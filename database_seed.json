{
  "chapters": [
    {
      "id": "chapter-00",
      "chapter_number": "00",
      "title": "序章",
      "subtitle": "找到你的位置",
      "icon": "🎯",
      "color": "#00ff9d",
      "order": 0
    },
    {
      "id": "chapter-01",
      "chapter_number": "01",
      "title": "第1章",
      "subtitle": "觉醒 - 从码农到指挥官",
      "icon": "⚡",
      "color": "#00d9ff",
      "order": 1
    },
    {
      "id": "chapter-02",
      "chapter_number": "02",
      "title": "第2章",
      "subtitle": "心法 - 核心思维",
      "icon": "🧠",
      "color": "#b600ff",
      "order": 2
    },
    {
      "id": "chapter-03",
      "chapter_number": "03",
      "title": "第3章",
      "subtitle": "技术 - 从想法到产品",
      "icon": "🛠️",
      "color": "#00ff9d",
      "order": 3
    },
    {
      "id": "chapter-04",
      "chapter_number": "04",
      "title": "第4章",
      "subtitle": "实战 - 从0到1开发个人工具",
      "icon": "💻",
      "color": "#ff6b00",
      "order": 4
    },
    {
      "id": "chapter-05",
      "chapter_number": "05",
      "title": "第5章",
      "subtitle": "精进 - 从「能用」到「好用」",
      "icon": "🚀",
      "color": "#ff006b",
      "order": 5
    },
    {
      "id": "chapter-99",
      "chapter_number": "99",
      "title": "附录",
      "subtitle": "工具箱与资源",
      "icon": "📚",
      "color": "#6b00ff",
      "order": 6
    },
    {
      "id": "chapter-101",
      "chapter_number": "101",
      "title": "预告",
      "subtitle": "下部预告",
      "icon": "🔮",
      "color": "#ff00d9",
      "order": 7
    }
  ],
  "lessons": [
    {
      "id": "lesson-001",
      "chapter_id": "chapter-00",
      "lesson_number": 1,
      "title": "找到你的位置",
      "content": "<h1>找到你的位置</h1>\n<p>这份教程写给谁 ​ 零基础从没接触过编程，看到代码就头疼？时代变了。AI 帮你处理复杂部分，你只需把想要的东西说清楚。就像告诉装修师傅\"我想要亮堂的客厅\"，你不需要自己砌墙接电线。文科生/商科生你可能觉得\"编程是理科生的事\"。但 Vibe Coding 的核心是表达、是把想法说清楚&mdash;&mdash;这恰恰是你的强项。在 AI 编程时代，文科生的优势比想象中大得多。理工科学生已经会写代码，为什么还要学？因为你正在从\"代码生产者\"变成\"代码指挥官\"。核心技能正在迁移：从\"写得出来\"到\"说得清楚 + 判断对错\"。职场人士想要个小工具，但技术部门排期三个月后？现在你可以自己动手&mdash;&mdash;快速做原型验证想法，用自然语言做数据分析，写自动化脚本告别重复劳动。创业者最怕花三个月开发，结果没人用。Vibe Coding 能帮你几小时内做出能跑的原型，快速测试市场反应，低成本试错。</p>\n<h1>学完获得 ​</h1>\n<p>一个亲手做出的作品能运行的网页或小工具，可以分享给别人看与 AI 协作的基本功表达想法、拆解任务、引导 AI 修复错误产品思维启蒙MVP 概念、功能取舍、写 AI 能读懂的需求继续探索的信心具备独立完成下一个项目的能力</p>\n<h1>学习路径 ​</h1>\n<p>本教程是整个体系的基础版： 完成后可进入进阶版，学习专业技术栈和完整产品开发流程。</p>",
      "word_count": 622,
      "estimated_time": 3
    },
    {
      "id": "lesson-002",
      "chapter_id": "chapter-01",
      "lesson_number": 1,
      "title": "1.1.1 2025 年，编程世界发生了什么",
      "content": "# 1.1.1 2025 年，编程世界发生了什么 ​\n\n## 一条推文引发的革命 ​\n\n2025年2月，前特斯拉AI总监、OpenAI联合创始人 Andrej Karpathy 在社交媒体上发了一条推文。\n\n他说：\n\n\"有一种新的编程方式，我称之为 'vibe coding'（氛围编程）。你完全沉浸在感觉中，拥抱指数级变化，甚至忘记代码的存在。\"\n\n这条推文引发广泛讨论的原因是——我们正在进入一个不需要\"写\"代码也能\"做\"软件的时代。\n\n## \"Vibe Coding\" 成为年度热词 ​\n\n2025年11月，柯林斯词典宣布：\"Vibe Coding\" 当选年度词汇。\n\n这个词的官方定义是：\n\n一种使用人工智能、通过自然语言描述来生成计算机代码的方式。\n\n换句话说，你不需要学什么编程语言，只要用自然语言告诉AI\"我想要一个XX\"，它就能帮你做出来。\n\n## 数据不会说谎 ​\n\n以下是相关数据：\n\nY Combinator 的惊人发现\n\n2025年3月，全球最著名的创业孵化器 Y Combinator 的CEO Garry Tan 透露：\n\n在最新一批创业公司中，有25%的公司报告——它们95%的代码是由AI生成的。\n\n这些不是玩票的业余项目，而是正在融资、正在增长的真实创业公司。\n\n更让人惊讶的是，这些公司的团队规模往往不到10人，却能做出以前需要几十人才能完成的产品。\n\n## 更多数据佐证 ​\n\n更多行业数据：\n指标数据使用AI编程工具的美国开发者92%全球代码中AI生成的比例41%Vibe Coding用户中非开发者占比63%使用AI后开发速度提升最高55%市场规模预测（2032年）从49亿→301亿美元\n数据来源：Second Talent 2025统计、Bubble调研报告\n\n注意那个 63%——超过一半的Vibe Coding用户根本不是程序员。他们是设计师、产品经理、创业者、甚至文科生。\n\n## 这意味着什么？ ​\n\n让我们把这几件事串起来：\n\n编程正在从\"专业技能\"变成\"通用工具\"。\n\n核心洞察\n\n就像 Excel 让每个人都能处理数据，Word 让每个人都能排版文档一样，AI 编程工具正在让每个人都能创造软件。\n\n## 小结 ​\n\n2025年是Vibe Coding元年。Karpathy提出概念，Collins词典收录为年度词汇，Y Combinator数据验证了这一趋势的实际影响。接下来，我们看看这场变革如何改变开发者的角色。",
      "word_count": 1039,
      "estimated_time": 3
    },
    {
      "id": "lesson-003",
      "chapter_id": "chapter-01",
      "lesson_number": 2,
      "title": "1.1.2 从 Coder 到 Commander 的角色转变",
      "content": "# 1.1.2 从 Coder 到 Commander 的角色转变 ​\n\n## 一个类比帮你理解 ​\n\n用开车来打个比方。\n\n手动挡时代（传统编程）想象从北京开车去上海。用手动挡，你需要熟练掌握离合器、换挡技巧，时刻关注转速，新手很容易熄火。这就像传统编程：必须掌握很多\"操作技巧\"，才能让程序跑起来。自动挡时代（代码补全）换成自动挡，不用管离合器和换挡，可以把更多注意力放在路况上。这就像 GitHub Copilot 等工具：AI 帮你补全代码片段，但你仍然需要懂代码、会\"开车\"。自动驾驶时代（Vibe Coding）自动驾驶出租车：你只需说\"我要去外滩\"，车子自己规划路线、自己开。走错了说一声就行。这就是 Vibe Coding：说清楚目的地，AI 完成所有操作。\n## 工作流程的变化 ​\n\n传统编程：\n\n- 学习编程语言：花几个月学 JavaScript、Python 或其他语言\n- 理解语法规则：记住各种括号、分号、缩进规则\n- 一行一行写代码：把每个功能都\"翻译\"成计算机能懂的指令\n- 不停地调试：程序报错了？自己一行行找问题\n- 查文档、问社区：遇到不会的，花几小时搜索解决方案\n整个过程像在学一门外语——你得先学会语法，才能表达自己想说的话。\n\nAI 时代：\n\n- 告诉 AI 你想要什么：\"帮我做一个待办清单，可以添加任务、标记完成、删除任务\"\n- 看 AI 生成代码：几秒钟后，代码就出现了\n- 试试看效果：运行一下，看看是不是你想要的\n- 告诉 AI 怎么改：\"把完成的任务变成灰色，加一个删除线\"\n- 继续迭代：直到满意为止\n整个过程更像在和一个懂技术的助手对话——你说想法，它来实现。\n\n## 核心技能的迁移 ​\n过去的核心技能现在的核心技能记住语法规则把需求说清楚手写代码判断代码对不对调试找bug描述问题让AI修阅读技术文档知道什么该问、什么该查\n用开车的类比：\n你需要知道的你不需要知道的我要去哪（需求）发动机怎么工作（底层原理）走哪条路更快（大方向）变速箱的原理（语法细节）到没到、对不对（验收）如何修车（手写每行代码）路况不对要调整（迭代）汽车电路图（复杂架构）\n一句话总结\n\n从\"写代码\"变成\"表达清楚 + 判断对错\"。\n\n## 什么没变 ​\n\n虽然\"怎么做\"变了，但有些东西永远不会变：\n\n- 你需要知道自己想要什么：AI再聪明，也不能替你想清楚要做什么\n- 你需要判断结果好不好：AI可能会出错，你得能看出来\n- 你需要有解决问题的思路：遇到问题时，知道怎么一步步排查\nAI 目前还不是\"完全自动驾驶\"\n\n就像今天的自动驾驶汽车，AI编程也需要你保持关注、随时接手、负最终责任。Vibe Coding 更像是\"L3 级自动驾驶\"——大部分时候AI来做，但你得盯着，关键时刻你得上。\n\nAI 接管了\"执行\"，但\"思考\"和\"决策\"还是你的事。\n\n## Context Engineering：进一步的进化 ​\n\n2025年下半年，行业开始从 Vibe Coding 进化到 Context Engineering（上下文工程）。\n\nVibe Coding 强调\"跟着感觉走\"，快速出结果。Context Engineering 则强调：给AI提供足够的上下文，让它理解你的项目背景、代码规范、业务逻辑。\n\n换句话说：想让AI帮得更好，你需要学会\"提供好的上下文\"。这也是本教程后面会重点教你的内容。\n\n## 这对你意味着什么 ​\n\n如果你会用滴滴打车，你就已经具备了 Vibe Coding 最核心的能力：\n\n- 说清楚你要去哪（表达需求）\n- 判断司机有没有走错路（验收结果）\n- 必要时给司机指路（引导调整）\n这取决于个人优势。如果你擅长表达、沟通，擅长想清楚需求，对细节敏感、能发现问题——这些都是你的优势。\n\n如果你之前总觉得\"编程太难了\"，很可能是因为你不擅长记语法、写代码——但那不是你真正的短板。真正重要的能力，你可能早就有了。",
      "word_count": 1645,
      "estimated_time": 3
    },
    {
      "id": "lesson-004",
      "chapter_id": "chapter-01",
      "lesson_number": 3,
      "title": "1.1.3 这对你意味着什么",
      "content": "# 1.1.3 这对你意味着什么 ​\n\n## 过去 vs 现在 ​\n过去：想做一个小工具？想法 → 学编程（3-6个月）→ 写代码 → 不断踩坑 → 可能放弃 → 或花几周做出来 → 勉强能用门槛高、周期长、容易放弃现在：想做一个小工具？想法 → 打开AI工具 → 说清楚你要什么 → 几分钟后看到结果 → 不满意？继续说 → 当天就能用门槛低、周期短、立刻能用\n## 具体能做什么？ ​\n\n以下是具体应用场景：\n\n### 给自己用 ​\n你的烦恼你可以做每天记不住喝了多少水喝水打卡小工具孩子的生日礼物清单总是乱礼物管理小应用想记录每天的开支专属记账本想背单词但市面上的App太复杂简单的单词卡片\n### 给工作用 ​\n你的烦恼你可以做Excel做数据汇总太麻烦自动化报表工具客户信息散落在各处简单的客户管理页面团队排班总是冲突排班协调小工具会议纪要格式不统一会议纪要模板生成器\n### 给创业用 ​\n你的想法你可以做想验证一个产品概念快速做出原型给用户看想做一个小众工具卖钱从MVP开始，边做边调整想给自己的服务做个网站几小时内上线一个落地页\n## 真实案例 ​\n\nCynthia Chen：产品设计师做出宠物App\n\nCynthia Chen是产品设计师，从未写过代码。她用Replit和Claude，花两个月业余时间做出狗狗品种识别App\"Dog-e-dex\"，成功上架App Store。（Business Insider 2025.5）\n\nRebecca Beach：月入$20,000的数字产品卖家\n\n前UX设计师Rebecca Beach用vibe coding制作数字产品（日记本、课程、工作簿），原本需要几周的工作现在2小时完成。她在Etsy和Shopify月销售额超过$20,000。（Business Insider 2025.8）\n\nTherese Waechter：贴纸店收入翻倍\n\nOtto's Grotto贴纸店店主Therese Waechter，用ChatGPT辅助文案和自动化流程，2024年收入比前一年翻倍。（Business Insider 2025.4）\n\n2025年调研显示，63%的Vibe Coding用户是非开发者。\n\n## 人人都能成为 Builder ​\n\n\"Builder\"这个词很难翻译，它比\"程序员\"的含义更广。\n\n一个 Builder 是能把想法变成现实的人。\n\n以前，成为 Builder 需要：\n\n- 会写代码，或者\n- 有钱雇人写代码\n现在，成为 Builder 只需要：\n\n- 有想法\n- 能把想法说清楚\n- 愿意花时间和AI一起迭代\n核心观点\n\nVibe Coding 不是让你成为程序员，而是让你成为 Builder。\n\n你的价值不在于\"会写代码\"，而在于\"知道要做什么\"和\"能判断做得好不好\"。\n\n## 你可能还有顾虑 ​\n\n### \"我怕做不好\" ​\n\n别担心。Vibe Coding 的核心精神就是**\"试错成本很低\"**。\n\n做得不好？改呗。 改崩了？让AI重来。 一个方案不行？换个思路再说。\n\n你会在后面的章节学到，怎么保存进度、怎么回退版本，让你放心大胆地试。\n\n### \"我的想法会不会太简单\" ​\n\n恰恰相反。简单的想法更容易成功。\n\n很多人失败是因为想法太复杂，而不是太简单。\n\n后面的\"心法\"章节会详细讲这个——如何设计一个\"刚刚好\"的第一版。\n\n### \"AI做的东西能用吗\" ​\n\n能用。\n\n对于个人工具、原型验证、小团队内部使用，AI生成的代码完全够用。\n\n当然，如果你要做一个面向百万用户的产品，那就需要更专业的方案——但那是后话，也是进阶版教程会讲的内容。\n\n## 也要知道边界 ​\n\n适合用Vibe Coding的场景：\n\n- 个人工具、原型验证、内部使用\n- 快速试错、验证想法\n- 学习和探索\n需要更专业方案的场景：\n\n- 面向大量用户的生产系统\n- 涉及敏感数据、金融交易的应用\n- 需要长期维护和迭代的大型项目\n安全提醒\n\n根据Wiz Research 2025年报告：\n\n- 1/5使用vibe coding的组织存在系统性安全风险\n- 常见问题：硬编码密码、客户端存储敏感信息、缺少访问控制\n- 约36%的AI生成代码可能包含安全漏洞\n如果你的应用涉及用户数据、支付等敏感场景，需要额外的安全审查。\n\nVibe Coding是一个强大的起点，但如果你想走得更远，后面还有很多东西要学。\n\n## 小结 ​\n\n本节小结\n\n- 编程门槛正在大幅降低，从\"学几个月才能开始\"变成\"今天就能上手\"\n- 你不需要成为程序员，但你可以成为 Builder\n- 成为 Builder 的核心能力是\"想清楚要做什么\"和\"判断做得对不对\"\n- 现在是最好的开始时机——这个浪潮才刚刚开始",
      "word_count": 1993,
      "estimated_time": 3
    },
    {
      "id": "lesson-005",
      "chapter_id": "chapter-01",
      "lesson_number": 4,
      "title": "1.2.1 什么是 Vibe Coding",
      "content": "# 1.2.1 什么是 Vibe Coding ​\n\n## 一句话解释 ​\n\nVibe Coding = 用自然语言告诉 AI 你想要什么，让 AI 帮你写代码。\n\n就像你跟一个超级能干的助手说：\"帮我做个能记录每天心情的小网页\"，然后它就做出来了。你不需要知道代码怎么写，你只需要说清楚你想要什么。\n\n关于 Vibe Coding 的由来（Karpathy 的推文、Collins 年度词汇），我们在 1.1.1 节 已经详细介绍过。这一节聚焦于：Vibe Coding 到底怎么用？\n\n## Vibe Coding 的四个核心特征 ​\n\n### 1. 用自然语言表达需求 ​\n\n你不需要写 `if...else...`、`for...loop...` 这些代码。\n\n你只需要说：\n\n- \"帮我做一个倒计时器\"\n- \"我想要一个能记录读书笔记的网页\"\n- \"做一个背单词的小程序\"\nAI 会理解你的意思，然后生成代码。\n\n### 2. 关注结果而非语法 ​\n\n传统编程里，你需要确保每一行代码的语法都正确。\n\nVibe Coding 让你从语法细节中解放出来，把精力放在\"结果对不对\"上。\n\n你不需要检查\"分号有没有漏\"、\"括号是否匹配\"——AI 会处理这些。但你需要验证：功能是不是你想要的？逻辑有没有明显问题？\n\n这是一种责任转移：语法交给 AI，结果审查交给你。\n\n### 3. 快速迭代，跟着感觉走 ​\n\n不满意？直接说：\n\n- \"按钮换成蓝色\"\n- \"字体再大一点\"\n- \"加一个分享功能\"\n几秒钟就能看到新结果。改到满意为止。\n\n### 4. 接受\"够用就好\"的起点 ​\n\nVibe Coding 生成的代码可能不是最优雅的，可能有冗余，可能不符合\"最佳实践\"。\n\n但对于起步阶段，这完全没问题。\n\n就像学骑自行车——先学会不摔倒，再谈姿势优美。先做出能用的东西，再逐步提高标准。\n\n后面的学习会帮你理解什么是\"更好的代码\"，现在先专注于\"做出来\"。\n\n## 一句话类比 ​\n\nVibe Coding 就是\"打车模式\"——你只负责说清楚目的地，AI 负责把你送到。（更详细的类比见 1.1.3 节）\n\n## 适用边界 ​\n\n关于 Vibe Coding 适合什么、不适合什么，我们在 1.1.3 节 已经讨论过。\n\n简单回顾：\n\n- ✅ 个人工具、快速验证、学习实验 → 适合 Vibe Coding\n- ❌ 高风险、长期维护、团队协作 → 需要 Spec Coding（下一节讲）\n## 常见误解澄清 ​\n\n### Vibe Coding 是不是就是瞎搞？ ​\n\n不是。Vibe Coding 是一种有意识的选择——在合适的场景下，用最快的方式达到目标。这不是\"不负责任\"，而是\"把精力放在更重要的地方\"。\n\n### 出了问题怎么办？ ​\n\n把错误信息复制给 AI，让 AI 帮忙修复。这就是 Vibe Coding 的核心循环：\n\n描述需求 → 生成代码 → 测试 → 发现问题 → 描述问题 → AI 修复 → 重复\n\n随着使用次数增多，你会自然地开始理解代码在做什么。这不是必须的，但会让你和 AI 的协作更高效。\n\n### 这样学不到编程吧？ ​\n\nVibe Coding 是一个起点，不是终点。\n\n很多人通过 Vibe Coding 做出第一个作品后产生了兴趣，反过来开始学习代码背后的原理。先有成就感，再谈深入学习——这才符合人性。\n\n本教程的进阶版会带你逐步理解更多技术细节，但那是后话。现在，先专注于做出东西。\n\n小结\n\n- Vibe Coding 是 2025 年最火的编程方式，由 Andrej Karpathy 提出\n- 核心是：用自然语言描述需求，让 AI 生成代码\n- 适合个人项目、快速验证、学习实验\n- 不适合高风险、长期维护、团队协作的场景\n下一节，我们来看看另一种 AI 编程方式：Spec Coding——当项目变复杂时，你可能需要它。",
      "word_count": 1644,
      "estimated_time": 3
    },
    {
      "id": "lesson-006",
      "chapter_id": "chapter-01",
      "lesson_number": 5,
      "title": "1.2.2 什么是 Spec Coding（规范驱动开发）",
      "content": "# 1.2.2 什么是 Spec Coding（规范驱动开发） ​\n\n## 一句话解释 ​\n\nSpec Coding = 先写清楚\"要做什么\"，再让 AI 按规范生成代码。\n\n如果说 Vibe Coding 是\"打车说目的地\"，那 Spec Coding 就是\"给司机一份详细的路线图\"。\n\n## 为什么需要 Spec Coding？ ​\n\nVibe Coding 很爽，但当项目变复杂时，你会遇到问题：\n\n- 功能越加越多，AI 开始\"忘记\"之前的需求\n- 改一个地方，另一个地方莫名其妙坏了\n- 你自己都记不清最初想做什么了\n- 和别人协作时，说不清楚项目要做成什么样\n这时候，你需要一种更\"规范\"的方式——Spec Coding。\n\n## 行业趋势：Spec Coding 正在成为主流 ​\n\n2025年，越来越多的工具开始支持 Spec Coding 方式：\n\n- \nAmazon Kiro：AWS 推出的 AI IDE，核心卖点就是\"Spec-Driven Development\"。它要求你先写 requirements.md、design.md、tasks.md，然后 AI 按规范生成代码。\n\n- \nGitHub Spec Kit：GitHub 推出的规范工具包，帮助团队在 AI 编程时代建立\"活文档\"（living documents）——随项目演进的规范。\n\n- \nJetBrains Junie：JetBrains 的 AI 编程助手，官方教程明确推荐\"先写需求文档，再让 AI 生成开发计划\"。\n\n这说明什么？Spec Coding 不是\"麻烦\"，而是让 AI 更好地帮你的方法。\n\n工具越来越智能，但\"想清楚要做什么\"这件事，永远是人类的工作。\n\n## Spec Coding 的核心思路 ​\n\nSpec 是 Specification 的缩写，意思是\"规格说明书\"。\n\nSpec Coding 的核心是：先想清楚、写清楚，再动手。\n\n你需要先产出一些文档，让 AI（和你自己）都清楚：\n\n- 要做什么\n- 怎么做\n- 分几步做\n然后 AI 按照这些文档来生成代码。\n\n## Spec Coding 的三件套文档 ​\n\nSpec Coding 的核心产物是三份文档。别被\"文档\"吓到——它们可以很简单，关键是有总比没有好。\n\n### 1. requirements.md（需求文档） ​\n\n回答的问题：要做什么？\n\n内容包括：\n\n- 产品是什么\n- 用户是谁\n- 核心功能有哪些\n- 不做什么（同样重要！）\n示例（简化版）：\nmarkdown\n`# 背单词 App 需求文档\n\n## 产品概述\n一个帮助用户每天背 20 个单词的网页应用。\n\n## 目标用户\n准备四六级考试的大学生。\n\n## 核心功能（P0）\n1. 每天展示 20 个单词\n2. 用户可以标记\"认识\"或\"不认识\"\n3. 查看今日学习进度\n\n## 不包含（Out of Scope）\n- 用户注册登录\n- 单词发音\n- 多设备同步`\n### 2. design.md（设计文档） ​\n回答的问题：怎么做？\n\n内容包括：\n\n- 技术选型（用什么工具/框架）\n- 数据结构（信息怎么组织）\n- 页面结构（有几个页面，每个页面干什么）\n示例（简化版）：\nmarkdown\n`# 背单词 App 设计文档\n\n## 技术选型\n- 纯前端实现，使用 HTML + CSS + JavaScript\n- 数据存储：LocalStorage\n\n## 数据结构\n- 单词列表：[{ word: \"apple\", meaning: \"苹果\", status: \"unknown\" }, ...]\n- 学习进度：{ total: 20, learned: 5, date: \"2025-01-15\" }\n\n## 页面结构\n1. 首页：显示今日进度，开始学习按钮\n2. 学习页：卡片式展示单词，认识/不认识按钮\n3. 结果页：今日学习总结`\n### 3. tasks.md（任务清单） ​\n回答的问题：分几步做？\n\n把大目标拆成小任务，每个任务都是一次可以完成的事。\n\n示例（简化版）：\nmarkdown\n`# 背单词 App 任务清单\n\n## 第一阶段：基础框架\n- [ ] 创建项目基本文件结构\n- [ ] 实现首页 UI\n- [ ] 准备 20 个测试单词数据\n\n## 第二阶段：核心功能\n- [ ] 实现单词卡片展示\n- [ ] 实现\"认识/不认识\"按钮功能\n- [ ] 实现进度统计\n\n## 第三阶段：数据持久化\n- [ ] 用 LocalStorage 保存学习记录\n- [ ] 实现\"继续昨天的进度\"功能`\n## Spec Coding vs Vibe Coding 对比 ​\n维度Vibe CodingSpec Coding启动速度快，说干就干慢，需要先写文档适合项目规模小（1-3 个功能）中大（5 个以上功能）代码质量够用就行相对规范可维护性低，改着改着可能乱高，有文档可追溯协作友好度低，别人看不懂高，文档是沟通工具学习曲线平，马上能上手陡一点，要学写文档\n## 一个类比 ​\n还是用出行来类比：\n场景你会怎么做？去楼下便利店直接走（Vibe Coding）第一次去一个陌生城市旅游先做攻略，列出要去的景点、路线（Spec Coding）\n简单任务，直接干；复杂任务，先规划。\n\n## 常见问题 ​\n\n### 写文档好麻烦，能不能让 AI 帮忙？ ​\n\n完全可以。直接告诉 AI：\"我想做一个背单词的应用，帮我写一份简单的需求文档，包括产品概述、目标用户、核心功能和不做什么。\" AI 会给出初稿，在此基础上修改即可。\n\n### 文档要写多详细？ ​\n\n够用就行。个人项目几行字的清单就够；团队项目需要把每个功能的输入输出写清楚；生产级项目则需要更专业的格式（超出本教程范围）。\n\n### Vibe 和 Spec 能混着用吗？ ​\n\n不仅能，而且推荐这样做。很多人的实际工作流是：先 Vibe Coding 快速搭原型 → 验证通过后补文档 → 后续迭代用 Spec Coding 方式。\n\n小结\n\n- Spec Coding 是\"先规划，再动手\"的 AI 编程方式\n- 核心产物是三件套文档：需求、设计、任务清单\n- 适合复杂项目、团队协作、长期维护的场景\n- 可以和 Vibe Coding 混合使用\n下一节详细讨论：如何判断什么时候用 Vibe，什么时候用 Spec？",
      "word_count": 2682,
      "estimated_time": 5
    },
    {
      "id": "lesson-007",
      "chapter_id": "chapter-01",
      "lesson_number": 6,
      "title": "1.2.3 Vibe vs Spec：什么时候用什么",
      "content": "# 1.2.3 Vibe vs Spec：什么时候用什么 ​\n\n学完了 Vibe Coding 和 Spec Coding，下一个问题是：项目到底该用哪个？\n\n这一节提供一个简单的决策框架。\n\n## 三个问题快速判断 ​\n\n在开始一个项目前，问自己三个问题：\n问题需要 Spec 的信号功能数量超过 5 个功能使用者给客户/团队用时长需要长期维护\n判断规则：如果有 2 个以上回答\"需要 Spec\"，就用 Spec Coding；否则 Vibe Coding 即可。\n\n## 决策流程图 ​\n\n简单记：小项目、自己用、短期使用 → Vibe；大项目、给别人、长期维护 → Spec。\n\n## 混合使用：最佳实践 ​\n\n实际工作中，你不需要非此即彼。很多时候，混合使用效果最好。\n\n### 模式 1：Vibe 起步，Spec 收尾 ​\n\n适合场景：你有个想法，不确定能不能做出来。\n\n流程：\n\n- 先用 Vibe Coding 快速做个最小原型\n- 验证想法可行后，暂停写代码\n- 补上需求文档和任务清单\n- 后续开发用 Spec Coding 方式\n好处：不会在一个不靠谱的想法上浪费时间写文档。\n\n### 模式 2：Spec 规划，Vibe 执行 ​\n\n适合场景：你很清楚要做什么，只是需要 AI 帮你快速实现。\n\n流程：\n\n- 先花 10 分钟写个简单的需求清单\n- 把清单分成小任务\n- 每个小任务用 Vibe Coding 快速完成\n- 完成后检查是否符合需求\n好处：既有方向感，执行又快。\n\n### 模式 3：渐进式演进 ​\n\n适合场景：项目会逐渐变大，一开始不知道会发展成什么样。\n\n流程：\n\n- 第一版：纯 Vibe，快速上线\n- 开始有用户反馈，功能变多：补上简单文档\n- 用户越来越多，需要稳定：正式用 Spec 方式管理\n好处：按需投入，不过度设计。\n\n## 实际案例 ​\n\n### 案例 1：做一个番茄钟小工具 ​\n\n分析：\n\n- 功能：倒计时 + 开始/暂停 + 提醒 = 3 个功能\n- 使用者：自己\n- 时长：用几周就可能换别的\n决定：Vibe Coding\n\nPrompt 示例：\n\n\"帮我做一个番茄钟网页，25 分钟倒计时，有开始、暂停、重置按钮，时间到了弹窗提醒。\"\n\n### 案例 2：做一个团队内部的日报系统 ​\n\n分析：\n\n- 功能：写日报 + 查看历史 + 按人筛选 + 按日期筛选 + 导出 + 统计 = 6 个功能\n- 使用者：团队 10 个人\n- 时长：长期使用\n决定：Spec Coding\n\n第一步：先写需求文档\n\n\"帮我写一份'团队日报系统'的需求文档，包括产品概述、目标用户、核心功能（写日报、查看历史、按人筛选、按日期筛选、导出、统计）和不做什么。\"\n\n### 案例 3：验证一个创业想法 ​\n\n分析：\n\n- 想法：一个帮人匹配学习伙伴的平台\n- 不确定能不能做出来\n- 不确定有没有人用\n决定：先 Vibe，再看情况\n\n流程：\n\n- 用 Vibe Coding 做一个最简单的版本（只有填表单 + 看匹配结果）\n- 发给 10 个朋友试用\n- 如果反馈好，再补文档、做完整版\n## 记住一句话 ​\n\n先开始，再完善。\n\n不要在\"用 Vibe 还是 Spec\"上纠结太久。如果纠结，就先 Vibe 起来；做着做着发现乱了，再停下来补文档。这本身就是一种学习过程。没有人第一次就选对，重要的是开始。\n\n## 快速检查清单 ​\n\n开始项目前，花 30 秒过一遍：功能超过 5 个吗？要给别人用吗？要长期维护吗？\n\n如果有 2 个以上回答\"是\"，建议用 Spec Coding；否则 Vibe Coding 即可。\n\n小结\n\n- 小项目、自己用、短期使用 → Vibe Coding\n- 大项目、给别人、长期用 → Spec Coding\n- 可以混合使用：Vibe 起步 + Spec 收尾 是常见模式\n- 不要纠结，先开始，做着再调整\n下一节，我们来学习一些 AI 编程中必须知道的核心概念：Prompt、Context、Token 等。",
      "word_count": 1697,
      "estimated_time": 3
    },
    {
      "id": "lesson-008",
      "chapter_id": "chapter-01",
      "lesson_number": 7,
      "title": "1.2.4 其他你需要知道的概念",
      "content": "# 1.2.4 其他你需要知道的概念 ​\n\n在使用 AI 编程的过程中，你会经常遇到一些术语。这一节，我们用最简单的方式把它们讲清楚。\n\n不需要死记硬背，用到的时候回来查就行。\n\n## Prompt（提示词） ​\n\n### 一句话解释 ​\n\nPrompt 就是你对 AI 说的话。\n\n你输入什么，AI 就根据你的输入生成回应。这个输入就叫 Prompt。\n\n### 类比 ​\n\nPrompt 就像你在餐厅点菜时对服务员说的话：\n\n- \"来一碗牛肉面\" → 简单 Prompt\n- \"来一碗牛肉面，不要香菜，少放辣，面要硬一点\" → 详细 Prompt\n说得越清楚，得到的结果越符合你的期望。\n\n### 好 Prompt vs 差 Prompt ​\n差 Prompt好 Prompt\"帮我做个网站\"\"帮我做一个个人博客首页，要有标题、简介、三篇文章列表，风格简洁现代\"\"这个代码有问题\"\"这段代码运行时报错 'undefined is not a function'，错误出现在第 15 行，帮我看看怎么修\"\n### 你需要记住的 ​\n\n写 Prompt 就像写微信消息——说清楚你想要什么，对方才能帮到你。\n\n## Context（上下文） ​\n\n### 一句话解释 ​\n\nContext 是 AI 在回答你时能\"看到\"的所有信息。\n\n包括：\n\n- 你当前说的话\n- 你之前说的话\n- 你给 AI 看的文件、代码\n- AI 自己之前的回复\n### 类比 ​\n\n想象你和朋友聊天：\n\n- 如果你们刚认识，你说\"那个事怎么样了\"，对方会一脸懵\n- 如果你们聊了很久，对方知道\"那个事\"指什么，就能回答\nAI 也一样。它能\"记住\"多少，取决于 Context 有多大。\n\n### Context Window（上下文窗口） ​\n\n每个 AI 模型能\"记住\"的信息量是有限的，这个限制叫 Context Window。\n模型大约能记住多少早期模型几千字GPT-4约 2.5 万字Claude 3约 15 万字更新的模型可能更多\n### 为什么重要 ​\n\n如果你的对话太长，或者给 AI 看的文件太大，它可能会\"忘记\"早期的内容。\n\n更重要的是：提供好的 Context 是让 AI 更好地帮你的关键。\n\nAI 不会读心术。你给它的背景信息越清晰、越相关，它生成的代码就越符合你的预期。这也是为什么 Spec Coding 要先写文档——文档本身就是给 AI 的 Context。\n\n实用技巧：\n\n- 重要的信息放在最前面或最后面（AI 对这两个位置记忆更好）\n- 对话太长时，开一个新对话，把关键信息重新说一遍\n- 在项目中维护一份\"项目背景\"文档，每次对话时可以快速提供给 AI\n## Hallucination（幻觉） ​\n\n### 一句话解释 ​\n\n幻觉 = AI 一本正经地胡说八道。\n\nAI 有时候会编造看起来很合理、但实际上是错的信息。\n\n### 例子 ​\n\n你问 AI：\"XXX 这个函数怎么用？\"\n\nAI 可能会给你一个详细的说明，但这个函数根本不存在——它是 AI \"编\"出来的。\n\n### 为什么会这样 ​\n\nAI 不是\"查资料\"，而是\"根据模式生成文字\"。它不知道自己说的是真是假，它只知道\"这样说看起来很合理\"。\n\n### 如何应对 ​\n\n- 验证：AI 说的东西，尤其是具体的函数名、API、数据，要自己核实\n- 怀疑：如果 AI 说得太肯定、太详细，反而要多留个心眼\n- 让它引用来源：问 AI \"你说的这个信息来自哪里？\"（虽然它可能继续编，但会降低胡说的概率）\n### 你需要记住的 ​\n\nAI 是助手，不是权威。它说的话要验证，不能全信。\n\n## Agent（智能体） ​\n\n### 一句话解释 ​\n\nAgent = 能自己规划、自己行动的 AI。\n\n普通的 AI 是\"你问一句，它答一句\"。\n\nAgent 是\"你给它一个目标，它自己想办法完成\"。\n\n### 类比 ​\n类型类比普通 AI问路人\"去火车站怎么走\"，他告诉你路线Agent告诉司机\"带我去火车站\"，他自己规划路线、开车、到达\n### 在 AI 编程中的应用 ​\n\n- 普通 AI：你说\"帮我写一个登录功能\"，它给你代码\n- Agent：你说\"帮我做一个完整的用户系统\"，它自己分析需求、创建文件、写代码、测试、修 bug...\n### 常见的 Agent 工具 ​\n\n- Cursor 的 Composer（多文件协作模式）\n- Replit Agent\n- Claude 的 Artifacts\n- GitHub Copilot Workspace\n### 你需要记住的 ​\n\nAgent 更强大，但也更不可控。对于新手，建议先用普通 AI，等熟悉了再尝试 Agent。\n\n## MCP（Model Context Protocol） ​\n\n### 一句话解释 ​\n\nMCP = 让 AI 能连接外部工具和数据的标准协议。\n\n### 类比 ​\n\n想象 AI 是一个很聪明的人，但它被关在一个房间里，只能通过窗口和你对话。\n\nMCP 就像给这个房间开了几扇门：\n\n- 一扇门通向数据库\n- 一扇门通向文件系统\n- 一扇门通向互联网\n- ...\n有了这些门，AI 能做的事情就多多了。\n\n### 为什么重要 ​\n\n没有 MCP 时，你需要手动把信息复制给 AI。\n\n有了 MCP，AI 可以直接读取你的文件、查询数据库、调用 API。\n\n### 你需要知道的 ​\n\nMCP 是 2024-2025 年兴起的新标准。如果你用 Cursor、Claude Desktop 等工具，可能会看到 MCP 相关的设置。\n\n现阶段：知道有这个东西就行，不需要深入了解。等你用到的时候再学。\n\n## Token（令牌）与计费 ​\n\n### 一句话解释 ​\n\nToken 是 AI 处理文字的基本单位。AI 服务按 Token 数量收费。\n\n### Token 是什么 ​\n\nAI 不是一个字一个字读你的文字，而是把文字切成小块来处理。这些小块叫 Token。\n\n大致换算（英文）：\n\n- 1 个 Token ≈ 4 个字符\n- 100 个 Token ≈ 75 个单词\n中文的话，1 个汉字通常是 1-2 个 Token。\n\n### 为什么重要 ​\n\n- 影响能处理的信息量：Context Window 通常用 Token 数来衡量\n- 影响费用：AI 服务按输入 Token + 输出 Token 收费\n### 计费逻辑（以 API 调用为例） ​\n\n`费用 = (输入 Token 数 × 输入单价) + (输出 Token 数 × 输出单价)`不同模型价格差异很大：\n模型大约价格（每百万 Token）GPT-4o$2.5 - $10Claude 3.5 Sonnet$3 - $15更便宜的模型$0.1 - $1\n### 如何省 Token ​\n\n- Prompt 写得精炼：废话少说\n- 不要重复粘贴大段代码：只粘相关部分\n- 用更便宜的模型做简单任务\n### 你需要记住的 ​\n\n- 如果用免费工具（如 ChatGPT 免费版），不用操心 Token\n- 如果用付费 API，注意控制用量，尤其是在调试时\n- Cursor 等工具通常有用量限制，超了要加钱\n## 概念速查表 ​\n概念一句话解释生活类比Prompt你对 AI 说的话点菜时说的话ContextAI 能看到的所有信息聊天记录Context WindowAI 能记住的信息量上限记忆力HallucinationAI 一本正经地胡说随口编的\"事实\"Agent能自己规划行动的 AI自动驾驶 vs 导航MCP让 AI 连接外部工具的协议USB 接口TokenAI 处理文字的单位计费单位\n学习建议\n\n这些概念不需要现在就全部记住。\n\n现在：大致知道每个概念是什么意思就够了。\n\n以后：用到的时候回来查，多用几次自然就记住了。\n\n章节小结\n\n恭喜你完成了第 1.2 节的学习！\n\n你现在已经知道了：\n\n- Vibe Coding 是什么，适合什么场景\n- Spec Coding 是什么，什么时候需要它\n- 如何选择和混合使用这两种方式\n- AI 编程中的核心术语\n下一节，我们将破除一些常见的编程迷信，让你轻装上阵！",
      "word_count": 3431,
      "estimated_time": 6
    },
    {
      "id": "lesson-009",
      "chapter_id": "chapter-01",
      "lesson_number": 8,
      "title": "1.3.1 迷信一：编程需要数学很好",
      "content": "# 1.3.1 迷信一：\"编程需要数学很好\" ​\n\n\"我高中数学就不好，肯定学不了编程。\"\n\n这大概是我听过最多的借口了。\n\n让我告诉你真相：日常编程 95% 用不到高中以上的数学。\n\n## 编程真正需要的\"数学\" ​\n\n先来看看，做一个网站或者小工具，你需要什么数学？\n你可能担心的实际需要的高等数学、微积分加减乘除线性代数比较大小（大于、小于）概率统计简单的百分比算法复杂度数数（1, 2, 3...）\n没开玩笑。\n\n做一个待办清单应用，你需要的数学是：\n\n- 数一数有几个任务（加法）\n- 完成了几个（减法）\n- 完成率是多少（除法，而且 AI 会帮你算）\n做一个记账工具，你需要的数学是：\n\n- 这个月花了多少（加法）\n- 还剩多少预算（减法）\n这些，小学三年级就学过了。\n\n## 那为什么大家觉得编程需要数学好？ ​\n\n因为顶尖的程序员确实需要数学。\n\n- 写游戏引擎的人，需要线性代数\n- 做机器学习的人，需要概率统计\n- 做金融交易系统的人，需要复杂的数学模型\n但这就像说\"厨师需要懂分子料理\"一样。\n\n顶级厨师确实需要。但你在家做个西红柿炒蛋，需要吗？\n\n大多数编程工作，不需要高深数学。\n\n而用 AI 做个人工具？更不需要。\n\n## 你真正需要的是什么 ​\n\n与其担心数学，不如关注这些：\n\n### 1. 逻辑思维 ​\n\n能想清楚\"先做什么，后做什么\"就够了。\n\n比如：用户点击按钮 → 显示结果。这就是逻辑。\n\n### 2. 耐心 ​\n\n代码报错了，愿意再试一次。AI 会帮你修。\n\n### 3. 表达能力 ​\n\n能把你想要的东西说清楚。这比数学重要得多。\n\n## 真实案例 ​\n\n小王，文科生，数学从小到大都是短板\n\n她高中时数学经常不及格，高考也是靠其他科目拉分。\n\n她用 AI 做了一个\"每日阅读打卡\"小程序。\n\n整个过程用到的\"数学\"：\n\n- 今天是第几天（加 1）\n- 连续打卡了多少天（计数）\n- 总共读了多少本书（加法）\n她说：\n\n\"我一开始也担心数学不好。后来发现，我只需要告诉 AI '我要一个打卡功能'，它就帮我实现了。根本不需要我算什么。\"\n\n## 小结 ​\n迷信真相编程需要数学很好日常编程只需要小学数学看不懂算法就做不了AI 会帮你处理算法数学不好的人不适合编程表达能力比数学重要\n数学不是门槛。不要让这个借口阻止你。\n\n给自己的话\n\n如果你数学不好，恭喜你！\n\n你不会过度依赖\"自己算\"，反而会更自然地让 AI 帮你。\n\n这在 AI 编程时代，其实是一个优势。\n\n下一个迷信：要先学好英文？",
      "word_count": 1069,
      "estimated_time": 3
    },
    {
      "id": "lesson-010",
      "chapter_id": "chapter-01",
      "lesson_number": 9,
      "title": "1.3.2 迷信二：要先学好英文",
      "content": "# 1.3.2 迷信二：\"要先学好英文\" ​\n\n\"代码都是英文的，我英语不好，肯定看不懂。\"\n\n这个担忧，放在五年前可能有点道理。\n\n但现在？完全不用担心。\n\n## 2025 年，AI 懂中文 ​\n\n现在的 AI 编程工具，几乎都能理解中文。\n\n你完全可以这样和 AI 对话：\n\n`帮我做一个网页，显示当前的北京时间，\n背景用浅蓝色，字体要大一点。`AI 会直接生成代码。你不需要写一个英文单词。\n\n## 中文 Prompt vs 英文 Prompt ​\n\n很多人问：用英文是不是效果更好？\n\n对于大多数场景，差别不大。\n场景中文表现建议日常开发需求✅ 完全够用用中文描述界面样式✅ 完全够用用中文解释代码报错✅ 完全够用用中文涉及专业术语⚠️ 偶尔需要英文混用即可\n举个例子，这两个 Prompt 效果几乎一样：\n\n中文版：\n\n`做一个按钮，点击后显示\"你好世界\"`英文版：\n\n`Create a button that shows \"Hello World\" when clicked`\n## 实用建议：混用策略 ​\n最佳实践是中英混用：\n\n- 描述需求用中文（说得更清楚）\n- 遇到专业术语保留英文（减少歧义）\n比如：\n\n`帮我做一个 login 页面，包含用户名和密码输入框，\n用 flexbox 居中显示，样式参考 Material Design。`这样的混用方式，AI 完全能理解。\n\n## 那代码里的英文呢？ ​\n\n代码本身确实是英文的。但你需要\"精通\"它吗？\n\n不需要。\n\n你需要做的是：\n\n- 告诉 AI 你想要什么（用中文）\n- 验证效果对不对（运行看结果）\n- 不对就告诉 AI 哪里不对（用中文描述问题）\n起步阶段，你不需要看懂每一行代码。但随着使用次数增多，你会自然地开始认识一些常见的英文单词和代码结构——这不是必须的，但会让你和 AI 协作更顺畅。\n\n好消息是：代码里的英文单词就那么几十个常用的。用着用着就熟了。\n\n## 真实案例 ​\n\n李阿姨，58 岁，英语只会说 \"Hello\"\n\n她女儿教她用 AI 做了一个\"菜谱收藏\"网页。\n\n整个过程：\n\n- 李阿姨说：\"我想把我的拿手菜做成一个网页\"\n- 女儿帮她打成文字发给 AI\n- AI 生成了网页\n- 李阿姨说：\"字太小了\"，女儿再发给 AI\n- 搞定\n李阿姨全程没写一个英文单词。\n\n她说：\n\n\"我以为要学英语才能做网站，结果跟说话一样。\"\n\n## 小结 ​\n迷信真相编程必须用英文中文 Prompt 完全可行代码是英文的，看不懂Vibe Coding 不需要读懂代码英文好才能学好编程表达清楚比英语好重要\n语言不是障碍。AI 是你的翻译官。\n\n给自己的话\n\n如果你英语不好，没关系。\n\n先用中文把想法说清楚，这是最重要的。\n\n等你做出几个项目，自然会慢慢认识一些英文单词。\n\n那时候再学，有目标、有动力，效率反而更高。\n\n下一个迷信：需要懂很多技术名词？",
      "word_count": 1222,
      "estimated_time": 3
    },
    {
      "id": "lesson-011",
      "chapter_id": "chapter-01",
      "lesson_number": 10,
      "title": "1.3.3 迷信三：需要懂很多技术名词",
      "content": "# 1.3.3 迷信三：\"需要懂很多技术名词\" ​\n\n\"什么 API、框架、后端、数据库……听都听不懂，怎么学？\"\n\n如果你听到这些词就头大，我理解你。\n\n但我要告诉你一个好消息：你不需要先学会这些词，再开始做东西。\n\n## 传统学习 vs AI 时代学习 ​\n\n传统方式：\n\n`学概念 → 学语法 → 学框架 → 做项目\n（可能需要半年到一年）`AI 时代的方式：\n\n`说出你想要的 → 做出来 → 遇到问题再学\n（可能只需要一下午）`顺序完全反过来了。\n\n你不需要先搞懂什么是\"前端\"、\"后端\"、\"数据库\"，才能做一个网站。\n\n你只需要说：\"帮我做一个能记录待办事项的网页\"。\n\nAI 会帮你处理所有技术细节。\n\n## 那些名词到底是什么？ ​\n\n如果你好奇，我用最简单的话解释几个常见的：\n技术名词大白话解释前端用户能看到的部分（页面、按钮、颜色）后端用户看不到的部分（数据处理、存储）API两个程序之间的\"传话筒\"数据库存数据的地方，像个超级 Excel框架别人写好的代码模板，让你不用从零开始部署把你的网站放到网上，让别人能访问\n知道这些就够了。 用到的时候再深入了解。\n\n## 边做边学的正确姿势 ​\n\n与其先啃概念，不如：\n\n### Step 1：先动手做 ​\n\n不管懂不懂，先让 AI 帮你生成代码，看看效果。\n\n### Step 2：遇到问题，问 AI ​\n\n`AI 说要配置一个 API，这是什么意思？\n能用更简单的话解释一下吗？`\n### Step 3：记住\"够用就好\" ​\n不需要完全理解每个概念。知道它是干什么的，能用就行。\n\n### Step 4：逐渐积累 ​\n\n做的项目多了，这些词自然就熟悉了。\n\n## 真实案例 ​\n\n张老师，45 岁，小学语文老师\n\n她想做一个\"学生作业提交\"的小网页。\n\n一开始，她完全不懂什么是\"前端\"、\"后端\"。\n\n她就直接告诉 AI：\n\n`我想做一个网页，学生可以输入自己的名字，\n然后上传作业文件，我能看到谁提交了。`AI 帮她生成了代码。她看了效果，发现可以用。\n\n三个月后，她已经知道：\n\n- \"前端\"就是学生看到的提交页面\n- \"后端\"就是处理上传文件的部分\n- \"数据库\"就是存储提交记录的地方\n这些概念，她是做完项目之后才真正理解的。\n\n她说：\n\n\"如果让我先学这些概念，我可能学两周就放弃了。但先做出来，再回头看，一下子就懂了。\"\n\n## 一个小提醒 ​\n\n虽然不需要先学概念，但有一个能力很重要：\n\n愿意搜索和提问。\n\n遇到不懂的词，你可以：\n\n- 直接问 AI：\"XX 是什么意思？\"\n- 用搜索引擎查一下\n- 在本教程的附录术语表里找\n好奇心比知识储备更重要。\n\n## 小结 ​\n迷信真相要先学会技术名词边做边学，遇到再查不懂概念就做不了AI 会帮你处理技术细节学编程要从基础学起先做出东西，再补基础\n不要让\"不懂\"成为\"不做\"的借口。\n\n给自己的话\n\n学习新东西，最有效的方式不是\"先学后用\"，而是\"边用边学\"。\n\n就像学游泳。你可以在岸上看一年的教程，也可以直接跳下水扑腾。\n\n哪种方式学得更快？你懂的。\n\nAI 就是你的游泳圈。先跳下去，别怕。\n\n下一个迷信：Vibe Coding 只是玩具？",
      "word_count": 1340,
      "estimated_time": 3
    },
    {
      "id": "lesson-012",
      "chapter_id": "chapter-01",
      "lesson_number": 11,
      "title": "1.3.4 迷信四：Vibe Coding 只是玩具",
      "content": "# 1.3.4 迷信四：\"Vibe Coding 只是玩具\" ​\n\n\"用 AI 写代码？那不就是玩玩吗，能做正经东西吗？\"\n\n这个问题问得好。\n\n诚实的回答是：有边界，但能做的事情比你想象的多得多。\n\n## Vibe Coding 能做什么 ​\n\n先说能做的。这个清单可能会让你惊讶：\n\n### 个人工具类 ​\n\n- ✅ 待办清单、记账本、习惯打卡\n- ✅ 个人博客、作品集网站\n- ✅ 简历页面、个人主页\n- ✅ 学习笔记整理工具\n### 工作效率类 ​\n\n- ✅ 数据可视化看板\n- ✅ 表单收集工具\n- ✅ 简单的自动化脚本\n- ✅ 内部使用的小工具\n### 创意项目类 ​\n\n- ✅ 互动网页、小游戏\n- ✅ 活动邀请函、电子贺卡\n- ✅ 产品原型、概念验证\n- ✅ 数据分析报告\n### 学习项目类 ​\n\n- ✅ 课程作业、毕业设计原型\n- ✅ 技术概念验证\n- ✅ 个人技能展示\n这些，Vibe Coding 都能搞定。\n\n## Vibe Coding 不适合什么 ​\n\n但也有一些场景，纯 Vibe Coding 确实不太够：\n场景为什么不适合涉及资金交易安全性要求高，需要专业审计处理敏感数据隐私合规要求，不能靠\"差不多\"高并发系统性能优化需要专业知识长期维护的产品代码质量和可维护性很重要对外发布的商业产品需要更严谨的开发流程\n这些场景需要专业开发者介入，或者你需要进阶学习更多知识。\n\n## 正确的定位 ​\n\n把 Vibe Coding 想象成瑞士军刀：\n\n- 它不是专业的厨师刀，切不了最复杂的菜\n- 但它能帮你解决 80% 的日常需求\n- 而且随身携带，随时能用\nVibe Coding 的价值在于：\n\n- 快速验证想法：几小时做出原型，而不是几周\n- 降低入门门槛：不需要先学半年再动手\n- 自己解决小问题：不用等技术部门排期\n- 学习的起点：从做出东西开始，再深入学习\n## 真实数据 ​\n\n来看看一些有意思的数据：\n\nY Combinator 2025 年的统计：\n\n25% 的创业公司，代码的 95% 是 AI 生成的\n\n这些不是玩具项目，而是拿到投资、有用户的真实产品。\n\nGitHub 2024 年的调查：\n\n使用 AI 编程工具的开发者，编码速度提升 55%\n\n连专业开发者都在用 AI 辅助。\n\n关键不在于\"用不用 AI\"，而在于\"用得好不好\"。\n\n## 从\"玩具\"到\"工具\"的进阶路径 ​\n\n如果你担心 Vibe Coding 只是玩玩：\n\n### 阶段 1：纯 Vibe ​\n\n- 用自然语言描述需求\n- AI 生成代码\n- 看效果、调整、迭代\n你能做出：个人工具、简单网页\n\n### 阶段 2：Vibe + 代码阅读 ​\n\n- 开始看懂 AI 生成的代码\n- 理解大致的结构和逻辑\n你能做出：更复杂的应用、开始修改细节\n\n### 阶段 3：Vibe + 手动修改 ​\n\n- 能自己改一些小地方\n- 知道什么时候 AI 出错了\n你能做出：质量更高的项目、能解决更多问题\n\n### 阶段 4：AI 辅助开发 ​\n\n- AI 是你的助手，不是唯一依赖\n- 有独立的技术判断能力\n你能做出：商业级产品、专业项目\n\n本教程会带你从阶段 1 走到阶段 2。 进阶版会带你走得更远。\n\n## 小结 ​\n迷信真相Vibe Coding 只能做玩具能做很多实用的东西AI 生成的代码不靠谱用对了场景，完全够用专业开发不需要 AI连专业开发者都在用\nVibe Coding 是工具，不是玩具。\n\n关键在于你用它来做什么。\n\n重要提醒\n\nVibe Coding 有边界，这很正常。\n\n任何工具都有适用范围。\n\n知道它能做什么、不能做什么，比盲目吹捧或贬低都重要。\n\n这本书会帮你找到这个边界，并教你如何在边界内把事情做好。\n\n最后一个迷信：AI 会抢走程序员的工作？",
      "word_count": 1595,
      "estimated_time": 3
    },
    {
      "id": "lesson-013",
      "chapter_id": "chapter-01",
      "lesson_number": 12,
      "title": "1.3.5 迷信五：AI 会抢走程序员的工作",
      "content": "# 1.3.5 迷信五：\"AI 会抢走程序员的工作\" ​\n\n\"AI 都能写代码了，程序员是不是要失业了？我现在学还有意义吗？\"\n\n这个问题，不只是新手在问。很多资深开发者也在焦虑。\n\n让我给你一个更清晰的视角。\n\n## 不是替代，是协作 ​\n\n先说结论：AI 不会取代程序员，但会改变程序员的工作方式。\n\n这就像 Excel 没有取代会计，但改变了会计的工作方式。\n\n- 过去，会计要手算很多数字\n- 现在，会计用 Excel 处理数据，专注于分析和决策\n编程也是一样：\n\n- 过去，程序员要写很多重复的代码\n- 现在，AI 帮你写重复代码，你专注于设计和决策\n工作内容变了，但工作没有消失。\n\n## 新的工作机会 ​\n\nAI 时代，一些新的角色正在出现：\n\n### 1. AI 辅助开发者 ​\n\n用 AI 提高效率的程序员。能力不是被替代，而是被放大。\n\n### 2. Prompt 工程师 ​\n\n专门研究如何和 AI 沟通的人。需求正在增长。\n\n### 3. AI 产品设计师 ​\n\n设计 AI 能力边界，定义 AI 产品体验。\n\n### 4. AI 审计员 ​\n\n检查 AI 生成代码的安全性、合规性。\n\n### 5. \"公民开发者\" ​\n\n非技术背景，但能用 AI 做出产品的人。这就是你正在成为的角色。\n\n## 什么样的人会被\"替代\"？ ​\n\n说实话，有些人确实会受到影响：\n受影响的不受影响的只会机械写代码，不思考能理解业务需求，做设计决策拒绝学习新工具主动拥抱 AI，学会协作只做执行，不做判断能审查 AI 输出，判断对错没有领域知识懂业务、懂用户、有专业背景\n真正的风险不是\"AI 会不会取代人\"，而是\"会不会有人用 AI 取代你\"。\n\n## 你应该怎么想这件事 ​\n\n如果你是非技术背景的人：\n\n这是一个好消息。\n\n过去，你想做一个产品，要么学很久编程，要么找人帮你做。\n\n现在，你可以用 AI 自己做出来。\n\n门槛降低了，你的领域知识和创意反而更值钱了。\n\n如果你是技术背景的人：\n\n这也是一个好消息。\n\nAI 帮你处理无聊的重复工作，你可以专注于更有价值的事情：\n\n- 系统设计\n- 架构决策\n- 代码审查\n- 解决复杂问题\n你的效率会被放大，而不是被替代。\n\n## 真实案例 ​\n\n陈总，创业公司 CEO\n\n他不会写代码，但他懂金融业务。\n\n以前，他每次有产品想法，都要和技术团队反复沟通，等三个月才能看到原型。\n\n现在，他自己用 AI 做原型：\n\n- 早上有想法\n- 下午做出原型\n- 晚上拿给团队看，讨论是否值得投入\n他说：\n\n\"AI 没有取代我的技术团队，但让我能更好地和他们沟通。我现在知道什么容易做、什么难做，提需求也更靠谱了。\"\n\n## 小结 ​\n迷信真相AI 会取代程序员AI 改变工作方式，不是取代工作学编程没意义了理解编程的人能更好地使用 AIAI 时代不需要人了需要能和 AI 协作的人\n与其担心被替代，不如学会用 AI。\n\n你不需要和 AI 竞争。你需要学会和 AI 一起工作。\n\n给自己的话\n\nAI 时代最大的风险不是 AI 本身，而是你选择忽视它。\n\n现在开始学习 Vibe Coding，你就是在为未来做准备。\n\n不管你最终是否成为程序员，理解 AI 编程的能力都会让你受益。\n\n你正在做一个正确的选择。继续往下走吧。\n\n还有一个常见迷信需要破除：AI 生成的代码总是完美的？",
      "word_count": 1414,
      "estimated_time": 3
    },
    {
      "id": "lesson-014",
      "chapter_id": "chapter-01",
      "lesson_number": 13,
      "title": "1.3.6 迷信六：AI生成的代码总是完美的",
      "content": "# 1.3.6 迷信六：\"AI生成的代码总是完美的\" ​\n\n\"AI都能写代码了，肯定比人写得好吧？\"\n\n如果你这样想，需要调整一下预期。\n\nAI 是一个非常能干的助手，但它不是全知全能的神。\n\n## AI 会犯的错误 ​\n\nAI 生成的代码可能存在这些问题：\n问题类型例子功能遗漏你要的功能只实现了一半逻辑错误代码能跑，但结果不对凭空捏造引用了根本不存在的函数或库过时信息用了已经淘汰的写法安全漏洞代码能用，但有安全隐患\n这不是 AI 的\"缺陷\"，而是它的工作方式决定的——它是根据模式生成文字，不是真的\"理解\"你的需求。\n\n## 正确的心态 ​\n\n把 AI 想象成一个非常勤快但偶尔粗心的实习生：\n\n- 它干活很快\n- 它大部分时候都对\n- 但你不能完全不检查就直接用\n- 它犯错时，你要能发现\n你的责任是验证结果，而不是盲目信任。\n\n## 怎么验证？ ​\n\n对于 Vibe Coding 阶段，验证很简单：\n\n- 运行一下：看看效果是不是你想要的\n- 多试几种情况：点点按钮，输入一些数据，看看会发生什么\n- 问问自己：如果我是用户，这个体验对吗？\n你不需要读懂每一行代码，但你需要对\"结果对不对\"负责。\n\n## 这反而是个好消息 ​\n\n为什么？\n\n因为这意味着你的判断力很重要。\n\nAI 负责\"怎么写\"，你负责\"写得对不对\"。\n\n这正是我们在 1.2 节说的\"Commander\"角色——你是指挥官，AI 是执行者。执行者也会犯错，所以你需要检查。\n\n## 小结 ​\n迷信真相AI 代码总是完美的AI 会犯错，需要验证AI 比人写得好AI 快但不一定对，人慢但能判断用 AI 就不用操心了语法交给 AI，结果审查交给你\n信任 AI，但要验证。\n\n这不是对 AI 的不信任，而是负责任的协作方式。\n\n给自己的话\n\n\"信任但验证\"（Trust but verify）是和 AI 协作的黄金法则。\n\nAI 帮你省下了写代码的时间，但检查结果的责任还是你的。\n\n好消息是：检查比写代码简单多了。你只需要看看效果对不对，不需要知道代码怎么写。\n\n## 恭喜你！ ​\n\n你已经完成了\"破除迷信\"这一章。\n\n现在你知道了：\n\n- ✅ 数学不好？没关系，小学数学够用\n- ✅ 英语不好？没关系，中文完全可以\n- ✅ 不懂技术名词？没关系，边做边学\n- ✅ Vibe Coding 是玩具？不是，它是实用工具\n- ✅ AI 会抢工作？不会，学会协作才是关键\n- ✅ AI 代码完美？不是，需要你来验证\n心理障碍清除了，准备好开始了吗？\n\n下一章，我们来看看有哪些工具可以选择：工具初探",
      "word_count": 1086,
      "estimated_time": 3
    },
    {
      "id": "lesson-015",
      "chapter_id": "chapter-01",
      "lesson_number": 14,
      "title": "1.4.1 AI 编程工具全景图（2025 年版）",
      "content": "# 1.4.1 AI 编程工具全景图（2025 年版） ​\n\n2025 年的 AI 编程工具，就像点外卖 App 一样多。别慌，不需要全部了解。\n\n这一节帮助快速建立一个\"地图\"，知道有哪些工具、它们大概是干什么的。等需要的时候，再回来查就行。\n\n## 五大类工具一览 ​\n\n市面上的 AI 编程工具可以分成五类，就像五种不同的交通工具：\n\n## 对话式 AI：最简单的起点 ​\n\n是什么：就是熟悉的 ChatGPT、Claude 这类聊天机器人。\n\n怎么用：打开网页，用中文告诉它想做什么，它直接给代码。\n工具特点免费额度官网ChatGPT最知名，支持多种任务有免费版chat.openai.comClaude代码质量高，擅长长文本有免费版claude.aiGeminiGoogle 出品，集成搜索有免费版gemini.google.comKimi中文友好，支持长文档有免费版kimi.moonshot.cnDeepSeek国产之光，性价比高有免费版chat.deepseek.com豆包字节出品，中文体验好有免费版doubao.com\n适合谁：完全零基础。先用这个试试水，感受一下\"用中文写代码\"是什么体验。\n\n小贴士：如果只是想体验 AI 编程，打开 Claude.ai 或 ChatGPT，输入\"帮我写一个显示当前时间的网页\"，就完成了人生第一次 AI 编程。\n\n## AI 代码编辑器：独立安装的专业工具 ​\n\n是什么：需要下载安装的完整开发环境，内置强大的 AI 能力。\n\n怎么用：安装后打开，像用 Word 一样，但它能理解整个项目，帮助生成、修改、解释代码。\n工具特点价格官网Cursor功能最强，社区活跃，教程资源多$20/月，有免费额度cursor.comWindsurf自动化程度高，性价比好$15/月，免费版够用codeium.com/windsurfTrae 国际版字节出品，支持 Gemini-3-Pro-Preview 等顶级模型首月$3，之后$10/月trae.aiTrae 国内版字节出品，中文友好，使用国产模型个人免费，企业69元/席位/月trae.com.cnQoder国产新秀，功能全面免费版可用qoder.aiKiroAmazon 出品，规范驱动，先写文档再写代码免费kiro.devZed高性能，协作功能强有免费版zed.dev\n适合谁：想认真学习 AI 编程、愿意花几分钟安装软件。这类工具能理解整个项目，帮助更精准。\n\nTrae 说明：分国内版（trae.com.cn）和国际版（trae.ai）。国际版支持 Gemini-3-Pro-Preview、GPT-4o 等顶级模型；国内版使用豆包、DeepSeek 等国产模型，个人完全免费。\n\n2025 年热门选择：Cursor 和 Windsurf 是目前最受欢迎的两个。Cursor 功能强大，Windsurf 价格友好。新手可以先试 Windsurf 或 Trae 的免费版。\n\n## IDE 插件/扩展：给现有编辑器加 AI ​\n\n是什么：在已有的代码编辑器（如 VS Code、JetBrains）里安装一个 AI 插件。\n\n怎么用：不用换编辑器，装个插件就能获得 AI 能力。边写代码边和 AI 聊天，它能看到整个项目。\n工具特点价格官网GitHub Copilot老牌稳定，生态最全$10/月起github.com/copilotAugment企业级，擅长大型代码库（200K 上下文）$20/月起，有免费版augmentcode.comCline开源免费，灵活度高免费（需自备 API）cline.botContinue.dev开源，高度可定制免费（需自备 API）continue.devTabnine老牌，支持本地模型有免费版tabnine.comAmazon Q DeveloperAWS 集成好有免费版aws.amazon.com/q\n适合谁：已经在用 VS Code 或 JetBrains，不想换编辑器，只想加个 AI 助手。\n\n## 网页版 AI 编程：零安装的一站式方案 ​\n\n是什么：打开浏览器，描述想要什么，AI 直接生成一个完整的项目，还能实时预览效果。\n\n怎么用：零安装，打开网页就能用。输入需求，几分钟后就能看到一个可运行的网站。\n工具特点价格官网豆包 AI 编程国内访问流畅，支持代码预览免费doubao.com/chat/codingBolt.new全栈应用生成，一键部署$20/月起，有免费额度bolt.newv0.devVercel 出品，UI 组件质量极高$20/月起，有免费额度v0.devLovable速度最快，12 分钟出 MVP$25/月起lovable.devReplit支持 50+ 语言，教育友好有慷慨免费版replit.com\n适合谁：想快速看到成果、不想装任何软件。打开网页就能开始做东西。\n\n国内用户首选：豆包 AI 编程，访问流畅、免费、中文支持好。Bolt.new 功能更全但需要科学上网。\n\n## 命令行工具：开发者的效率神器 ​\n\n是什么：在终端（那个黑色的窗口）里直接和 AI 对话。\n\n怎么用：输入命令，AI 帮助改代码、跑测试、修 Bug。效率极高，但需要一定基础。\n工具特点价格官网Claude CodeAnthropic 官方出品，能力强按使用量计费claude.ai/codeDroid (Factory)支持多模型，可自带 API，专业化 Droid 分工有免费版factory.aiAider开源免费，社区活跃免费（需自备 API）aider.chatCodex CLIOpenAI 出品按使用量计费github.com/openai/codexGemini CLIGoogle 出品有免费额度github.com/google-gemini/gemini-cli\n适合谁：有一定编程基础、追求效率的开发者。新手可以先跳过这类。\n\n## 一图看懂怎么选 ​\n\n## 本节小结 ​\n\n- AI 编程工具分五大类，各有各的用途\n- 零基础首选：对话式 AI（Claude/ChatGPT）或网页版工具（Bolt.new/豆包）\n- 想深入学习：AI 代码编辑器（Cursor/Windsurf/Trae）\n- 不用全学：选一个顺手的，用熟了再换\n- 所有工具都有免费版或免费额度，不用花钱也能体验\n下一节，来看看这些工具有什么\"共同的超能力\"——理解了这些，用任何工具都能上手。",
      "word_count": 2683,
      "estimated_time": 5
    },
    {
      "id": "lesson-016",
      "chapter_id": "chapter-01",
      "lesson_number": 15,
      "title": "1.4.2 所有工具的共同能力",
      "content": "# 1.4.2 所有工具的共同能力 ​\n\n上一节我们看了五大类工具。工具虽多，但它们都有一些\"共同的核心能力\"。\n\n理解了这些，你换任何工具都能快速上手。就像学会了开车，换什么品牌的车都能开。\n\n## 五大核心能力 ​\n\n### 能力 1：自然语言生成代码 ​\n\n你说中文，它写代码。\n\n这是所有 AI 编程工具最核心的能力。你不需要记住任何编程语法，只要能把想法说清楚就行。\n\n`你输入：「帮我做一个按钮，点击后显示\"你好\"」\n\nAI 输出：\n<button onclick=\"alert('你好')\">点我</button>`关键心法：描述越具体，结果越好。不是\"做个按钮\"，而是\"做一个蓝色的圆角按钮，点击后弹出'你好世界'\"。\n\n### 能力 2：理解上下文 ​\n\nAI 能\"看到\"你的项目，给出更精准的建议。\n\n普通聊天机器人每次对话都是\"失忆\"的。但专业的 AI 编程工具能记住：\n\n- 你之前说了什么\n- 你的项目里有哪些文件\n- 代码之间是怎么关联的\n这就像请了一个助手，他不仅听你说话，还看过你的所有文档。\n\n`场景：你的项目里已经有一个 user.js 文件\n\n你说：「在首页显示用户名」\n\n普通 AI：可能给你一个不兼容的方案\n专业工具：会读取 user.js，用你已有的变量和函数`为什么专业工具比 ChatGPT 好用？\n\n普通聊天 AI（如网页版 ChatGPT）每次对话都是\"失忆\"的，你需要反复粘贴代码。\n\n而 Cursor、Windsurf 这类工具能直接\"看到\"你的整个项目，理解文件之间的关系。这就是为什么我们推荐使用专业的 AI 编程工具，而不是用通用聊天 AI。\n\n### 能力 3：解释和修改代码 ​\n\n看不懂的代码，问它就行。\n\n遇到不理解的代码？选中它，问 AI：\n\n- \"这段代码是做什么的？\"\n- \"为什么要这样写？\"\n- \"能不能用更简单的方式？\"\nAI 会用你能理解的语言解释，还能帮你改写。\n\n`你选中一段代码，问：「这是什么意思？」\n\nAI 回答：\n「这段代码的作用是：\n1. 获取用户输入的文字\n2. 检查是否为空\n3. 如果不为空，就保存到本地存储\n\n简单说，就是\"保存用户填写的内容\"」`\n### 能力 4：多轮对话迭代 ​\n不满意？继续聊，直到满意为止。\n\nAI 编程不是\"一次成功\"，而是\"对话式改进\"。\n\n`第 1 轮：「帮我做一个计时器」\n→ AI 生成了基础版本\n\n第 2 轮：「把数字变大一点」\n→ AI 调整了字体大小\n\n第 3 轮：「加一个暂停按钮」\n→ AI 添加了暂停功能\n\n第 4 轮：「颜色换成蓝色」\n→ AI 修改了配色`每一轮对话都是在上一轮的基础上改进。这就是 Vibe Coding 的核心节奏：说 → 看 → 改 → 说 → 看 → 改...\n\n### 能力 5：错误诊断和修复 ​\n\n报错了？把错误信息丢给 AI，它帮你修。\n\n这可能是最实用的能力。当你的代码出问题时：\n\n- 复制错误信息\n- 发给 AI\n- AI 告诉你哪里错了、怎么改\n`你说：「报错了：Cannot read property 'length' of undefined」\n\nAI 回答：\n「这个错误的意思是：你在读取一个不存在的东西的长度。\n\n可能的原因：\n1. 变量还没有赋值就使用了\n2. 数据还没加载完就访问了\n\n修复方法：在使用前先检查变量是否存在。\n\n修改后的代码：\nif (myArray && myArray.length > 0) {\n  // 你的代码\n}」`\n## 这些能力意味着什么？ ​\n理解了这五大能力，你会发现：\n过去（不会编程）现在（有 AI 帮忙）看不懂代码让 AI 解释给你听不会写代码用中文描述，AI 来写报错不知所措复制错误，AI 帮你修改动怕改崩告诉 AI 你想改什么功能不会加对话式一步步加\n你需要学的不是\"编程语言\"，而是\"如何清楚地表达你想要什么\"。\n\n## 本节小结 ​\n\n所有 AI 编程工具都有五大共同能力：\n\n- 自然语言生成代码 — 你说中文，它写代码\n- 理解上下文 — 它知道你的项目长什么样\n- 解释和修改代码 — 看不懂就问，想改就说\n- 多轮对话迭代 — 不满意就继续聊\n- 错误诊断和修复 — 报错了丢给它\n下一节，我们来看看\"你应该选哪个工具\"——根据你的情况，给你具体的推荐。",
      "word_count": 1813,
      "estimated_time": 3
    },
    {
      "id": "lesson-017",
      "chapter_id": "chapter-01",
      "lesson_number": 16,
      "title": "1.4.3 按你的情况选择",
      "content": "# 1.4.3 按你的情况选择 ​\n\n工具那么多，到底选哪个？\n\n别焦虑。这一节帮你快速定位——根据你现在的情况，给你最直接的建议。\n\n## 快速定位：你是哪种情况？ ​\n\n### 情况 A：完全零基础，想先体验一下 ​\n\n你的状态：从没写过代码，甚至有点怕技术。只是好奇想试试。\n\n推荐工具类别：\n类型工具类别先聊天体验对话式 AI（如 Claude、豆包）直接看成品网页版 AI 编程\n两种入门方式：\n\n- \n先聊天试试：打开任意一个对话式 AI，输入\"帮我写一个显示当前时间的网页\"——AI 会给你代码。\n\n- \n直接看成品：打开网页版 AI 编程工具，输入同样的话，直接看到可运行的网页。\n\n第一步行动：参考 1.4.1 选一个工具，输入「帮我做一个显示当前时间的网页」，1-2 分钟后就能看到结果。\n\n### 情况 B：想快速做出东西，验证一个想法 ​\n\n你的状态：有个小想法（比如做个小工具、简单网站），想快速看到成果。\n\n推荐工具类别：网页版 AI 编程\n\n从描述到上线，可能只要 10-30 分钟。生成的项目可以直接分享链接给别人。\n\n具体工具参考 1.4.1 网页版 AI 编程。\n\n### 情况 C：用过 VS Code，想深入学习 AI 编程 ​\n\n你的状态：有一点编程基础（哪怕只是看过教程），想认真学习 AI 辅助开发。\n\n推荐工具类别：AI 代码编辑器\n\n为什么选这类工具：\n\n- 基于 VS Code，界面熟悉\n- 能理解整个项目的上下文\n- 具备 Agent 能力，能自动处理多文件任务\n什么是 Agent？\n\n2025 年 AI 编程的核心能力：AI 不只补全代码，还能自己规划任务、读取多个文件、执行命令——像有个助手帮你干活，而不只是给建议。\n\n参考 1.4.1 AI 代码编辑器 的对比表格，根据你的偏好选择。\n\n### 情况 D：只想做漂亮的界面 ​\n\n你的状态：需要做一些好看的网页组件、落地页、UI 界面。\n\n推荐工具类别：网页版 AI 编程（UI 专长的如 v0.dev）\n\n适合场景：\n\n- 做产品落地页\n- 设计系统里的组件\n- 需要交付给开发的原型\n### 情况 E：已是开发者，追求效率 ​\n\n你的状态：已经会写代码，想让 AI 帮你提效。\n\n推荐工具类别：\n场景工具类别日常开发AI 代码编辑器快速原型网页版 AI 编程终端效率命令行工具\n组合建议：多个类别搭配使用，各取所长。\n\n### 情况 F：已有编辑器，只想加 AI 插件 ​\n\n你的状态：习惯了 VS Code 或 JetBrains，不想换编辑器，只想加个 AI 助手。\n\n推荐工具类别：IDE 插件\n\n适合场景：\n\n- 已经有成熟的开发环境\n- 团队统一使用某个 IDE\n- 不想学新工具，只想加 AI 能力\n具体工具参考 1.4.1 IDE 插件。\n\n## 工具选择决策树 ​\n\n如果你还是不确定，跟着这个流程走：\n\n## 常见选择误区 ​\n\n### 误区 1：「要选最好的工具」 ​\n\n真相：没有\"最好\"，只有\"适合\"。\n\n工具只是手段。你用 Bolt.new 做出来的网站，和用 Cursor 做出来的，用户根本看不出区别。\n\n### 误区 2：「免费的肯定不好用」 ​\n\n真相：2025 年的免费额度已经很慷慨了。\n\n- Claude.ai 免费版足够体验\n- Windsurf 免费版够日常学习\n- Bolt.new 免费额度能做好几个小项目\n先用免费的，真的不够再付费。\n\n### 误区 3：「要把所有工具都学会」 ​\n\n真相：选一个，用熟了再换。\n\n工具的核心能力是相通的（上一节讲的五大能力）。用熟一个之后，换其他的只需要适应界面，不用重新学。\n\n## 本节小结 ​\n你的情况推荐类别不想装软件对话式 AI / 网页版 AI 编程想装软件AI 代码编辑器已有编辑器不想换IDE 插件追求终端效率命令行工具\n具体工具请参考 1.4.1 工具全景图。\n\n最重要的建议：别纠结太久。选一个类别，去 1.4.1 挑一个工具，现在就打开试试。\n\n下一节，我们来聊聊本教程的\"工具策略\"——为什么我们不绑定特定工具，以及这对你意味着什么。",
      "word_count": 1732,
      "estimated_time": 3
    },
    {
      "id": "lesson-018",
      "chapter_id": "chapter-01",
      "lesson_number": 17,
      "title": "1.4.4 本教程的工具策略",
      "content": "# 1.4.4 本教程的工具策略 ​\n\n你可能在想：「这个教程到底用什么工具？我要不要跟着装一样的？」\n\n这一节，我们来聊聊本教程的\"工具哲学\"。\n\n## 我们的策略：不绑定任何工具 ​\n\n本教程不会要求你必须用某个特定工具。\n\n为什么？三个原因：\n\n### 原因 1：工具变化太快 ​\n\n2024 年最火的工具，2025 年可能就被新工具超越了。\n\n- Cursor 曾经一家独大，现在 Windsurf 在追赶\n- Bolt.new 去年才出现，今年已经是零基础首选\n- 明年又会有新的工具出来\n如果我们绑定某个工具，这份教程很快就会过时。\n\n### 原因 2：方法论比工具重要 ​\n\n我们教的是思维方式，不是按钮在哪。\n\n当你学会了：\n\n- 如何把想法拆解成 AI 能理解的描述\n- 如何迭代式地改进\n- 如何 Debug（修复问题）\n这些能力在任何工具上都能用。工具只是载体，方法论才是核心。\n\n### 原因 3：每个人情况不同 ​\n\n- 有人能装软件，有人只能用网页\n- 有人在国内，有人在国外\n- 有人愿意付费，有人想先用免费的\n强制大家用同一个工具，反而会给很多人造成障碍。\n\n## 本教程的使用方式 ​\n\n### 我们会怎么写示例 ​\n\n在教程中，当我们需要演示操作时：\n\n- 给出通用的 Prompt（提示词），而不是具体的按钮操作\n- 解释背后的思路，而不是死记硬背的步骤\n- 偶尔用某个工具截图，但会说明\"其他工具操作类似\"\n`✅ 我们会这样写：\n「把这段描述发给 AI：帮我做一个计时器，能开始、暂停、重置」\n\n❌ 我们不会这样写：\n「打开 Cursor，点击左上角的 Chat，输入...」`\n### 你应该怎么跟着学 ​\n\n- 选一个你能用的工具（参考上一节的推荐）\n- 把教程里的 Prompt 复制过去\n- 看效果，对比教程的预期结果\n- 如果不一样，问 AI 帮你调整不同工具的界面不同，但核心流程是一样的：描述需求 → 看结果 → 迭代改进。\n\n## 本节小结 ​\n\n- 本教程不绑定特定工具，教的是通用的方法论\n- 工具选择：参考 1.4.3 选类别，1.4.1 选具体工具\n- 方法论比工具重要：学会思路，换工具只是换界面\n恭喜你完成了 1.4 章！现在你已经：\n\n- 了解了 AI 编程工具的全景图\n- 知道了所有工具的共同能力\n- 找到了适合自己的工具类别\n下一步：进入 1.5 Hello World，用你选的工具做出第一个小项目。",
      "word_count": 1039,
      "estimated_time": 3
    },
    {
      "id": "lesson-019",
      "chapter_id": "chapter-01",
      "lesson_number": 18,
      "title": "1.5.1 目标与准备",
      "content": "# 1.5.1 目标与准备 ​\n\n## 本节目标 ​\n\n完成这一节后，你会得到：\n\n- ✅ 一个能在浏览器里看到的网页\n- ✅ 网页上显示一句励志名言\n- ✅ 页面有好看的样式（不是白底黑字的\"毛坯房\"）\n就这么简单。不多不少。\n\n## 选择你的工具 ​\n\n还记得 1.4 节介绍的那些工具吗？\n\n现在是用起来的时候了。\n\n选择建议\n\n如果是完全零基础，推荐用这几个（任选其一）：\n\n- Bolt.new - 打开浏览器就能用，不需要安装任何东西\n- v0.dev - Vercel 出品，同样打开就能用\n- 豆包 AI 编程 - 国内用户首选，访问流畅，支持实时预览\n注：Bolt.new 在国内可能加载较慢，需要科学上网。国内用户推荐使用豆包 AI 编程。\n\n如果已经装了 Cursor 或 Trae，也可以直接用它们。\n\n本节的操作在任何工具里都一样，只是界面稍有不同。\n\n## 准备清单 ​\n\n开始之前，确认你有：\n\n- [ ] 一台能上网的电脑（手机也行，但电脑体验更好）\n- [ ] 一个现代浏览器（Chrome、Edge、Safari 都可以）\n- [ ] 3 分钟的时间\n没了。\n\n不需要安装任何软件。\n\n不需要注册账号（大部分工具可以免注册试用）。\n\n不需要任何编程知识。\n\n## 心理准备 ​\n\n你可能会想：\n\n\"我真的能做出来吗？\"\n\n答案是：一定能。\n\n我见过 60 岁的阿姨用 AI 做出了自己的食谱网站。\n\n我见过从没写过代码的大学生用 AI 做出了课程表应用。\n\n如果他们可以，你也可以。\n\n唯一的区别是：你愿不愿意试一试。\n\n准备好了？\n\n下一节，我们正式动手。",
      "word_count": 697,
      "estimated_time": 3
    },
    {
      "id": "lesson-020",
      "chapter_id": "chapter-01",
      "lesson_number": 19,
      "title": "1.5.2 Step by Step 操作",
      "content": "# 1.5.2 Step by Step 操作 ​\n\n接下来的每一步，我都会告诉你：\n\n- 做什么 - 具体的操作\n- 看到什么 - 你应该看到的结果\n- 检查点 - 确认你做对了\n跟着走就行。\n\n## Step 1：打开工具（30 秒） ​\n\n做什么：\n\n打开浏览器，访问 bolt.new（国内用户可用 豆包 AI 编程）\n\n（或者你选择的其他工具）\n\n你应该看到：\n\n一个简洁的界面，中间有一个输入框，让你描述想要做什么。\n\n类似于 ChatGPT 的对话界面，但它专门用来生成网页和应用。\n\n检查点：\n\n- [ ] 界面已经加载完成\n- [ ] 你能看到输入框\n如果遇到问题\n\n- 页面加载很慢？ Bolt.new 在国内需要科学上网。建议国内用户使用 豆包 AI 编程，访问更流畅\n- 需要登录？ 大部分工具可以免费试用，用 Google 账号或手机号登录即可\n## Step 2：输入 Prompt（30 秒） ​\n\n现在，最关键的一步来了。\n\n做什么：\n\n在输入框里，输入下面这段话（可以直接复制）：\n\n`帮我做一个简单的网页，显示一句励志名言。\n\n要求：\n1. 页面正中央显示一句名言，比如\"千里之行，始于足下\"\n2. 名言下方显示作者名字\n3. 页面背景用浅色渐变，看起来舒服一点\n4. 整体风格简洁大方`然后按回车（或点击发送按钮）。\n\n你应该看到：\n\nAI 开始工作了！\n\n它会：\n\n- 思考一下你的需求\n- 开始生成代码\n- 在右边（或下方）实时显示预览效果\n整个过程大概 10-30 秒。\n\n检查点：\n\n- [ ] AI 正在生成内容\n- [ ] 你能看到预览画面在变化\n小技巧\n\n不用紧盯着代码看。看不懂很正常——你只需要看最终的预览效果就行。\n\n## Step 3：查看结果（1 分钟） ​\n\n做什么：\n\n等 AI 生成完毕后，看看预览窗口里的效果。\n\n你应该看到：\n\n一个漂亮的网页，上面显示着：\n\n- 一句励志名言（可能是\"千里之行，始于足下\"，也可能是 AI 自己选的其他名言）\n- 作者名字\n- 好看的背景色\n检查点：\n\n- [ ] 页面正常显示，没有报错\n- [ ] 能看到名言和作者\n- [ ] 背景颜色是渐变的\n恭喜！\n\n如果你看到了上面这些，你已经成功做出了你的第一个 AI 网页！\n\n是的，就这么简单。\n\n## Step 4：尝试修改（1 分钟） ​\n\n做出来不满意？没关系，改它。\n\n做什么：\n\n在对话框里继续输入你的修改意见。比如：\n\n`把名言换成\"Stay hungry, stay foolish. —— Steve Jobs\"`或者：\n\n`背景颜色改成深色系，字体颜色改成白色`或者：\n\n`加一个按钮，点击可以切换到下一句名言`你应该看到：\n\nAI 会根据你的要求，修改代码，预览窗口也会实时更新。\n\n检查点：\n\n- [ ] 修改生效了\n- [ ] 页面按你说的方式变化了\n## 完整的 Prompt 参考 ​\n\n如果你想要一个更完整的版本，可以试试这个：\n\n`帮我做一个\"每日一句\"励志名言网页。\n\n功能：\n1. 页面正中央显示一句名言和作者\n2. 有一个\"换一句\"按钮，点击可以随机切换名言\n3. 预设 5-10 句名言供切换\n\n样式：\n1. 背景用柔和的渐变色（比如浅蓝到浅紫）\n2. 名言用大字体，居中显示\n3. 作者名用小一点的字体，显示在名言下方\n4. 按钮要好看，有悬停效果\n5. 整体风格现代、简洁\n\n请用 HTML + CSS + JavaScript 实现。`这个版本加入了交互功能（按钮切换），你可以试试。\n\n## 小结 ​\n\n你刚刚完成了什么？\n\n- 打开工具 - 30 秒\n- 输入需求 - 30 秒\n- 等待生成 - 30 秒\n- 查看结果 - 30 秒\n- 尝试修改 - 1 分钟\n总共：3 分钟。\n\n你用自然语言\"写\"了一个网页。\n\n没有学任何编程语言。\n\n没有写一行代码。\n\n这就是 Vibe Coding。",
      "word_count": 1650,
      "estimated_time": 3
    },
    {
      "id": "lesson-021",
      "chapter_id": "chapter-01",
      "lesson_number": 20,
      "title": "1.5.3 恭喜你！你已经完成了什么",
      "content": "# 1.5.3 恭喜你！你已经完成了什么 ​\n\n恭喜你！\n\n如果你跟着上一节做完了，你已经：\n\n## ✅ 体验了 AI 编程 ​\n\n你亲眼见证了 AI 如何把你的想法变成真实的网页。\n\n这不是魔术，这是 2025 年的现实。\n\n## ✅ 用自然语言\"写\"了代码 ​\n\n你没有学 HTML、CSS、JavaScript，但你做出了一个真正的网页。\n\n你用的是最熟悉的工具——语言。说清楚你想要什么，AI 就能帮你实现。\n\n## ✅ 看到了即时结果 ​\n\n传统学编程，可能要学几周才能做出一个像样的页面。\n\n你只用了 3 分钟。\n\n这不是因为你比别人聪明，而是因为工具变了。\n\n## ✅ 尝试了迭代修改 ​\n\n更重要的是，你体验了\"对话式开发\"的感觉：\n\n- 不满意？告诉 AI\n- 想加功能？告诉 AI\n- 想改样式？告诉 AI\n你是指挥官，AI 是执行者。\n\n## 你现在的位置 ​\n\n你已经从\"完全零基础\"走到了\"第一个网页\"。\n\n你证明了一件事：你能做出东西。接下来，就是做得更多、做得更好。\n\n## 这意味着什么？ ​\n\n你可能觉得\"就是一个显示名言的页面，有什么了不起的？\"\n\n但请想想：\n\n- 如果你能做一个名言页面，你就能做一个记录心情的日记页面\n- 如果你能加一个按钮，你就能做一个简单的计算器\n- 如果你能切换内容，你就能做一个背单词的小工具\n所有复杂的应用，都是从简单的功能组合起来的。\n\n你已经走出了最难的一步：开始。\n\n## 下一步 ​\n\n现在你有两个选择：\n\n- 继续往下学 - 我们会教你更多技巧，做出更复杂的东西\n- 自己玩一玩 - 用刚才的工具，试着做点别的\n无论哪个选择，都是对的。\n\n因为最好的学习方式，就是做。\n\n\"千里之行，始于足下。\"\n\n你已经迈出了第一步。\n\n## 想继续玩？试试这些 Prompt ​\n\n学会了第一个网页，不妨继续挑战：\n\n### 初级：修改名言页面 ​\n\n`把页面改成英文版，用 3 句乔布斯的名言`\n### 中级：做一个计时器 ​\n\n```\n帮我做一个 25 分钟番茄钟，有开始、暂停、重置按钮，时间到了弹出提醒\n```\n\n### 进阶：做一个记事本 ​\n\n```\n做一个简单的记事本网页，可以输入文字，点击保存按钮后显示在下方列表里\n```\n每一个都只需要一句话。试试看？",
      "word_count": 969,
      "estimated_time": 3
    },
    {
      "id": "lesson-022",
      "chapter_id": "chapter-01",
      "lesson_number": 21,
      "title": "1.5.4 常见问题 FAQ",
      "content": "# 1.5.4 常见问题 FAQ ​\n\n做第一个项目的时候，你可能会遇到一些困惑。\n\n别担心，这些问题大家都会遇到。\n\n## Q1：\"我的结果和教程不一样怎么办？\" ​\n\n这太正常了。\n\nAI 每次生成的内容都会有些不同。就像你问两个设计师\"做一个好看的页面\"，他们给你的方案肯定也不一样。\n\n关键是\n\n只要你的页面：\n\n- 能正常显示\n- 有名言和作者\n- 看起来还不错\n就算成功了！\n\n如果你想要和教程一模一样的效果，可以在 Prompt 里描述得更具体，比如：\n\n- 指定具体的颜色（\"背景用 #f0f4f8\"）\n- 指定具体的字体大小（\"名言用 32px 的字体\"）\n- 指定具体的布局（\"名言在页面垂直居中\"）\n## Q2：\"代码看不懂正常吗？\" ​\n\n完全正常。\n\n起步阶段，你不需要看懂每一行代码。\n\n就像你用微信发消息，不需要懂微信是怎么写出来的。\n\nVibe Coding 的核心理念是：让 AI 处理代码语法，你专注于需求和结果。\n\n好消息\n\n随着使用次数增多，你会自然地开始认识一些常见的代码结构。\n\n如果你好奇某段代码是什么意思，可以问 AI：\n\n`请解释一下这段代码是做什么的，用最简单的话说`AI 会用你能懂的语言给你解释。这不是必须的，但会让你和 AI 的协作更顺畅。\n\n## Q3：\"可以用中文吗？\" ​\n\n当然可以。\n\n现在的 AI 对中文的理解已经非常好了。\n\n用中文写 Prompt，AI 完全能懂。\n\n什么时候用英文？\n\n有些技术名词用英文会更准确，比如：\n\n- \"按钮\" vs \"button\"\n- \"悬停效果\" vs \"hover effect\"\n但大部分情况下，用中文完全没问题。\n\n如果你英文好，用英文也可以——效果差不多。\n\n## Q4：\"AI 生成的东西报错了怎么办？\" ​\n\n把错误信息复制给 AI。\n\n这是最简单有效的方法：\n\n`页面报错了，错误信息是：\n[粘贴错误信息]\n\n请帮我修复`AI 会分析错误原因，然后给你修复后的代码。\n\n如果反复修不好\n\n- 简化你的需求：把复杂功能拆成更小的步骤，一次只做一件事\n- 换一种描述方式：同样的需求，用不同的话说，AI 可能更容易理解\n- 从最简版本重新开始：删掉复杂功能，先让基础版跑起来，再逐步加功能\n问题通常出在\"描述不够清楚\"，而不是工具不行。\n\n## Q5：\"这个网页怎么发给别人看？\" ​\n\n现在你做的网页只在工具的预览窗口里。想让别人访问，需要\"部署\"——这个我们在后面的章节会详细讲。\n\n现在不用着急，先把东西做出来再说。\n\n## Q6：\"我想保存这个项目怎么办？\" ​\n\n不同类型的工具保存方式不同：\n工具类型保存方式网页版工具（如 Bolt.new、豆包）注册账号后自动保存，也可以导出代码AI 代码编辑器（如 Cursor、Trae）本地文件，随时保存\n如果你只是想保留代码，最简单的方法是：\n\n- 复制 AI 生成的所有代码\n- 粘贴到一个文本文件里\n- 保存到电脑上\n## Q7：\"我可以用这个做商业项目吗？\" ​\n\n可以，但建议分阶段：\n\n- 先用 Vibe Coding 验证想法——快速做出原型，看看是否可行\n- 如果要正式上线——涉及用户数据、支付等敏感功能时，需要学习进阶篇的安全（第6章）和测试（第9章）内容\n很多成功的产品，都是从一个粗糙的原型开始的。本教程的进阶篇会教你如何把原型变成正式产品。\n\n## Q8：\"不同工具界面不一样怎么办？\" ​\n\n不用担心，核心操作都一样。\n\n无论你用 Bolt.new、豆包、Cursor 还是其他工具，基本流程都是：\n\n- 找到输入框\n- 用中文描述你想要什么\n- 等 AI 生成\n- 看预览效果\n- 不满意就继续说\n界面按钮的位置可能不同，但\"用自然语言描述需求\"这个核心不会变。\n\n如果找不到某个功能，直接问 AI：\"怎么在 [工具名] 里保存项目？\"\n\n## 还有其他问题？ ​\n\n如果你遇到了上面没提到的问题，试试这个方法：\n\n直接问 AI。\n\n`我在用 [工具名] 做一个网页，遇到了这个问题：\n[描述你的问题]\n\n请问怎么解决？`AI 能帮你思考大部分问题——但记得验证它给的答案是否靠谱。\n\n这也是 Vibe Coding 的精髓：遇到问题，先问 AI，再自己验证。\n\n准备好继续学习了吗？\n\n下一章，我们会讲讲\"心法\"——如何像产品经理一样思考，让你的 AI 产出更靠谱。",
      "word_count": 1835,
      "estimated_time": 3
    },
    {
      "id": "lesson-023",
      "chapter_id": "chapter-02",
      "lesson_number": 1,
      "title": "2.1.1 JTBD框架：理解&quot;雇佣&quot;隐喻",
      "content": "# 2.1.1 JTBD框架：理解\"雇佣\"隐喻 ​\n\n## 什么是JTBD ​\n\nJobs to be Done（待完成的任务），简称JTBD，是由哈佛商学院教授Clayton Christensen提出的产品思维框架。\n\n核心思想只有一句话：\n\n人们不是在购买产品本身，而是在\"雇佣\"产品来帮助他们完成某项任务。\n\n\"雇佣\"这个词用得很妙。想象一下：\n\n- 你雇佣一个清洁工，是为了让家里变干净\n- 你雇佣一个会计，是为了让账目清晰\n- 你雇佣一个待办清单App，是为了不遗漏重要的事\n如果清洁工打扫得不干净，你会解雇他。如果App没能帮你记住事情，你也会卸载它。\n\n产品被\"雇佣\"是因为它能完成任务，被\"解雇\"是因为它完成得不好。\n\n## 奶昔的故事：JTBD的经典案例 ​\n\n这是JTBD框架最著名的案例，来自一家快餐连锁店的真实经历。\n\n### 问题 ​\n\n这家连锁店想要提高奶昔的销量。他们最初的做法是：\n\n- 调查顾客：\"你想要奶昔更甜还是更稠？\"\n- 增加口味选择：草莓、巧克力、香草……\n- 优化配料组合\n结果呢？销量几乎没有变化。\n\n### 转折 ​\n\n后来，研究团队换了一个问题：\n\n\"顾客在什么情况下会'雇佣'奶昔？他们要完成什么任务？\"\n\n他们派人去店里观察，发现了一个有趣的现象：\n\n大多数奶昔是在早上7点到9点之间卖出的，买奶昔的人通常是独自开车上班的通勤者。\n\n### 洞察 ​\n\n通过访谈，团队发现这些顾客\"雇佣\"奶昔的真正任务是：\n顾客的真实任务为什么选择奶昔在漫长的通勤路上有事可做吸管喝奶昔可以单手操作，不影响开车抵御上午的饥饿感奶昔比咖啡更顶饿，能撑到午饭比面包不那么无聊有味道，吃起来不枯燥保持衣服整洁不会像三明治那样掉渣\n### 解决方案 ​\n\n基于这个洞察，团队的建议是：让奶昔更稠。\n\n更稠的奶昔需要更长时间才能吸完，这意味着：\n\n- 通勤路上的\"陪伴\"时间更长\n- 顾客会觉得更\"值\"\n结果：奶昔销量提升了超过40%。\n\n### 这个故事告诉我们什么 ​\n\n传统思维问的是\"你想要什么口味\"，这是功能视角。\n\nJTBD思维问的是\"你要完成什么任务\"，这是任务视角。\n\n同样是卖奶昔，视角不同，答案完全不同。\n\n## 任务的三个层次 ​\n\nJTBD框架把用户的任务分为三个层次：\n层次定义示例（待办清单场景）功能任务用户要完成的具体事情记录今天要做的事、设置截止日期情感任务用户想要的感受感到安心、有掌控感、不焦虑社会任务用户想要的社会形象显得有条理、专业、靠谱\n初学者常犯的错误是只看到功能任务，忽略情感任务和社会任务。\n\n举个例子：\n\n一个职场新人下载待办清单App，表面上是为了\"记录任务\"（功能任务），但深层原因可能是：\n\n- 害怕遗漏重要事项导致被领导批评（情感任务）\n- 想让同事觉得自己是个靠谱的人（社会任务）\n如果你只关注功能，可能会不断加功能：分类、标签、统计……\n\n但如果你理解情感任务，可能会发现：一个简单的\"今日待办\"清单，加上完成时的小庆祝动画，反而更能解决问题。\n\n## 为什么JTBD对Vibe Coding特别重要 ​\n\n你可能会问：这个框架是给产品经理用的，和我用AI写代码有什么关系？\n\n关系太大了。\n\nAI是一个超级执行者，但它不会帮你思考\"该做什么\"。\n\n当你告诉AI\"帮我做一个待办清单\"，AI会忠实地执行你的指令。但它不会问你：\n\n- 你为什么需要待办清单？\n- 你现在用什么方式管理任务？\n- 那个方式有什么问题？\n这些问题，只有你自己能回答。\n\nJTBD框架的价值，就是帮你在开口告诉AI之前，先想清楚这些问题。\n\n## 一个思维转换练习 ​\n\n下次当你有了一个想法，试着完成这个转换：\n原始想法问自己JTBD视角的重述我想做一个待办清单我为什么需要它？当我每天开始工作时，我想快速记录今天要做的事，这样我就不会遗漏重要任务，可以安心投入工作我想做一个记账App我为什么需要它？当我月底发现钱不知道花哪了，我想看清楚钱都去了哪里，这样我可以调整消费习惯，存下更多钱我想写一个自动化脚本我为什么需要它？当我每周都要手动汇总5个部门的Excel表格，我想让这个过程自动完成，这样我可以把时间花在更有价值的事情上\n注意这个转换的结构：\n\n`当 [某个情境发生时]，\n我想要 [完成某个任务]，\n这样我就可以 [获得某种结果/感受]。`这个结构会在后面的练习中反复使用。先记住它。",
      "word_count": 1834,
      "estimated_time": 3
    },
    {
      "id": "lesson-024",
      "chapter_id": "chapter-02",
      "lesson_number": 2,
      "title": "2.1.2 初学者最常犯的三个错误",
      "content": "# 2.1.2 初学者最常犯的三个错误 ​\n\n在开始学习正确的方法之前，我们先来看看大多数人是怎么失败的。\n\n了解这些错误，能帮你少走很多弯路。\n\n## 错误一：功能堆砌症 ​\n\n### 典型表现 ​\n\n`\"帮我做一个待办清单App，要有：\n任务分类、优先级标签、截止日期提醒、重复任务、\n子任务拆解、标签系统、日历视图、统计报表、\n多设备同步、协作共享、暗黑模式……\"`\n### 为什么这是错的 ​\n\n- 你在列功能清单，而不是在解决问题\n\n这个需求里没有提到：谁会用？在什么场景下用？要解决什么问题？\n\n- \n你在假设用户需要这些\n\n这些功能是你想象出来的，还是真的有人需要？你验证过吗？\n\n- \n复杂度会杀死项目\n\n给AI一个20项功能的需求，AI会尝试同时满足所有要求。结果通常是一团乱麻的代码，充满bug，难以调试。\n\n### 真实后果 ​\n\n小李尝试让AI做这个\"功能齐全\"的待办清单，三个小时后：\n\n- AI生成了超过2000行代码\n- 页面加载后一片空白\n- 控制台报了十几个错误\n- 小李完全看不懂哪里出了问题\n功能越多，失败概率越高。这是铁律。\n\n## 错误二：解决不存在的问题 ​\n\n### 典型表现 ​\n\n`\"帮我做一个数据可视化看板，展示：\n用户活跃度趋势、留存率漏斗、转化率分析、\n用户画像分布、行为路径追踪……\"`\n### 为什么这是错的 ​\n问题在于：你真的需要看这些数据吗？看了之后要做什么决策？\n\n很多人做数据分析项目时，会陷入\"数据越多越好\"的误区。他们花大量时间搭建看板，最后发现：\n\n- 没人看这些图表\n- 看了也不知道该干什么\n- 数据没有驱动任何行动\n### 真实后果 ​\n\n一位产品经理花了两周时间，用AI做了一个\"全面\"的数据看板：\n\n- 20多个图表，覆盖各种指标\n- 可以按日、周、月切换\n- 支持导出PDF报告\n结果呢？\n\n- 老板只看了一眼销售额趋势图\n- 其他图表从未被点击过\n- 两周的时间可以做10个小功能了\n先问自己：我要回答什么问题？我会根据答案做什么决策？\n\n## 错误三：为技术而技术 ​\n\n### 典型表现 ​\n\n`\"帮我写一个Python脚本，用Pandas读取Excel，\n然后用正则表达式清洗数据，再用Matplotlib画图，\n最后导出成PDF……\"`\n### 为什么这是错的 ​\n这个需求直接跳到了\"怎么做\"，完全跳过了\"为什么做\"。\n\n更好的问法是：\n\n\"我每周要手动汇总5个部门的销售数据，现在用的是复制粘贴。有没有办法让这个过程自动化？\"\n\n### 两种问法的区别 ​\n为技术而技术为问题而技术我要用Pandas处理Excel我要自动汇总5个Excel我要用正则表达式数据格式有点乱需要清理我要用Matplotlib画图老板想看趋势变化我要导出PDF最后要发邮件给团队\n左边那列是\"怎么做\"，右边那列是\"做什么\"。\n\nAI可以帮你想\"怎么做\"，但\"做什么\"只有你自己能决定。\n\n如果你把\"怎么做\"也一起规定了，反而限制了AI发挥。也许有比Pandas更简单的方案呢？\n\n## 错误后果对比 ​\n错误类型表面行为深层问题典型后果功能堆砌一次性要求20个功能没想清楚核心问题代码混乱，bug满天飞解决不存在的问题做一堆没人看的功能没验证真实需求时间浪费，成果无用为技术而技术指定具体技术方案把手段当目的限制了更好的解决方案\n## 正确思维的起点 ​\n\n避开这三个错误的方法，归结起来就是一句话：\n\n先想清楚\"要解决什么问题\"，再考虑\"怎么解决\"。\n\n这听起来很简单，但需要刻意练习。\n\n下一节，我们会学习如何用JTBD框架系统地思考问题，并通过四个真实场景的示例，让你掌握这种思维方式。",
      "word_count": 1536,
      "estimated_time": 3
    },
    {
      "id": "lesson-025",
      "chapter_id": "chapter-02",
      "lesson_number": 3,
      "title": "2.1.3 JTBD框架应用：四个场景实战",
      "content": "# 2.1.3 JTBD框架应用：四个场景实战 ​\n\n学会了JTBD的理论，现在来看看它如何应用到你实际想做的事情上。\n\n我们会通过四个不同场景的示例，展示如何用任务视角重新定义问题。\n\n## 任务描述模板 ​\n\n在开始之前，先记住这个模板。后面所有的分析都会用到它：\n\n`当 [某类用户] 在 [某个情境] 下，\n他们想要 [完成某个任务]，\n以便于 [获得某种结果/感受]。\n\n目前他们的替代方案是 [现有解决方式]，\n但这个方案的问题是 [痛点]。`\n## 场景一：产品原型——待办清单 ​\n\n### 原始想法 ​\n\"我想做一个待办清单App\"\n\n### 用JTBD重新分析 ​\n\n用户是谁？ 小李，互联网公司运营，每天要处理20-30个工作事项\n\n情境是什么？ 每天早上到公司，需要理清今天要做什么\n\n要完成什么任务？ 快速记录和查看今天要做的事，确保不遗漏\n\n期望的结果是什么？ 安心投入工作，不用担心漏掉重要的事\n\n目前的替代方案？ 用便利贴、微信置顶消息、或脑子记\n\n替代方案的问题？ 便利贴容易丢，微信消息会被刷掉，脑子记不住\n\n### JTBD视角的任务描述 ​\n\n`当小李每天早上到公司时，\n他想要快速记录和查看今天要做的事，\n以便于不遗漏重要任务，可以安心投入工作。\n\n目前他用便利贴和微信置顶来管理，\n但便利贴容易丢，微信消息会被别的聊天刷掉。`\n### 这个分析改变了什么？ ​\n有了这个分析，你和AI的对话会完全不同：\n\n之前（功能视角）：\n\n\"帮我做一个待办清单，要有分类、标签、日历视图……\"\n\n之后（任务视角）：\n\n\"帮我做一个简单的每日待办工具。用户是职场人士，早上需要快速记录今天要做的事，核心需求是'不遗漏'和'快速记录'。不需要复杂功能，能添加任务、标记完成就够了。\"\n\n## 场景二：数据分析——Q3销售报告 ​\n\n### 原始想法 ​\n\n\"我想做一个销售数据可视化看板\"\n\n### 用JTBD重新分析 ​\n\n用户是谁？ 销售部门负责人，需要向管理层汇报季度业绩\n\n情境是什么？ 下周要开季度会议，需要准备汇报材料\n\n要完成什么任务？ 清楚展示Q3销售表现，回答\"我们做得怎么样？\"\n\n期望的结果是什么？ 让管理层快速理解业绩情况，为Q4策略提供依据\n\n目前的替代方案？ 手动在Excel里做图表，再复制到PPT\n\n替代方案的问题？ 每次都要重新做，格式不统一，耗时2-3小时\n\n### JTBD视角的任务描述 ​\n\n`当销售负责人准备季度汇报时，\n他想要清楚展示Q3的销售表现，\n以便于让管理层快速理解业绩情况，做出Q4决策。\n\n目前他用Excel做图表再复制到PPT，\n但每次都要重新做，格式不统一，耗时长。`\n### 这个分析改变了什么？ ​\n之前（功能视角）：\n\n\"帮我做一个销售看板，展示趋势、留存、转化……\"\n\n之后（任务视角）：\n\n\"帮我做一个Q3销售汇报页面。受众是管理层，他们关心的核心问题是'Q3做得怎么样'和'Q4应该怎么调整'。数据我会提供Excel，需要展示总销售额、月度趋势、和各区域对比。\"\n\n## 场景三：自动化脚本——Excel汇总 ​\n\n### 原始想法 ​\n\n\"我想写一个Python脚本处理Excel\"\n\n### 用JTBD重新分析 ​\n\n用户是谁？ 行政助理，负责汇总各部门周报\n\n情境是什么？ 每周五下午，需要把5个部门的周报汇总成一份总表\n\n要完成什么任务？ 把5个Excel合并成1个，计算汇总数据\n\n期望的结果是什么？ 下班前完成汇总，不用加班\n\n目前的替代方案？ 手动复制粘贴每个部门的数据\n\n替代方案的问题？ 容易出错，格式不统一，要花2小时\n\n### JTBD视角的任务描述 ​\n\n`当行政助理每周五下午需要汇总周报时，\n她想要快速把5个部门的Excel合并成一份总表，\n以便于准时下班，不用加班。\n\n目前她手动复制粘贴每个部门的数据，\n但容易出错、格式不统一，每次要花2小时。`\n### 这个分析改变了什么？ ​\n之前（技术视角）：\n\n\"帮我写Python脚本，用Pandas读取Excel，合并数据……\"\n\n之后（任务视角）：\n\n\"帮我自动化一个周报汇总流程。每周我会收到5个Excel文件，格式相同。需要把它们合并成一份总表，并计算合计行。输出一个新的Excel文件。\"\n\n## 场景四：给家人做工具——吃药提醒 ​\n\n### 原始想法 ​\n\n\"我想给我爸做一个吃药提醒App\"\n\n### 用JTBD重新分析 ​\n\n用户是谁？ 60岁的父亲，每天需要吃3种药\n\n情境是什么？ 每天早晚饭后需要吃药，经常忘记\n\n要完成什么任务？ 按时吃药，不漏服\n\n期望的结果是什么？ 身体健康，子女放心\n\n目前的替代方案？ 让家人提醒，或者在药盒上贴纸条\n\n替代方案的问题？ 家人不总在身边，纸条容易忽略\n\n### JTBD视角的任务描述 ​\n\n`当60岁的父亲每天需要吃药时，\n他想要有东西提醒他按时服药，\n以便于保持健康，让子女放心。\n\n目前他靠家人提醒或药盒上的纸条，\n但家人不总在身边，纸条容易被忽略。`\n### 这个分析改变了什么？ ​\n之前（功能视角）：\n\n\"帮我做一个吃药提醒App，要有药品管理、用量记录、库存追踪……\"\n\n之后（任务视角）：\n\n\"帮我给60岁的父亲做一个吃药提醒网页。他不太会用手机App，所以要极简设计：大字体、醒目颜色、每天早晚两个时间点提醒。只需要响铃提醒和'已服药'按钮，不需要其他功能。\"\n\n## 传统思维 vs JTBD思维对比 ​\n维度传统思维JTBD思维核心问题\"我要做什么功能？\"\"用户要完成什么任务？\"起点功能清单用户场景关注点产品有什么用户需要什么竞争分析别人有什么功能用户现在怎么解决成功标准功能做完了任务完成得更好\n## 识别\"真正的任务\"三步法 ​\n\n当你有了一个想法，用这三步来识别真正的任务：\n\n### 第一步：问\"为什么\" ​\n\n我想做一个XXX。 → 为什么？\n\n继续问\"为什么\"，直到你找到真正的动机。\n\n示例：\n\n- 我想做一个习惯打卡App → 为什么？\n- 因为我想养成跑步习惯 → 为什么？\n- 因为我想减肥 → 为什么？\n- 因为我想更健康、更自信\n真正的任务是\"变得更健康更自信\"，不是\"做一个App\"。\n\n### 第二步：问\"现在怎么做\" ​\n\n你现在怎么解决这个问题？\n\n了解现有方案，能帮你理解真正的痛点。\n\n### 第三步：问\"哪里不爽\" ​\n\n现在的方案有什么问题？\n\n痛点往往藏在这里。你的解决方案只需要比现有方案好一点点，就能被\"雇佣\"。\n\n## 下一步 ​\n\n现在你已经理解了JTBD框架的核心思想和应用方法。\n\n下一节，我们会通过一个实践练习，让你用这个框架重新审视自己的想法。",
      "word_count": 2785,
      "estimated_time": 5
    },
    {
      "id": "lesson-026",
      "chapter_id": "chapter-02",
      "lesson_number": 4,
      "title": "2.1.4 实践练习：用JTBD重新审视你的想法",
      "content": "# 2.1.4 实践练习：用JTBD重新审视你的想法 ​\n\n理论学完了，现在轮到你动手了。\n\n这个练习会帮你把刚学到的JTBD思维应用到你自己的想法上。\n\n## 练习一：填写任务描述模板 ​\n\n拿出你现在想做的一个项目（或者用下面的示例），完成这个模板：\n\n### 模板 ​\nmarkdown\n`### 我的原始想法\n我想做一个 _______________________\n\n### JTBD任务描述\n\n**用户是谁？**\n[描述具体的人，不是\"所有人\"]\n\n**情境是什么？**\n[什么时候、什么情况下会用到？]\n\n**要完成什么任务？**\n[用户真正想达成的目标是什么？]\n\n**期望的结果/感受是什么？**\n[功能层面 + 情感层面]\n\n**目前的替代方案？**\n[用户现在怎么解决这个问题？]\n\n**替代方案的痛点？**\n[现有方案哪里不好用？]\n\n### 重新表述\n\n当 [某类用户] 在 [某个情境] 下，\n他们想要 [完成某个任务]，\n以便于 [获得某种结果/感受]。\n\n目前他们的方案是 [现有解决方式]，\n但这个方案的问题是 [痛点]。`\n### 填写示例 ​\nmarkdown\n```\n### 我的原始想法\n我想做一个读书笔记工具\n\n### JTBD任务描述\n\n**用户是谁？**\n上班族，每天通勤时在手机上看电子书，每周能看1-2本\n\n**情境是什么？**\n看书时遇到好句子想记下来，或者读完后想回顾要点\n\n**要完成什么任务？**\n保存书中的精华内容，日后能快速找到和回顾\n\n**期望的结果/感受是什么？**\n功能：读完的书有沉淀，不是看完就忘\n情感：觉得时间没白花，有成就感\n\n**目前的替代方案？**\n微信收藏、手机备忘录、读书App自带的划线功能\n\n**替代方案的痛点？**\n微信收藏找不到、备忘录没分类、App划线导出麻烦\n\n### 重新表述\n\n当上班族在通勤读书时看到好句子，\n他们想要快速保存下来，并在日后能方便地回顾，\n以便于让读书有沉淀、感到时间没白花。\n\n目前他们用微信收藏或备忘录，\n但内容零散、难以检索、无法形成体系。\n```\n\n## 练习二：自检清单 ​\n完成练习一后，用这个清单检验你的任务描述是否合格：\n\n- [ ] 用户具体吗？ 不是\"所有人\"，而是有具体特征的人\n- [ ] 情境明确吗？ 说清楚了\"什么时候、什么情况下\"\n- [ ] 任务是动词吗？ 是\"完成某事\"而不是\"拥有某功能\"\n- [ ] 包含情感层面吗？ 不只是功能需求，还有心理需求\n- [ ] 知道替代方案吗？ 了解用户现在怎么解决\n- [ ] 痛点真实吗？ 替代方案的问题是你观察到的，不是想象的\n如果有任何一项打不上勾，回去继续完善你的描述。\n\n## 练习三：案例对比分析 ​\n\n看看下面两个产品，思考它们成功/失败的原因：\n\n### 案例A：某习惯打卡App（失败） ​\n\n产品功能：\n\n- 21天习惯养成计划\n- 每日打卡提醒\n- 社交分享、排行榜\n- 习惯统计、成就系统\n- 付费解锁高级功能\n结果： 上线3个月后，日活不到1000，最终下架\n\n问题分析： 这个App假设用户需要\"养成习惯\"，但没有问：\n\n- 用户真的想养成什么习惯？\n- 为什么他们之前没养成？\n- 一个App真的能解决意志力问题吗？\nJTBD视角： 用户的任务不是\"打卡\"，而是\"变成更好的自己\"。 打卡只是手段，不是目的。 这个App把手段当成了目的。\n\n### 案例B：一个简单的计数器网页（成功） ​\n\n产品功能：\n\n- 一个大按钮\n- 点一下加一\n- 显示今天的次数\n- 没了\n结果： 一位健身教练用它记录每天做了多少个俯卧撑。 没有花哨功能，但每天都在用。\n\n成功原因： 精准解决了一个具体任务——\"记录今天做了多少个\"。 不多也不少。\n\nJTBD视角：\n\n`当健身教练锻炼时，\n他想要快速记录每组做了多少个，\n以便于追踪进步、保持动力。\n\n目前他用脑子记或者纸笔，\n但容易忘记、事后补记不准确。`\n### 思考题 ​\n\n- 案例A的功能比案例B多得多，为什么反而失败了？\n- 如果你是案例A的产品经理，用JTBD视角重新定义问题，你会怎么做？\n- 案例B成功的关键是什么？\n## 练习输出 ​\n完成上面的练习后，你应该得到：\n\n- 一份完整的任务描述：用JTBD模板重新定义你的想法\n- 通过自检的确认：六项检查全部打勾\n- 对案例的思考：理解为什么简单往往比复杂更好\n[配图建议]画面内容：一个人站在分岔路口，左边是写满功能清单的复杂路线，右边是只写着\"解决一个问题\"的简洁路线 Prompt：warm illustration of person at crossroads, left path crowded with feature lists, right path simple with one clear goal, friendly and approachable style, soft rounded shapes, pastel colors with coral accents, minimal text, educational infographic feel, clean white background, high quality, 8k --ar 16:9\n\n## 下一步 ​\n\n恭喜你完成了JTBD思维的学习和练习。\n\n现在你已经知道如何用\"任务视角\"来定义问题了。但这只是第一步。\n\n下一节，我们会总结本节的核心要点，并预告接下来要学习的\"逆向思维\"——如何提前预见并避开失败。",
      "word_count": 2323,
      "estimated_time": 4
    },
    {
      "id": "lesson-027",
      "chapter_id": "chapter-02",
      "lesson_number": 5,
      "title": "2.1.5 本节核心要点",
      "content": "# 2.1.5 本节核心要点 ​\n\n## 三条核心原则 ​\n\n`✓ 先问\"用户要完成什么任务\"，再想\"产品要有什么功能\"\n  ——功能是手段，任务是目的。搞反了就会做出没人用的东西。\n\n✓ 你的产品是被\"雇佣\"来完成任务的，完成得不好就会被\"解雇\"\n  ——用户不在乎你有多少功能，只在乎能不能帮他把事办了。\n\n✓ 理解任务的三个层次：功能任务、情感任务、社会任务\n  ——大多数初学者只看到功能层，忽略了情感和社会层。`\n## 本节检查清单 ​\n在进入下一节之前，确认你已经掌握：\n\n- [ ] 能用一句话解释什么是JTBD框架\n- [ ] 知道\"功能视角\"和\"任务视角\"的区别\n- [ ] 能用模板写出一个完整的任务描述\n- [ ] 理解为什么\"简单\"往往比\"复杂\"更好\n- [ ] 完成了至少一个场景的JTBD分析练习\n## 本节关键概念速查 ​\n概念一句话解释JTBD用户\"雇佣\"产品来完成任务，不是购买功能功能视角问\"产品要有什么功能\"任务视角问\"用户要完成什么任务\"功能任务用户要做的具体事情情感任务用户想要的感受社会任务用户想要的社会形象替代方案用户现在用什么方式解决问题\n## 承接下一节 ​\n\n现在你已经学会了如何用\"任务视角\"来定义问题。\n\n但只是定义清楚问题还不够。\n\n很多项目失败，不是因为没想清楚要做什么，而是因为没想清楚什么会导致失败。\n\n下一节，我们会学习\"逆向思维\"——一个帮你提前预见失败、避开陷阱的思维工具。\n\n这是硅谷顶级投资人和产品经理都在用的方法：\n\n\"告诉我我会死在哪里，这样我就永远不会去那里。\" —— Charlie Munger\n\n准备好了吗？让我们继续。\n\n👉 2.2 逆向思维：先想清楚什么会让产品失败",
      "word_count": 728,
      "estimated_time": 3
    },
    {
      "id": "lesson-028",
      "chapter_id": "chapter-02",
      "lesson_number": 6,
      "title": "2.2.2 逆向思维的智慧",
      "content": "# 2.2.2 逆向思维的智慧 ​\n\n## 一个数学家的发现 ​\n\n19 世纪，德国数学家 Carl Jacobi 在解决复杂问题时发现了一个规律：\n\n\"反转，永远反转。\"（Invert, always invert.）\n\nJacobi 发现，许多正向推导很难解决的数学问题，如果反过来思考，往往更容易找到答案。\n\n这个原则后来被 Charlie Munger 引入商业和投资领域，成为他最重要的思维工具之一。\n\n## 人类思维的默认模式 ​\n\n我们的大脑天生习惯正向思考：\n\n- 想要成功 → 思考如何成功\n- 想要用户喜欢 → 思考如何让用户喜欢\n- 想要项目顺利 → 思考如何让项目顺利\n这种思维方式有一个问题：它让我们只看到我们想看到的东西。\n\n心理学研究表明，人类存在一种\"乐观偏见\"——我们倾向于高估成功的可能性，低估失败的风险。这种偏见在创业者和项目发起人身上尤为明显。\n\n## 逆向思维的力量 ​\n\n逆向思维的核心是把问题反过来问：\n正向思维逆向思维如何让用户喜欢我的产品？什么会让用户讨厌我的产品？如何获得更多用户？什么会让用户放弃使用？如何让 AI 写出好代码？什么会让 AI 写出糟糕的代码？如何让数据分析有价值？什么会让分析结果毫无意义？如何让脚本稳定运行？什么情况会让脚本崩溃？\n为什么反过来问更有效？\n\n- 避免失败比追求成功更容易：你可能不知道成功的秘诀，但你通常能识别出明显的错误\n- 打破乐观偏见：当你主动思考失败原因时，那些被忽视的风险会浮出水面\n- 减少盲点：正向思维让你看到想看的，逆向思维让你看到不想看但必须看的\n## 实际案例：投资决策中的逆向思维 ​\n\nCharlie Munger 和 Warren Buffett 在 Berkshire Hathaway 的投资决策中大量使用逆向思维。\n\n他们不会问\"这家公司为什么会成功\"，而是先问：\n\n- 什么会让这家公司失败？\n- 什么情况下我们会后悔这笔投资？\n- 这个行业有什么结构性风险？\n只有当他们想不出足够多的失败理由时，才会考虑投资。\n\n这种方法帮助他们避开了无数看起来很诱人但实际上风险很高的投资机会。\n\n## 对 Vibe Coding 的启示 ​\n\n当你准备用 AI 做一个项目时，不要只想\"这个东西做出来会有多棒\"。\n\n先问自己：\n\n- 什么会让这个项目彻底失败？\n- 什么会让我三天后就放弃？\n- 什么会让做出来的东西没人用（包括我自己）？\n这些问题的答案，往往比\"如何成功\"更有价值。\n\n下一节，我们将学习一个具体的技术，帮助你系统性地回答这些问题。",
      "word_count": 1082,
      "estimated_time": 3
    },
    {
      "id": "lesson-029",
      "chapter_id": "chapter-02",
      "lesson_number": 7,
      "title": "2.2.3 预演失败：假设你的项目已经失败了",
      "content": "# 2.2.3 预演失败：假设你的项目已经失败了 ​\n\n## 什么是 Pre-mortem？ ​\n\nPre-mortem（预演失败）是由认知心理学家 Gary Klein 于 2007 年在《哈佛商业评论》上正式提出的技术。\n\n这个名字来源于医学术语：\n\n- Post-mortem（尸检）：人死后分析死因\n- Pre-mortem（预演失败）：项目\"死亡\"前分析可能的\"死因\"\n核心思想很简单：假设项目已经失败了，然后追溯原因。\n\n## 为什么 Pre-mortem 如此有效？ ​\n\nGary Klein 的研究表明，使用 Pre-mortem 技术可以将风险识别能力提高 30%。\n\n这种效果来自几个心理学机制：\n\n- \n打破乐观偏见：当你被要求\"想象失败已经发生\"时，大脑会切换到分析模式，而不是推销模式\n\n- \n释放负面想象：在正常的项目讨论中，人们不愿意说\"这个可能会失败\"。Pre-mortem 给了一个\"安全\"的空间来表达担忧\n\n- \n利用后见之明：人类对\"已发生的事情\"的分析能力，远强于对\"可能发生的事情\"的预测能力。Pre-mortem 利用这个特点，把\"预测\"变成\"回顾\"\n\n## Pre-mortem vs Post-mortem ​\n对比项Post-mortem（事后复盘）Pre-mortem（预演失败）时机项目结束后项目开始前问题\"为什么失败了？\"\"假设失败了，为什么？\"心态追责、总结教训预防、提前规避成本已经付出代价零成本价值下次不犯同样的错这次就不犯错\n## 完整操作步骤 ​\n\n以下是 Pre-mortem 的六步操作法：\n\n### 第一步：设定失败场景 ​\n\n清晰地描述失败的状态。要具体，不要模糊。\n\n`❌ 模糊：\"项目失败了\"\n✅ 具体：\"现在是3个月后，我的待办清单App已经被我彻底放弃。\n         它一直躺在手机里，但我从未打开过。我又回到了用便签纸记事的状态。\"`\n### 第二步：独立思考失败原因 ​\n在不受他人影响的情况下，写下所有可能导致失败的原因。\n\n要点：\n\n- 至少写 5 条\n- 不要自我审查，写下任何想到的原因\n- 包括技术原因、使用习惯原因、外部环境原因\n### 第三步：分类整理 ​\n\n把失败原因按类型整理：\n类型示例需求问题解决的不是真问题、功能太多太复杂技术问题性能太差、经常崩溃、数据丢失使用场景问题使用场景与设计不符、操作太繁琐习惯问题没有形成使用习惯、被其他工具替代外部因素没时间维护、需求变化了\n### 第四步：评估严重性和可能性 ​\n\n对每个失败原因进行评估：\n失败原因可能性严重性优先级功能太多，学习成本高高高⚠️ 必须解决没有提醒功能，容易忘记中高⚠️ 必须解决界面不好看中低可以接受服务器宕机低高暂时忽略\n### 第五步：制定预防措施 ​\n\n对于高优先级的失败原因，制定具体的预防措施：\n失败原因预防措施功能太多，学习成本高第一版只做3个核心功能，其他放入\"不做清单\"没有提醒功能，容易忘记提醒功能作为 P0 必须实现\n### 第六步：更新你的计划 ​\n\n把预防措施整合到你的项目计划中。这些措施应该成为你给 AI 的需求描述的一部分。\n\n## 贯穿案例：待办清单 App 的 Pre-mortem ​\n\n让我们用小李的待办清单项目做一个完整示范。\n\n失败场景设定：\n\n现在是 3 个月后。我的待办清单 App 已经彻底失败了。它安装在我手机里，但我已经两个月没打开过。我又回到了用微信\"文件传输助手\"记事的状态。\n\n失败原因分析：\n\n- \n功能太多，打开就头大：我最初要了 12 个功能，结果界面密密麻麻，找个添加按钮都要找半天\n\n- \n添加任务太麻烦：每次添加任务要填 5 个字段（标题、分类、优先级、截止日期、备注），我只是想记个\"买牙膏\"，结果要操作 30 秒\n\n- \n没有形成使用习惯：App 不会主动提醒我，我总是忘记打开它\n\n- \n和现有工作流冲突：我的待办事项来自微信、邮件、会议，但这个 App 是个孤岛，我还是要手动搬运\n\n- \n数据同步出问题：有一次手机重装后数据丢了，我就再也不信任它了\n\n预防措施：\n失败原因预防措施落实到需求功能太多第一版只做：添加、查看、完成告诉 AI \"只做这3个功能\"添加太麻烦一键添加，只需输入标题\"添加任务只需一个输入框\"没有提醒每日定时提醒\"需要每日提醒功能\"数据丢失云端同步\"数据需要保存在云端\"\n经过这个 Pre-mortem，小李的需求从\"12 个功能\"变成了\"3 个核心功能 + 2 个保障性功能\"。\n\n这才是一个可以成功的起点。",
      "word_count": 1898,
      "estimated_time": 3
    },
    {
      "id": "lesson-030",
      "chapter_id": "chapter-02",
      "lesson_number": 8,
      "title": "2.2.4 Vibe Coding 项目的常见失败原因",
      "content": "# 2.2.4 Vibe Coding 项目的常见失败原因 ​\n\n根据大量实践经验，Vibe Coding 项目最常见的失败原因可以分为几类。\n\n了解这些\"前人踩过的坑\"，可以帮助你在做 Pre-mortem 时更全面地思考。\n\n## 一、需求层面的失败 ​\n\n### 1. 需求不清晰 ​\n\n典型表现：\n\n- \"帮我做一个好用的 App\"\n- \"我想要一个能提高效率的工具\"\n为什么会失败：\n\nAI 无法读心。\"好用\"对你意味着什么？\"提高效率\"具体指哪个环节？\n\n模糊的输入只会得到模糊的输出。AI 会按照它的理解去实现，而它的理解很可能和你想的完全不同。\n\n真实案例：\n\n张三让 AI \"做一个笔记 App\"。AI 做出来的是一个功能完整的 Markdown 编辑器，支持语法高亮、导出 PDF、多级文件夹……但张三只是想要一个能快速记录灵感的地方，一句话就够了。\n\n### 2. 一次性要太多 ​\n\n典型表现：\n\n- 第一版就要 20 个功能\n- \"像 XX 产品一样，但要有这些改进……\"\n为什么会失败：\n\n复杂度的增长是指数级的，不是线性的。\n\n2 个功能之间可能有 1 种交互关系。 5 个功能之间可能有 10 种交互关系。 20 个功能之间可能有 190 种交互关系。\n\nAI 处理复杂系统时更容易出错，你也更难发现和定位问题。\n\n真实案例：\n\n李四一次性要求 AI 实现\"用户注册、登录、个人中心、任务管理、团队协作、权限控制、数据统计、消息通知\"。结果代码越改越乱，三天后整个项目变成了一团无法维护的意大利面条。\n\n## 二、价值层面的失败 ​\n\n### 3. 没有核心价值 ​\n\n典型表现：\n\n- 功能很多，但没有一个是\"非用不可\"的\n- 用户找不到留下来的理由\n为什么会失败：\n\n用户的注意力是稀缺的。如果你的工具不能在 10 秒内让用户感受到价值，他们就会离开。\n\n功能数量不等于价值。一个真正解决痛点的功能，比十个\"还不错\"的功能更有吸引力。\n\n自检方法：\n\n问自己：如果这个工具只能保留一个功能，我会保留哪个？那个功能是否足够强大，让人愿意单独为它使用这个工具？\n\n## 三、场景层面的失败 ​\n\n### 4. 忽视真实使用场景 ​\n\n典型表现：\n\n- 坐在电脑前设计给别人用的工具\n- 假设用户会在安静、专注的环境下使用\n为什么会失败：\n\n你设计的待办清单可能需要用户坐下来认真整理，但用户实际上是在地铁上、在开会的间隙、在带孩子的时候想要快速记录一件事。\n\n不同场景的失败案例：\n场景你的假设真实情况给自己用的工具我会认真使用新鲜感过后就忘了打开给家人用的工具他们会按我设计的方式使用60 岁的父母看不清小字，不理解图标含义数据分析脚本数据格式是标准的实际数据有缺失值、格式不统一、编码问题自动化脚本运行环境是固定的换台电脑路径就不对了，周末服务器维护就报错了\n## 四、技术层面的失败 ​\n\n### 5. 技术选择不当 ​\n\n典型表现：\n\n- 简单问题复杂化（用火箭炮打蚊子）\n- 复杂问题简单化（用 Vibe Coding 做不适合的事）\n简单问题复杂化的例子：\n\n只是想记录每天喝了几杯水，却要求 AI 做一个带数据库、带用户系统、带数据可视化的完整应用。实际上，一个本地的 HTML 文件就够了。\n\n复杂问题简单化的例子：\n\n想用 Vibe Coding 做一个涉及支付、用户隐私、实时通信的系统。这些领域有严格的安全和合规要求，不适合用\"快速原型\"的方式来做。\n\n## 五、多元场景的特定失败原因 ​\n\n### 数据分析场景 ​\n失败原因具体表现问题不清晰\"帮我分析一下这个数据\"——分析什么？想回答什么业务问题？数据质量差缺失值、异常值、格式不统一，AI 也无能为力结论无法落地分析出来的结论很有趣，但没人知道下一步该做什么\n### 自动化脚本场景 ​\n失败原因具体表现边界情况没考虑正常数据运行良好，一遇到空值/特殊字符就崩溃环境依赖在你电脑上能跑，换个环境就报错没有错误处理脚本跑到一半失败，不知道处理到哪里了，也不知道怎么恢复\n### 给家人做工具场景 ​\n失败原因具体表现忽视认知差异你觉得\"滑动删除\"很直观，他们根本不知道可以滑动字太小、按钮太小60 岁以上用户的视力和手指精度都不如年轻人步骤太多你能接受 5 步完成一个操作，他们可能在第 2 步就放弃了\n## 如何使用这份清单 ​\n\n在你做 Pre-mortem 时，可以对照这份清单问自己：\n\n- [ ] 我的需求描述足够清晰吗？AI 能准确理解吗？\n- [ ] 我第一版要的功能是不是太多了？\n- [ ] 我的工具有没有一个\"非用不可\"的核心功能？\n- [ ] 我考虑过用户的真实使用场景吗？\n- [ ] 我的技术选择和问题复杂度匹配吗？\n下一节，我们将用一个完整的模板，带你为自己的项目做一次 Pre-mortem。",
      "word_count": 2016,
      "estimated_time": 4
    },
    {
      "id": "lesson-031",
      "chapter_id": "chapter-02",
      "lesson_number": 9,
      "title": "2.2.5 实战练习：为你的项目做 Pre-mortem",
      "content": "# 2.2.5 实战练习：为你的项目做 Pre-mortem ​\n\n现在轮到你了。\n\n无论你想做的是一个小工具、一份数据分析、一个自动化脚本，还是给家人做的小网页，都可以用这个模板来做一次 Pre-mortem。\n\n## Pre-mortem 完整模板 ​\n\n以下模板可以直接复制使用：\nmarkdown\n`# Pre-mortem 分析：[你的项目名称]\n\n## 第一步：失败场景设定\n\n现在是 [3个月/6个月] 后，我的 [项目名称] 已经彻底失败了。\n\n具体表现是：\n- [描述失败的具体状态，比如\"我已经不再使用它\"]\n- [描述你回到了什么状态，比如\"又回到了用Excel手动处理的日子\"]\n\n## 第二步：失败原因列举\n\n这个项目失败是因为：\n\n1. ________________________________\n2. ________________________________\n3. ________________________________\n4. ________________________________\n5. ________________________________\n（至少写5条，越多越好）\n\n## 第三步：分类与评估\n\n| 失败原因 | 类型 | 可能性 | 严重性 | 优先级 |\n|---------|------|-------|-------|-------|\n| 原因1 | 需求/技术/场景/习惯 | 高/中/低 | 高/中/低 | ⚠️/⚡/✓ |\n| 原因2 | | | | |\n| 原因3 | | | | |\n| ... | | | | |\n\n优先级说明：\n- ⚠️ 必须解决：高可能性 + 高严重性\n- ⚡ 应该解决：高可能性 或 高严重性\n- ✓ 可以接受：低可能性 + 低严重性\n\n## 第四步：预防措施\n\n| 失败原因（⚠️和⚡的） | 预防措施 | 如何落实到需求 |\n|---------------------|---------|---------------|\n| | | |\n| | | |\n| | | |\n\n## 第五步：更新后的需求描述\n\n基于以上分析，我的项目需求更新为：\n\n**核心功能（必须有）：**\n1. \n2. \n3. \n\n**保障性功能（防止失败）：**\n1. \n2. \n\n**明确不做的功能：**\n1. \n2.`\n## 填写示例：待办清单 App ​\nmarkdown\n```\n# Pre-mortem 分析：我的待办清单 App\n\n## 第一步：失败场景设定\n\n现在是 3个月 后，我的 待办清单App 已经彻底失败了。\n\n具体表现是：\n- 我已经两个月没打开过这个App\n- 又回到了用微信给自己发消息记事的状态\n\n## 第二步：失败原因列举\n\n这个项目失败是因为：\n\n1. 功能太多，界面太复杂，每次打开都不知道该点哪里\n2. 添加任务太麻烦，要填太多字段，不如直接发微信快\n3. 没有提醒功能，总是忘记打开App查看任务\n4. 有一次数据丢失后，我就不再信任它了\n5. 和我的工作流不匹配，待办事项来源太分散\n6. 新鲜感过后，没有动力继续使用\n\n## 第三步：分类与评估\n\n| 失败原因 | 类型 | 可能性 | 严重性 | 优先级 |\n|---------|------|-------|-------|-------|\n| 功能太多太复杂 | 需求 | 高 | 高 | ⚠️ |\n| 添加任务太麻烦 | 场景 | 高 | 高 | ⚠️ |\n| 没有提醒功能 | 需求 | 高 | 中 | ⚡ |\n| 数据丢失 | 技术 | 中 | 高 | ⚡ |\n| 和工作流不匹配 | 场景 | 中 | 中 | ✓ |\n| 新鲜感消退 | 习惯 | 高 | 中 | ⚡ |\n\n## 第四步：预防措施\n\n| 失败原因 | 预防措施 | 落实到需求 |\n|---------|---------|-----------|\n| 功能太多太复杂 | 第一版只做3个功能 | 只做：添加、查看、完成 |\n| 添加任务太麻烦 | 一键添加 | 只需输入任务标题，其他都是可选 |\n| 没有提醒功能 | 每日定时提醒 | 每天早上9点推送今日任务 |\n| 数据丢失 | 云端存储 | 使用云数据库，不存本地 |\n| 新鲜感消退 | 设计使用激励 | 完成任务时有小动画反馈 |\n\n## 第五步：更新后的需求描述\n\n**核心功能（必须有）：**\n1. 快速添加任务（只需输入标题）\n2. 查看任务列表\n3. 标记任务完成\n\n**保障性功能（防止失败）：**\n1. 每日提醒\n2. 云端数据同步\n\n**明确不做的功能：**\n1. 任务分类和标签（第一版不做）\n2. 子任务拆解（第一版不做）\n3. 统计报表（第一版不做）\n```\n\n## 让 AI 帮你做 Pre-mortem ​\n如果你不知道从哪里开始，可以用这个 Prompt 让 AI 帮你做分析：\n\n`我想做一个 [简要描述你的项目]。\n\n请帮我做一个 Pre-mortem 分析：\n1. 假设这个项目 3 个月后失败了，请列出 10 个可能的失败原因\n2. 对每个原因评估可能性（高/中/低）和严重性（高/中/低）\n3. 对于高可能性或高严重性的原因，给出具体的预防措施\n4. 最后，基于这个分析，告诉我第一版应该做什么、不应该做什么\n\n背景信息：\n- 我的目标用户是：[描述]\n- 我想解决的核心问题是：[描述]\n- 我计划使用的工具是：[比如 Cursor、Bolt.new 等]`使用示例：\n\n`我想做一个帮助我妈妈记录吃药时间的小工具。\n\n请帮我做一个 Pre-mortem 分析：\n1. 假设这个项目 3 个月后失败了，请列出 10 个可能的失败原因\n2. 对每个原因评估可能性（高/中/低）和严重性（高/中/低）\n3. 对于高可能性或高严重性的原因，给出具体的预防措施\n4. 最后，基于这个分析，告诉我第一版应该做什么、不应该做什么\n\n背景信息：\n- 我的目标用户是：我60岁的妈妈，不太会用智能手机\n- 我想解决的核心问题是：她经常忘记吃药，或者忘记自己吃过没有\n- 我计划使用的工具是：Bolt.new`\n## 不同场景的 Pre-mortem 问题清单 ​\n根据你想做的事情类型，重点关注不同的失败风险：\n\n### 如果你在做小工具/产品原型 ​\n\n- [ ] 我第一版要的功能是否超过 5 个？\n- [ ] 核心功能的使用流程是否超过 3 步？\n- [ ] 是否考虑了用户的真实使用场景和时机？\n### 如果你在做数据分析 ​\n\n- [ ] 我要回答的业务问题是否清晰？\n- [ ] 数据源是否可靠？是否有缺失值、异常值？\n- [ ] 分析结论是否能指导具体行动？\n### 如果你在做自动化脚本 ​\n\n- [ ] 是否考虑了各种边界情况（空值、特殊字符、超大文件）？\n- [ ] 脚本失败时是否有错误提示和恢复机制？\n- [ ] 是否依赖特定的运行环境？换台电脑还能跑吗？\n### 如果你在给家人做工具 ​\n\n- [ ] 他们的视力、手指灵活度是否与年轻人不同？\n- [ ] 他们是否理解你认为\"常识\"的交互方式（如滑动删除）？\n- [ ] 操作步骤是否足够少（最好不超过 2 步）？\n完成 Pre-mortem 后，你会发现自己的需求变得更加清晰和聚焦。\n\n这正是下一节\"减法思维\"要讲的内容——如何从一堆想法中，提炼出真正重要的核心。",
      "word_count": 3106,
      "estimated_time": 6
    },
    {
      "id": "lesson-032",
      "chapter_id": "chapter-02",
      "lesson_number": 10,
      "title": "2.2.6 本节核心要点",
      "content": "# 2.2.6 本节核心要点 ​\n\n## 核心概念回顾 ​\n概念定义核心问题逆向思维通过思考\"什么会导致失败\"来规避风险什么会让这个项目失败？Pre-mortem假设项目已经失败，追溯可能的原因如果失败了，是因为什么？避坑清单把失败原因转化为预防措施如何避免这些失败？\n## 核心要点 ​\n\n✓ 避免失败比追求成功更容易：你可能不知道成功的秘诀，但你通常能识别出明显的错误。先排除错误，再追求正确。\n\n✓ Pre-mortem：假设已经失败，追溯原因：这个技术利用人类\"后见之明\"的能力，把\"预测\"变成\"回顾\"，可以将风险识别能力提高 30%。\n\n✓ 把失败原因转化为预防措施：识别风险只是第一步，关键是把每个高优先级的失败原因，转化为具体的预防措施，并落实到需求中。\n\n## 本节检查清单 ​\n\n在开始你的项目之前，确保你能回答以下问题：\n\n- [ ] 我做过 Pre-mortem 分析吗？\n- [ ] 我列出了至少 5 个可能的失败原因吗？\n- [ ] 我识别出了高可能性、高严重性的风险吗？\n- [ ] 我为这些风险制定了具体的预防措施吗？\n- [ ] 我把预防措施落实到需求描述中了吗？\n## 关键引用 ​\n\n\"告诉我我会死在哪里，这样我就永远不会去那里。\" —— Charlie Munger，伯克希尔·哈撒韦副董事长\n\n\"反转，永远反转。\" —— Carl Jacobi，德国数学家\n\n## 下一节预告 ​\n\n通过 Pre-mortem，你可能已经发现：很多失败原因都指向同一个问题——功能太多。\n\n下一节，我们将学习\"减法思维\"，理解 MVP 的真正含义，掌握\"如何砍功能\"的方法。\n\n你会发现，\"不做什么\"往往比\"做什么\"更重要。",
      "word_count": 724,
      "estimated_time": 3
    },
    {
      "id": "lesson-033",
      "chapter_id": "chapter-02",
      "lesson_number": 11,
      "title": "2.3.1 重新定义 MVP",
      "content": "# 2.3.1 重新定义 MVP ​\n\n## 一个熟悉的场景 ​\n\n还记得第一节里的小李吗？他在学习了「任务视角」后，重新审视了自己的待办清单项目。\n\n这次，他明确了核心任务：帮助职场人士不遗漏重要的事情。\n\n然后他又犯了另一个错误。\n\n他打开 AI 工具，输入：\n\n\"我要做一个帮职场人士不遗漏事情的待办清单。需要这些功能：添加任务、完成任务、查看任务、任务分类、优先级标签、截止日期提醒、重复任务、子任务拆解……\"\n\n他列了 14 个功能。\n\n三个月后，项目又一次搁浅了。\n\n## 问题出在哪？ ​\n\n小李这次已经想清楚了「要解决什么问题」，但他陷入了另一个陷阱：功能堆砌。\n\n他把「解决问题可能需要的所有功能」都列了出来，然后试图一次性全部实现。\n\n这是一个非常常见的错误。\n\n## 传统 MVP 的误区 ​\n\n你可能听说过 MVP 这个词。很多人对它的理解是：\n\nMVP = 功能数量最少的版本\n\n按照这个理解，小李可能会这样想：\n\n- 原来计划 14 个功能，那我砍到 7 个，这就是 MVP 了吧？\n这是错的。\n\nMVP 不是「功能最少」，而是「能验证核心假设的最小投入」。\n\n## MVP 的正确定义 ​\n\nMVP 的三个字母分别代表：\n字母单词错误理解正确理解MMinimum（最小）功能数量最少投入成本最少VViable（可行）能跑起来能验证假设PProduct（产品）完整的软件能给用户价值的东西\n关键洞见：MVP 是一个实验，不是一个产品。\n\n它的目的不是「做一个完整的东西」，而是「用最小的投入，验证你的核心假设是否成立」。\n\n## 一个经典案例：Dropbox ​\n\n2007 年，Drew Houston 想做一个云端文件同步工具。\n\n他面临一个问题：这个产品需要大量开发工作，但他不确定用户是否真的需要它。\n\n他的解决方案：不写一行代码，先做一个 3 分钟的演示视频。\n\n视频展示了「文件自动同步到云端」的效果（其实是假的），然后放到网上。\n\n结果：一夜之间，等待名单从 5,000 人涨到 75,000 人。\n\n这个视频就是 Dropbox 的 MVP。它验证了核心假设：「人们确实需要一个简单的文件同步工具」。\n\n## 这对你意味着什么 ​\n\n在开始动手之前，问自己一个问题：\n\n我的核心假设是什么？用什么最小的方式可以验证它？\n\n对于小李的待办清单项目：\n\n- 核心假设：职场人士愿意用一个极简工具来管理每日待办，而不是用便签纸或手机备忘录\n- 最小验证方式：一个只有「添加-完成-查看」三个功能的页面\n如果这三个功能都留不住用户，加再多功能也没用。\n\n如果这三个功能能留住用户，说明假设成立，可以继续迭代。\n\n## 多场景应用 ​\n\n减法思维不只适用于「做产品」：\n场景核心假设示例MVP 形式数据分析报告老板最关心的是销售转化率先做一张转化率趋势图，看老板反馈自动化脚本Excel 汇总是最耗时的重复工作先自动化一个部门的汇总，验证效果给爸妈做吃药提醒他们能看懂大字和简单按钮一个只有「吃了」按钮的页面\n## 本节要点 ​\n\n你现在已经理解了 MVP 的真正含义：\n\n- MVP 是实验，不是产品\n- 它的目的是验证假设，不是取悦用户\n- 「最小」指的是投入成本，不是功能数量\n接下来，我们通过真实案例，看看「做减法」和「堆功能」的项目有什么不同。",
      "word_count": 1394,
      "estimated_time": 3
    },
    {
      "id": "lesson-034",
      "chapter_id": "chapter-02",
      "lesson_number": 12,
      "title": "2.3.2 真实案例对比",
      "content": "# 2.3.2 真实案例对比 ​\n\n让我们通过几个真实案例，看看「功能堆砌」和「减法思维」的区别。\n\n## 反面案例：14 功能待办清单的失败 ​\n\n### 项目背景 ​\n\n小李想做一个待办清单工具，帮助自己管理工作事项。\n\n他的第一版规划包含以下功能：\n\n- 任务分类\n- 优先级标签\n- 截止日期提醒\n- 重复任务\n- 子任务拆解\n- 标签系统\n- 日历视图\n- 看板视图\n- 统计报表\n- 多设备同步\n- 团队协作\n- 评论功能\n- 暗黑模式\n- 桌面小组件\n### 发生了什么 ​\n\n- 第 1 周：搭建项目框架，实现了基础的添加任务功能\n- 第 2-4 周：开始做任务分类和标签，遇到数据结构问题，反复修改\n- 第 5-8 周：日历视图和看板视图开发，UI 调整花了大量时间\n- 第 9-12 周：多设备同步需要后端，学习后端知识，进度缓慢\n- 第 12 周后：心态崩溃，项目搁置\n### 结果 ​\n\n- 断断续续做了 3 个月，功能还没完成一半\n- 每个功能都是半成品，充满 bug\n- 自己试用后发现：「这比我现在用的便签纸还麻烦」\n- 项目放弃\n### 问题分析 ​\n问题具体表现没有核心假设不知道在验证什么，只是在「做功能」功能太多14 个功能分散了精力，没有一个做好没有验证节点3 个月后才发现方向可能有问题完美主义每个功能都想做到完美，反而什么都没完成\n## 正面案例：「只需一个按钮」的习惯打卡 ​\n\n### 项目背景 ​\n\n另一个人想做一个习惯养成工具。\n\n她的核心假设是：人们坚持不了习惯，是因为记录太麻烦。如果记录只需要点一下按钮，坚持率会提高。\n\n### 她的 MVP ​\n\n只有三个元素：\n\n- 一个习惯名称（比如「喝水」）\n- 一个大按钮（点击 = 今天完成了）\n- 一个连续天数显示\n没有统计图表，没有提醒功能，没有社交分享，没有成就系统。\n\n### 发生了什么 ​\n\n- 第 1 天：用 AI 生成了这个简单页面\n- 第 2-7 天：自己试用，发现确实比之前用的 App 更容易坚持\n- 第 2 周：发给 5 个朋友试用，收到反馈\n- 第 3 周：根据反馈加了「多个习惯」功能\n- 第 4 周：加了简单的周统计\n### 结果 ​\n\n- 1 个月内验证了核心假设：「简单确实能提高坚持率」\n- 收集了真实用户反馈，知道下一步该做什么\n- 项目持续迭代，现在有 50 多个朋友在用\n## 更多场景的案例对比 ​\n\n### 数据分析场景 ​\n方面失败做法成功做法目标做一份「全面」的销售分析报告回答老板的一个问题：「哪个渠道 ROI 最高？」内容50 个图表，覆盖所有指标1 张对比图 + 3 句结论时间花了 2 周，老板没时间看完花了 2 小时，老板当天就做了决策价值「辛苦了，放这儿吧」「这个分析很有用，下次再做一个 XX」\n### 自动化脚本场景 ​\n方面失败做法成功做法目标做一个「万能」Excel 处理工具自动化「每周五汇总 5 个部门数据」这一件事功能支持各种格式、各种操作只做这一个特定任务时间做了 1 个月，还在加功能2 小时搞定，每周省 3 小时维护代码复杂，改一个地方坏另一个代码简单，自己能维护\n### 给家人做工具场景 ​\n方面失败做法成功做法目标给爸妈做一个「完美」的吃药提醒 App让爸妈不忘吃药设计精美 UI、多种提醒方式、用药记录大字、一个「吃了」按钮结果爸妈觉得太复杂，不愿意用爸妈每天都在用关键差异按自己的审美设计按爸妈的使用能力设计\n## 失败项目 vs 成功项目的特征对比 ​\n特征失败项目成功项目核心假设模糊或没有清晰明确功能数量越多越好只做必须的验证周期很长，甚至没有很短，快速迭代成功标准「功能都做完了」「假设被验证了」用户参与做完再给用户看尽早让用户参与对待反馈防御性：「他们不懂」开放性：「他们的反馈很有价值」\n## 本节要点 ​\n\n通过这些案例，你应该能看出区别：\n\n- 失败项目往往死于「功能太多」，而不是「功能太少」\n- 成功项目的共同点是「聚焦」和「快速验证」\n- 减法思维的核心是：先验证假设，再考虑扩展\n接下来，我们深入拆解 MVP 的三个关键词，帮你建立更清晰的判断标准。",
      "word_count": 1735,
      "estimated_time": 3
    },
    {
      "id": "lesson-035",
      "chapter_id": "chapter-02",
      "lesson_number": 13,
      "title": "2.3.3 MVP 的真正含义",
      "content": "# 2.3.3 MVP 的真正含义 ​\n\n现在让我们深入拆解 MVP 的三个关键词，建立更清晰的判断标准。\n\n## 三个关键词深度解读 ​\n\n### M = Minimum（最小） ​\n错误理解正确理解功能数量最少投入成本最少砍掉「不重要」的功能砍掉「不能验证假设」的功能做一个「简陋版」做一个「聚焦版」\n关键洞见：「最小」的对象是你的投入（时间、精力、金钱），不是功能列表。\n\n例子：\n\n- Dropbox 的 MVP 是一个视频，投入最小\n- 习惯打卡的 MVP 是一个按钮，投入最小\n- 你的 MVP 应该是能验证假设的最小投入形式\n### V = Viable（可行） ​\n错误理解正确理解能跑起来、不报错能验证核心假设技术上可行商业/价值上可行「它能工作」「它能证明或否定我的假设」\n关键洞见：「可行」不是技术概念，而是验证概念。\n\n例子：\n\n- 一个能完美运行但没人用的 App，不是「可行」的\n- 一个有 bug 但能验证用户确实需要这个功能的原型，是「可行」的\n- 判断标准不是「它跑得好不好」，而是「它能不能告诉我假设对不对」\n### P = Product（产品） ​\n错误理解正确理解完整的软件/App能给用户价值的东西必须是代码可以是任何形式必须能「发布」只要能验证就行\n关键洞见：「产品」可以是任何能交付价值的东西。\n\n例子：\n\n- 一个手绘的界面草图（验证用户是否理解你的设计）\n- 一个 Excel 表格（验证你的数据分析逻辑是否有效）\n- 一段人工执行的流程（验证这个流程是否真的能解决问题）\n- 一个落地页（验证用户是否愿意注册）\n## MVP 的本质：一个实验 ​\n\n理解了这三个词，你会发现 MVP 的本质是：\n\n用最小的投入，验证核心假设，交付最小的价值。\n\n它不是一个「产品」，而是一个「实验」。\n\n实验的目的是获取信息：\n\n- 我的假设对吗？\n- 用户真的需要这个吗？\n- 这个方向值得继续投入吗？\n## 核心假设的重要性 ​\n\nMVP 存在的意义是验证假设。那么，什么是核心假设？\n\n核心假设是你做这件事的基本前提。如果这个假设不成立，整个项目就没有价值。\n\n### 核心假设模板 ​\n\n`我假设：\n[某类用户] 存在 [某个问题/需求]，\n他们愿意使用 [我的解决方案] 来 [完成某个任务]，\n因为它比现有方案 [更快/更简单/更便宜/更有效]。`\n### 示例 ​\n待办清单项目：\n\n`我假设：\n职场人士存在「怕遗漏重要事项」的问题，\n他们愿意使用一个极简待办工具来管理每日任务，\n因为它比便签纸/手机备忘录更容易坚持使用。`数据分析项目：\n\n`我假设：\n销售团队存在「不知道哪个渠道效果好」的问题，\n他们愿意看一份渠道 ROI 对比分析来做决策，\n因为它比凭感觉判断更准确。`自动化脚本项目：\n\n`我假设：\n财务人员存在「每周手动汇总 Excel」的痛点，\n他们愿意使用一个自动化脚本来完成这个任务，\n因为它比手动操作更快且不易出错。`\n## 验证标准：怎么知道假设成立了？ ​\n有了假设，还需要定义验证标准。否则你永远不知道假设是否成立。\n\n### 验证标准模板 ​\n\n`如果：\n- [具体数量] 个用户\n- 在 [具体时间段] 内\n- 完成了 [具体行为]\n\n则说明假设成立，值得继续投入。`\n### 示例 ​\n待办清单项目：\n\n`如果：\n- 5 个朋友\n- 在 2 周内\n- 每天都打开并添加/完成任务\n\n则说明「极简待办」确实比便签纸更容易坚持。`数据分析项目：\n\n`如果：\n- 老板/销售主管\n- 在看完报告后\n- 根据分析结论做了决策\n\n则说明这个分析确实有业务价值。`\n## 常见误区 ​\n\n### 误区 1：功能多 = 用户满意 ​\n现实：用户满意度与功能数量没有正相关。\n\n根据产品研究数据：\n\n- 用户实际使用的功能通常不到产品总功能的 20%\n- 功能越多，学习成本越高，放弃率越高\n- 「少而精」的产品往往比「多而杂」的产品口碑更好\n### 误区 2：先做完再验证 ​\n\n现实：越晚验证，纠错成本越高。\n\n- 第 1 周发现方向错误：损失 1 周\n- 第 12 周发现方向错误：损失 12 周\n- 上线后发现方向错误：可能损失全部投入\n### 误区 3：MVP 就是做得差一点 ​\n\n现实：MVP 是聚焦，不是敷衍。\n\n- 错误：每个功能都做 60 分\n- 正确：只做 3 个功能，每个做 90 分\n## 本节要点 ​\n\n你现在对 MVP 应该有了更清晰的理解：\n\n- Minimum：最小投入，不是最少功能\n- Viable：能验证假设，不只是能运行\n- Product：能交付价值，不限于软件形式\n- MVP 是实验，核心任务是验证假设\n- 必须有明确的假设和验证标准\n接下来，我们学习具体的方法：如何从 20 个功能砍到 3 个。",
      "word_count": 2007,
      "estimated_time": 4
    },
    {
      "id": "lesson-036",
      "chapter_id": "chapter-02",
      "lesson_number": 14,
      "title": "2.3.4 如何从 20 个功能砍到 3 个",
      "content": "# 2.3.4 如何从 20 个功能砍到 3 个 ​\n\n理解了 MVP 的含义，下一个问题是：具体怎么做减法？\n\n本节提供一套可操作的方法。\n\n## 砍功能的三个灵魂问题 ​\n\n面对每一个功能，问自己这三个问题：\n\n### 问题 1：没有这个功能，产品还能用吗？ ​\n\n这个问题帮你区分「核心功能」和「附加功能」。\n\n判断标准：\n\n- 如果答案是「能」→ 这个功能不是核心功能\n- 如果答案是「不能」→ 这可能是核心功能\n待办清单的例子：\n功能没有它能用吗？结论添加任务不能核心功能完成任务不能核心功能查看任务列表不能核心功能任务分类能（先不分类也行）非核心暗黑模式能（不影响使用）非核心统计报表能（知道完成了就行）非核心\n### 问题 2：这个功能能验证我的核心假设吗？ ​\n\n这个问题帮你聚焦于验证假设的功能。\n\n判断标准：\n\n- 如果答案是「能」→ 考虑保留\n- 如果答案是「不能」→ 暂时不做\n待办清单的例子：\n\n假设核心假设是：「极简待办比便签纸更容易坚持」\n功能能验证假设吗？理由一键添加任务能测试「极简」是否真的更容易用打卡日历不确定可能有用，但不是验证「极简」的关键社交分享不能这是增长功能，不是验证功能成就系统不能这是留存功能，先验证核心价值再说\n### 问题 3：用户第一次使用就需要这个功能吗？ ​\n\n这个问题帮你区分「获客功能」和「留存功能」。\n\n判断标准：\n\n- 第一次使用就需要 → 可能是 P0\n- 用了一段时间才需要 → 可能是 P1\n- 锦上添花 → 可能是 P2\n关键洞见：\n\n- 新用户只关心「这个东西能帮我做什么」\n- 排行榜、成就系统、社交功能是让用户「留下来」的，不是让用户「进来」的\n- MVP 阶段应该聚焦于让用户「进来并体验核心价值」\n## P0/P1/P2 优先级框架 ​\n\n用三个问题筛选后，把功能分成三档：\n优先级定义行动示例P0没有就无法验证核心价值必须在 MVP 中包含添加任务、完成任务P1重要但可以后续迭代V2 版本再做任务分类、提醒功能P2锦上添花有时间再说暗黑模式、统计报表\n原则：\n\n- P0 功能不超过 3-5 个\n- 如果 P0 超过 5 个，说明你还没想清楚核心价值是什么\n- P1 和 P2 写下来但暂时不做，防止忘记也防止诱惑\n## 砍功能决策树 ​\n\n把上面的方法整理成一个决策流程：\n\n## AI 辅助：让 AI 帮你砍功能 ​\n\n你可以直接把功能列表交给 AI，让它帮你做优先级分析。\n\n### Prompt 模板 ​\nmarkdown\n`我正在做一个项目：[项目描述]\n\n目标用户是：[用户描述]\n\n我的核心假设是：[假设描述]\n\n我目前规划了这些功能：\n1. [功能1]\n2. [功能2]\n3. [功能3]\n...\n\n请帮我分析：\n1. 哪些是 P0 核心功能（没有就不能验证假设）\n2. 哪些是 P1 可以后续迭代的功能\n3. 哪些是 P2 锦上添花可以先砍掉的功能\n\n请给出分类理由。`\n### 示例：待办清单项目 ​\nmarkdown\n```\n我正在做一个项目：帮助职场人士管理每日待办事项\n\n目标用户是：25-35岁职场人士，每天有5-10个待办事项需要管理\n\n我的核心假设是：人们不用复杂的待办工具，是因为太麻烦；\n如果有一个极简的工具，他们会更愿意用\n\n我目前规划了这些功能：\n1. 添加任务\n2. 完成任务（打勾）\n3. 查看今日任务\n4. 任务分类\n5. 优先级标签\n6. 截止日期提醒\n7. 重复任务\n8. 子任务拆解\n9. 日历视图\n10. 统计报表\n11. 多设备同步\n12. 暗黑模式\n\n请帮我分析优先级。\n```\n\n### AI 可能的回复 ​\n\n```\n基于你的核心假设「极简更容易坚持」，我的分析如下：\n\n**P0（核心功能，必须有）**：\n1. 添加任务 - 最基础的功能\n2. 完成任务 - 验证「用起来」的闭环\n3. 查看今日任务 - 知道今天要做什么\n\n理由：这三个功能构成最小闭环，可以验证用户是否愿意用极简工具\n\n**P1（下个版本）**：\n4. 截止日期提醒 - 有价值，但可以先手动记\n5. 任务分类 - 任务多了才需要\n\n**P2（暂时不做）**：\n6-12 全部。理由：\n- 优先级标签、子任务：增加复杂度，与「极简」假设矛盾\n- 日历视图、统计报表：是「高级功能」，不是核心价值\n- 多设备同步：需要后端，大大增加开发复杂度\n- 暗黑模式：纯粹美化，不影响核心验证\n\n建议 MVP 只做前 3 个功能。\n```\n\n## 实战演练：为待办清单做减法 ​\n让我们用这套方法，为小李的项目做一次完整的减法：\n\n### 原始功能清单（14 个） ​\n\n- 任务分类\n- 优先级标签\n- 截止日期提醒\n- 重复任务\n- 子任务拆解\n- 标签系统\n- 日历视图\n- 看板视图\n- 统计报表\n- 多设备同步\n- 团队协作\n- 评论功能\n- 暗黑模式\n- 桌面小组件\n### 核心假设 ​\n\n职场人士愿意用一个极简工具管理待办，因为它比复杂工具更容易坚持。\n\n### 应用三个问题 ​\n功能Q1：没有能用？Q2：验证假设？Q3：首次需要？优先级添加任务不能能是P0完成任务不能能是P0查看任务不能能是P0任务分类能不确定不一定P1优先级标签能否（增加复杂度）否P2截止日期提醒能部分不一定P1重复任务能否否P2子任务拆解能否否P2标签系统能否否P2日历视图能否否P2看板视图能否否P2统计报表能否否P2多设备同步能否否P2团队协作能否否P2评论功能能否否P2暗黑模式能否否P2桌面小组件能否否P2\n### 结论 ​\n\nP0（MVP 必须有）：3 个\n\n- 添加任务\n- 完成任务\n- 查看今日任务\nP1（下个版本）：2 个\n\n- 任务分类\n- 截止日期提醒\nP2（暂不做）：12 个\n\n- 其他全部\n从 14 个功能砍到 3 个。这就是减法。\n\n## 本节要点 ​\n\n你现在掌握了具体的砍功能方法：\n\n- 三个灵魂问题帮你快速判断功能优先级\n- P0/P1/P2 框架帮你结构化思考\n- AI 可以辅助你做优先级分析\n- 核心原则：P0 不超过 3-5 个\n接下来，我们学习另一个被低估的工具：「不做清单」。",
      "word_count": 2567,
      "estimated_time": 5
    },
    {
      "id": "lesson-037",
      "chapter_id": "chapter-02",
      "lesson_number": 15,
      "title": "2.3.5 「不做清单」的魔力",
      "content": "# 2.3.5 「不做清单」的魔力 ​\n\n大多数人只列「要做清单」，很少有人列「不做清单」。\n\n但「不做清单」可能比「要做清单」更重要。\n\n## 为什么需要「不做清单」 ​\n\n### 原因 1：明确边界 ​\n\n当你告诉 AI「帮我做一个待办清单」，AI 可能会问你：要不要加日历同步？要不要支持团队协作？\n\n如果你没有明确的边界，很容易被这些问题带偏。\n\n「不做清单」让你和 AI 都清楚：这些事情不在范围内。\n\n### 原因 2：抵抗诱惑 ​\n\n做项目的过程中，你会不断产生新想法：\n\n- 「如果加一个 XX 功能会不会更好？」\n- 「竞品都有 XX，我是不是也该有？」\n- 「用户反馈说想要 XX……」\n这些诱惑会不断膨胀你的项目范围。\n\n「不做清单」是你的防线：这些功能我已经想过了，决定不做，理由在这里。\n\n### 原因 3：沟通工具 ​\n\n当别人问「为什么你没做 XX 功能」时，你可以清晰回答：\n\n这个功能在我的「不做清单」里。原因是 [理由]。我会在 [条件满足时] 重新考虑。\n\n这比「还没来得及做」或「以后再说」专业得多。\n\n## 「不做清单」的三个维度 ​\n\n一份完整的「不做清单」应该覆盖三个维度：\n\n### 维度 1：不做的功能 ​\n\n列出你明确决定不做的功能，以及理由。\n\n### 维度 2：不考虑的用户群 ​\n\n你的产品不可能服务所有人。明确你不打算服务谁。\n\n### 维度 3：不追求的指标 ​\n\nMVP 阶段你应该聚焦于验证，而不是增长。明确你暂时不关心什么指标。\n\n## 「不做清单」完整模板 ​\nmarkdown\n`# 不做清单（V1 版本明确不做的事情）\n\n## 一、不做的功能\n\n| 功能 | 不做的理由 | 何时重新考虑 |\n|-----|----------|-------------|\n| [功能名称] | [理由] | [条件] |\n\n## 二、不考虑的用户群\n\n| 用户群 | 不考虑的理由 |\n|-------|-------------|\n| [用户描述] | [理由] |\n\n## 三、不追求的指标\n\n| 指标 | 不追求的理由 | 替代关注点 |\n|-----|-------------|----------|\n| [指标名称] | [理由] | [替代指标] |`\n## 示例 1：待办清单项目的「不做清单」 ​\nmarkdown\n```\n# 不做清单（V1 版本）\n\n## 一、不做的功能\n\n| 功能 | 不做的理由 | 何时重新考虑 |\n|-----|----------|-------------|\n| 多设备同步 | 需要后端开发，大大增加复杂度 | 核心功能验证成功后 |\n| 团队协作 | 不是个人工具的核心价值 | 有明确的团队使用需求时 |\n| 暗黑模式 | 纯美化功能，不影响核心验证 | 有用户强烈反馈时 |\n| 日历视图 | 增加开发工作量，不是极简体验 | P0 功能稳定后 |\n| 统计报表 | 对于验证「极简好用」没有帮助 | 用户留存稳定后 |\n| 小组件 | 平台特定功能，增加维护成本 | 主产品成熟后 |\n\n## 二、不考虑的用户群\n\n| 用户群 | 不考虑的理由 |\n|-------|-------------|\n| 专业项目经理 | 他们需要复杂的项目管理功能，不是我们的定位 |\n| 团队用户 | V1 只做个人工具 |\n| 重度 GTD 用户 | 他们已有成熟工具，不是我们的目标 |\n\n## 三、不追求的指标\n\n| 指标 | 不追求的理由 | 替代关注点 |\n|-----|-------------|----------|\n| 用户总数 | MVP 阶段关注验证，不关注增长 | 留存率 |\n| 功能完整性 | 关注核心功能深度，不关注广度 | 核心功能使用频率 |\n| 美观程度 | 功能优先，美化后续迭代 | 可用性 |\n```\n\n## 示例 2：数据分析项目的「不做清单」 ​\nmarkdown\n```\n# 不做清单（本次分析项目）\n\n## 一、不做的分析\n\n| 分析内容 | 不做的理由 | 何时重新考虑 |\n|---------|----------|-------------|\n| 全渠道对比 | 老板只问了 ROI 最高的渠道 | 老板提出新问题时 |\n| 年度趋势 | 决策需要的是当前数据 | 季度汇报时 |\n| 用户画像分析 | 不是本次问题的核心 | 有用户相关问题时 |\n| 竞品对比 | 没有可靠数据来源 | 获得数据后 |\n\n## 二、不考虑的受众\n\n| 受众 | 不考虑的理由 |\n|-----|-------------|\n| 一线销售 | 本次报告给决策层看 |\n| 外部投资人 | 需要不同的呈现方式 |\n\n## 三、不追求的指标\n\n| 指标 | 不追求的理由 | 替代关注点 |\n|-----|-------------|----------|\n| 图表数量 | 信息密度比数量重要 | 每张图是否回答了问题 |\n| 视觉精美 | 清晰比精美重要 | 老板能否一眼看懂 |\n```\n\n## 示例 3：自动化脚本的「不做清单」 ​\nmarkdown\n```\n# 不做清单（Excel 自动化脚本 V1）\n\n## 一、不做的功能\n\n| 功能 | 不做的理由 | 何时重新考虑 |\n|-----|----------|-------------|\n| 图形界面 | 命令行足够，降低开发复杂度 | 非技术同事需要使用时 |\n| 自动邮件发送 | 先验证汇总功能 | 汇总功能稳定后 |\n| 多格式支持 | 目前只有 xlsx 格式 | 出现其他格式需求时 |\n| 错误自动修复 | 先报错提示，人工处理 | 常见错误模式明确后 |\n\n## 二、不考虑的场景\n\n| 场景 | 不考虑的理由 |\n|-----|-------------|\n| 跨部门数据 | 先搞定本部门 |\n| 历史数据迁移 | 只处理增量数据 |\n\n## 三、不追求的指标\n\n| 指标 | 不追求的理由 | 替代关注点 |\n|-----|-------------|----------|\n| 运行速度 | 每周只跑一次，快慢无所谓 | 正确性 |\n| 代码优雅 | 能用就行 | 可维护性 |\n```\n\n## AI 辅助：让 AI 帮你生成「不做清单」 ​\n\n### Prompt 模板 ​\nmarkdown\n```\n我正在做一个项目：[项目描述]\n\n目标用户是：[用户描述]\n\n核心假设是：[假设描述]\n\nP0 功能是：[P0 功能列表]\n\n请帮我生成一份「不做清单」，包括：\n1. 不做的功能（列出 5-8 个常见但本项目不应该做的功能）\n2. 不考虑的用户群（2-3 个）\n3. 不追求的指标（2-3 个）\n\n请给出理由和「何时重新考虑」的条件。\n```\n\n## 为什么你忍不住想加功能 ​\n了解这些心理障碍，有助于你抵抗它们：\n\n### 障碍 1：害怕不够好 ​\n\n- 想法：「功能这么少，用户会不会觉得太简陋？」\n- 真相：用户在意的是问题有没有被解决，不是功能多不多\n- 应对：问自己「核心问题解决了吗？」而不是「功能够不够多？」\n### 障碍 2：害怕错过 ​\n\n- 想法：「竞品都有这个功能，我不做会不会落后？」\n- 真相：你不是在和竞品比功能数量，你在验证自己的假设\n- 应对：记住你的核心假设是什么，不在验证范围内的功能都可以不做\n### 障碍 3：沉没成本 ​\n\n- 想法：「这个功能我已经想了很久了，不做太可惜」\n- 真相：想了很久不代表该做；做了再发现不该做，才是真的可惜\n- 应对：把它放进 P2，明确「想过但决定不做」\n### 障碍 4：假装忙碌 ​\n\n- 想法：「多做点功能，显得我很努力」\n- 真相：努力的方向错了，再努力也没用\n- 应对：用验证结果证明努力，而不是用功能数量\n## 本节要点 ​\n\n你现在理解了「不做清单」的价值：\n\n- 它帮你明确边界、抵抗诱惑、专业沟通\n- 应该覆盖三个维度：功能、用户群、指标\n- 了解心理障碍有助于你做出更理性的决策\n接下来，我们通过一个完整的练习，把本节所学应用到你自己的项目上。",
      "word_count": 3389,
      "estimated_time": 6
    },
    {
      "id": "lesson-038",
      "chapter_id": "chapter-02",
      "lesson_number": 16,
      "title": "2.3.6 实战练习：为你的项目做减法",
      "content": "# 2.3.6 实战练习：为你的项目做减法 ​\n\n现在，让我们把本节所学应用到你自己的项目上。\n\n按照以下步骤完成练习。如果你还没有具体项目，可以用「待办清单」或「习惯打卡」作为练习对象。\n\n## Step 1：明确你的核心假设 ​\n\n在做任何减法之前，先明确你在验证什么。\n\n### 核心假设模板 ​\nmarkdown\n`## 我的核心假设\n\n我假设：\n[某类用户] 存在 [某个问题/需求]，\n他们愿意使用 [我的解决方案] 来 [完成某个任务]，\n因为它比现有方案 [更快/更简单/更便宜/更有效]。\n\n我的填写：\n[                                                    ]`\n### 验证标准模板 ​\nmarkdown\n```\n## 验证标准\n\n如果：\n- [      ] 个用户\n- 在 [      ] 天/周内\n- 完成了 [                    ]\n\n则说明假设成立，值得继续投入。\n\n我的填写：\n如果：\n- [      ] 个用户\n- 在 [      ] 天/周内\n- 完成了 [                    ]\n\n则说明假设成立。\n```\n\n## Step 2：列出所有想做的功能 ​\n不要自我审查，把你能想到的所有功能都列出来。\nmarkdown\n`## 功能清单（不设限）\n\n1. \n2. \n3. \n4. \n5. \n6. \n7. \n8. \n9. \n10. \n（继续添加...）`\n## Step 3：用三个问题筛选 ​\n对每个功能问三个问题：\n功能Q1：没有能用？Q2：验证假设？Q3：首次需要？优先级1.能/不能能/不能是/否P0/P1/P22.3.4.5....\n### 判断规则 ​\n\n- P0：Q1=不能 且 Q2=能 且 Q3=是\n- P1：Q1=能 但 Q2=能 或 Q3=是\n- P2：其他所有功能\n## Step 4：确认你的 P0 功能 ​\n\n从上面的筛选中，提取 P0 功能。\nmarkdown\n`## 我的 P0 功能（最多 3-5 个）\n\n1. ____________（理由：____________）\n2. ____________（理由：____________）\n3. ____________（理由：____________）`检查：如果 P0 超过 5 个，回到 Step 1 重新审视你的核心假设。假设越聚焦，P0 越少。\n\n## Step 5：写下你的「不做清单」 ​\nmarkdown\n`## 不做清单（V1 版本）\n\n### 不做的功能\n\n| 功能 | 不做的理由 | 何时重新考虑 |\n|-----|----------|-------------|\n| 1.  |          |             |\n| 2.  |          |             |\n| 3.  |          |             |\n\n### 不考虑的用户群\n\n| 用户群 | 不考虑的理由 |\n|-------|-------------|\n| 1.    |             |\n| 2.    |             |\n\n### 不追求的指标\n\n| 指标 | 不追求的理由 | 替代关注点 |\n|-----|-------------|----------|\n| 1.  |             |          |\n| 2.  |             |          |`\n## Step 6：用 AI 验证你的判断 ​\n把你的分析结果交给 AI，让它帮你检查是否遗漏或误判。\n\n### Prompt 模板 ​\nmarkdown\n`我正在为一个项目做减法练习，请帮我检查以下分析是否合理：\n\n## 项目描述\n[你的项目描述]\n\n## 核心假设\n[你的核心假设]\n\n## 我确定的 P0 功能\n1. [功能1]\n2. [功能2]\n3. [功能3]\n\n## 我决定不做的功能\n[列出不做清单中的功能]\n\n请帮我检查：\n1. P0 功能是否都是验证假设必须的？有没有遗漏？\n2. 不做清单中有没有应该做的功能被误判了？\n3. 有没有其他建议？`\n## 完成检查清单 ​\n在结束本节练习前，确认以下事项：\n\n- [ ] 我写下了明确的核心假设\n- [ ] 我定义了可衡量的验证标准\n- [ ] 我的 P0 功能不超过 5 个\n- [ ] 我有一份「不做清单」\n- [ ] 我用 AI 验证过我的判断\n## 练习示例：习惯打卡项目 ​\n\n以下是一个完整的填写示例，供参考：\n\n### 核心假设 ​\n\n`我假设：\n想养成习惯的人存在「记录太麻烦导致放弃」的问题，\n他们愿意使用一个「一键打卡」工具来记录习惯，\n因为它比其他打卡 App 更简单，更容易坚持。`\n### 验证标准 ​\n\n```\n如果：\n- 5 个朋友\n- 在 2 周内\n- 连续使用超过 10 天\n\n则说明假设成立。\n```\n\n### P0 功能 ​\n\n```\n1. 添加习惯（理由：没有习惯就无法打卡）\n2. 一键打卡（理由：核心价值，验证「简单」假设）\n3. 查看连续天数（理由：给用户成就感，鼓励坚持）\n```\n\n### 不做清单 ​\n功能不做的理由何时重新考虑提醒功能先验证「简单」是否有效用户反馈需要时统计图表连续天数已经够用用户需要更多数据时社交分享增长功能，不是验证功能核心功能稳定后多习惯管理先从一个习惯开始单习惯验证成功后自定义主题美化功能，不影响核心有时间且用户要求时\n## 本节要点 ​\n恭喜你完成了减法练习。\n\n现在你应该有：\n\n- 一个明确的核心假设\n- 一个可衡量的验证标准\n- 3-5 个 P0 功能\n- 一份「不做清单」\n这些就是你开始动手的基础。比起一开始就规划 14 个功能，你现在的方向清晰多了。\n\n接下来，让我们总结本节的核心要点。",
      "word_count": 2467,
      "estimated_time": 4
    },
    {
      "id": "lesson-039",
      "chapter_id": "chapter-02",
      "lesson_number": 17,
      "title": "2.3.7 本节核心要点",
      "content": "# 2.3.7 本节核心要点 ​\n\n## 三条核心原则 ​\n\n`✓ MVP 是实验，不是产品。它的目的是验证假设，而不是取悦用户。\n\n✓ 做减法比做加法更难，但更重要。功能多不等于价值高。\n\n✓ 「不做清单」和「要做清单」同样重要。明确边界才能聚焦核心。`\n## 本节思维模型回顾 ​\n概念核心要点应用场景MVP 重定义Minimum = 最小投入，Viable = 能验证假设任何需要决定「做什么」的时候三个灵魂问题能用吗？验证假设吗？首次需要吗？筛选功能优先级P0/P1/P2P0 ≤ 5 个，其他都可以暂缓确定 MVP 范围不做清单功能、用户群、指标三个维度明确边界、抵抗诱惑核心假设明确假设 + 验证标准判断功能是否该做\n## 可复用的模板清单 ​\n本节提供了以下可直接使用的模板：\n\n- 核心假设模板：明确你在验证什么\n- 验证标准模板：定义成功/失败的判断标准\n- 功能筛选表格：用三个问题快速分类\n- 不做清单模板：三个维度的完整格式\n- AI 辅助 Prompt：让 AI 帮你砍功能和验证判断\n## 常见错误 vs 正确做法 ​\n常见错误正确做法列了 14 个功能就开始做先明确核心假设，再确定 P0MVP = 功能最少MVP = 投入最小且能验证假设做完再给用户看尽早让用户参与验证竞品有什么我也做什么只做验证假设必须的功能不做清单放脑子里写下来，形成正式的决策记录\n## 检查清单 ​\n\n在开始动手开发之前，确认以下事项：\n\n- [ ] 我有明确的核心假设（一句话能说清楚）\n- [ ] 我有可衡量的验证标准（X 个用户在 Y 时间内做了 Z）\n- [ ] 我的 P0 功能不超过 5 个\n- [ ] 我写下了「不做清单」\n- [ ] 我知道这个 MVP 要验证什么，不验证什么\n## 承上启下 ​\n\n回顾一下我们在第二章学到的内容：\n\n- 2.1 思维升级：从「功能视角」转向「任务视角」，问「用户要完成什么任务」\n- 2.2 逆向思维：先想「什么会导致失败」，提前避坑\n- 2.3 减法思维：用最小投入验证核心假设，学会说「这个不做」\n这三个思维工具帮你解决了「做什么」和「不做什么」的问题。\n\n但还有一个问题：你真的了解你的用户吗？\n\n下一节，我们将学习「故事思维」——把用户当作故事的主角，深入理解他们的需求和场景。\n\n当你能像讲故事一样描述用户时，你写给 AI 的需求会清晰十倍。\n\n本节金句\n\n\"完美不是无以复加，而是无可删减。\" —— Antoine de Saint-Exupéry",
      "word_count": 1060,
      "estimated_time": 3
    },
    {
      "id": "lesson-040",
      "chapter_id": "chapter-02",
      "lesson_number": 18,
      "title": "2.4.2 产品即故事：用叙事结构思考需求",
      "content": "# 2.4.2 产品即故事：用叙事结构思考需求 ​\n\n## 一个常见的错误 ​\n\n还记得小李吗？他在学会了「任务视角」和「减法思维」后，再次打开 AI 工具，输入了这样的需求：\n\n\"做一个待办清单，核心功能是：添加任务、完成任务、查看任务。\"\n\n这比他最初列 14 个功能好多了。但结果呢？\n\nAI 给出的设计中规中矩：一个输入框、一个列表、一个勾选按钮。能用，但没有任何亮点。\n\n小李总觉得少了点什么，却说不清楚问题在哪。\n\n## 问题出在哪？ ​\n\n小李的需求描述虽然简洁，但缺少一样关键的东西：故事。\n\n他只告诉 AI「要做什么功能」，却没有告诉 AI「为谁做」「在什么场景下用」「用户真正想要的感受是什么」。\n\n没有故事的需求，就像没有灵魂的躯壳。\n\n## 故事的基本结构 ​\n\n从亚里士多德的《诗学》到好莱坞的剧本写作，所有好故事都遵循一个基本结构：\n\n`开端 → 冲突 → 解决 → 结局`\n- 开端：主角的日常生活，建立背景\n- 冲突：主角遇到了问题，打破平衡\n- 解决：主角找到方法，克服困难\n- 结局：问题解决，主角获得成长或满足这个结构之所以有效，是因为它符合人类理解世界的方式：我们通过「某人遇到问题并解决它」的叙事来理解事物。\n\n## 产品版本的故事结构 ​\n\n把这个结构应用到产品设计中，就变成了：\n故事阶段产品视角用户视角开端用户的现状我是谁，我的日常是什么样的冲突用户的痛点我遇到了什么问题，为什么难受解决用户发现并使用产品我发现了这个工具，它帮我解决了问题结局用户获得价值我的生活/工作变好了，我感到满足\n## 案例对比：功能视角 vs 故事视角 ​\n\n### 待办清单（贯穿案例） ​\n\n功能视角的描述：\n\n做一个待办清单，有添加、完成、查看功能。\n\n故事视角的描述：\n\n小李是一个互联网公司的运营，每天要处理 10 件以上的事情。他试过用便签纸，但经常丢；试过几个待办 App，录入比做事还累。他最大的焦虑是「怕漏掉重要的事」。\n\n他需要一个工具：打开就能记，记完就能忘，做完一件划掉一件，晚上看着清空的列表安心下班。\n\n感受到区别了吗？故事版本让你能「看到」这个用户，理解他的处境和期望。\n\n### 更多场景的故事化描述 ​\n场景功能视角故事视角读书笔记做一个读书笔记工具，能划线、能收集、能导出小王每天通勤时在手机上看书，看到好句子想划线保存。但现在的阅读 App 划完线就找不到了，想回顾时要翻半天。她希望有个地方能把所有书的划线自动收集起来，闲暇时翻翻就能重温。Excel 汇总写一个脚本，自动汇总 5 个 Excel 表格老张是财务主管，每周五要汇总 5 个部门的周报。每次都是同样的操作：打开 5 个文件，复制粘贴到汇总表，调整格式。这个流程要花 2 小时，而且容易出错。他希望点一下就能搞定，把时间花在分析数据上。吃药提醒做一个提醒 App，定时推送通知我 60 岁的妈妈有高血压，每天要吃 2 次药。她经常忘记吃没吃过，有时候会重复吃。她不太会用复杂的 App，密密麻麻的字看不清。她只需要一个东西：到点提醒，吃完点一下「吃了」，这样她和我都知道今天吃过了。\n## 为什么故事视角更有效 ​\n\n当你用故事描述需求时，会自然获得这些好处：\n好处说明约束更清晰「60 岁妈妈」自动排除了复杂功能，「每天 10 件事」暗示了简洁的重要性优先级更明确「怕漏掉重要的事」告诉你核心是「不遗漏」，不是「好看的界面」AI 理解更准确AI 能基于故事推断出你没明说的需求，比如「大字体」「少步骤」自己也更清楚写故事的过程会逼你想清楚「到底为谁做」\n## 练习：把你的想法变成故事 ​\n\n试着用这个结构，为你自己的想法写一个简短的故事：\nmarkdown\n`## 我的用户故事\n\n### 开端：用户的日常\n[描述用户是谁，他的日常是什么样的]\n\n### 冲突：用户的痛点\n[描述用户遇到了什么问题，为什么感到困扰]\n\n### 解决：用户发现产品\n[描述用户如何使用你的产品解决问题]\n\n### 结局：用户获得价值\n[描述问题解决后，用户的生活/工作有什么改变]`不需要很长，3-5 句话就够。关键是让你（和 AI）能「看到」这个用户。\n\n## 本节要点 ​\n\n故事不是可选的修饰，而是需求描述的核心：\n\n- 功能视角只告诉 AI「做什么」，故事视角还告诉 AI「为谁做」「为什么做」\n- 好故事遵循「开端→冲突→解决→结局」的结构\n- 写故事的过程会帮你自己想清楚需求\n接下来，我们深入故事的主角——用户。如何构建一个真正立体的用户形象？",
      "word_count": 1886,
      "estimated_time": 3
    },
    {
      "id": "lesson-041",
      "chapter_id": "chapter-02",
      "lesson_number": 19,
      "title": "2.4.3 三维用户画像：让用户从纸面上站起来",
      "content": "# 2.4.3 三维用户画像：让用户从纸面上站起来 ​\n\n## 一维画像的问题 ​\n\n很多人描述用户时，会写出这样的内容：\n\n用户画像：25-35 岁，职场人士，有待办管理需求。\n\n这是「一维画像」——只有人口统计学信息。\n\n问题在于：这种描述对设计几乎没有帮助。\n\n- 25 岁的实习生和 35 岁的总监，需求一样吗？\n- 「职场人士」能是程序员、销售、设计师、财务……他们的工作方式完全不同\n- 「有待办管理需求」说了等于没说，谁没有待办需求呢？\n一维画像太抽象，无法指导具体决策。\n\n## 三维构建法 ​\n\n要让用户从纸面上「站起来」，需要从三个维度构建画像：\n维度核心问题获取的信息第一维：表面属性用户是谁？年龄、职业、生活状态等基本信息第二维：行为习惯用户在做什么？实际的行为模式、使用的工具、遇到的问题第三维：深层动机用户为什么这样做？内心的恐惧、渴望、期待\n前两个维度告诉你「用户是谁」，第三个维度告诉你「用户为什么会用你的产品」。\n\n第三维才是设计的核心。\n\n## 详细解读三个维度 ​\n\n### 第一维：表面属性（Who） ​\n\n这是最容易获取的信息，也是最容易止步于此的地方。\n\n表面属性包括：\n\n- 人口统计：年龄、性别、职业、收入\n- 生活状态：单身/已婚、有无小孩、城市/乡村\n- 技术水平：数字原住民/数字移民、常用什么设备\n注意：表面属性的价值在于「筛选」，而不是「理解」。它帮你确定「我的用户大概是哪一类人」，但不能告诉你「他们真正需要什么」。\n\n### 第二维：行为习惯（What） ​\n\n这一维关注用户实际在做什么：\n\n- 日常行为：他每天怎么安排工作？用什么工具？\n- 当前解决方案：他现在怎么解决这个问题？用便签纸？备忘录？Excel？\n- 失败经历：他试过哪些方法？为什么放弃了？\n关键问题：「他现在是怎么做的？」\n\n这个问题的答案会告诉你很多：\n\n- 如果他用便签纸，说明他需要的是「快速记录」，不是「复杂管理」\n- 如果他试过 3 个 App 都放弃了，说明「简单」是第一优先级\n- 如果他用 Excel 管理待办，说明他可能需要更多的结构化功能\n### 第三维：深层动机（Why） ​\n\n这是最难挖掘、也最有价值的信息。\n\n深层动机包括：\n\n- 恐惧：他害怕什么？（怕遗漏、怕出错、怕被批评）\n- 渴望：他想要什么感受？（掌控感、安心感、成就感）\n- 期待：他希望别人怎么看他？（专业、靠谱、高效）\n挖掘技巧：连问 5 次「为什么」\n层次问题回答示例表面你为什么需要待办清单？事情太多记不住第 2 层为什么记不住会有问题？会遗漏重要的事第 3 层遗漏重要的事会怎样？可能会被领导批评第 4 层被领导批评意味着什么？显得我不专业、不靠谱深层你最担心的是什么？我害怕在同事眼里是个不靠谱的人\n看到了吗？从「记不住事情」到「害怕被认为不靠谱」，这才是用户真正的动机。\n\n理解了这一层，你就知道：产品不只要帮他「记住事情」，还要让他「感到安心」。一个「全部完成」的庆祝动画，可能比多一个分类功能更有价值。\n\n## 三维画像模板 ​\n\n用这个模板为你的用户画像：\nmarkdown\n`## 用户画像：[给用户起个名字]\n\n### 第一维：表面属性\n- 基本信息：[年龄、职业、生活状态]\n- 技术水平：[对数字产品的熟悉程度]\n- 一句话描述：[用一句话概括这个人]\n\n### 第二维：行为习惯\n- 典型场景：[什么时候、在哪里、做什么]\n- 当前方案：[他现在用什么方法解决问题]\n- 失败经历：[他试过什么方法，为什么没用]\n\n### 第三维：深层动机\n- 表面需求：[他说他需要什么]\n- 真实恐惧：[他害怕什么]\n- 深层渴望：[他真正想要什么感受]`\n## 多场景案例 ​\n\n### 案例一：待办清单的用户 ​\nmarkdown\n```\n## 用户画像：小李\n\n### 第一维：表面属性\n- 基本信息：28 岁，互联网公司运营，工作 3 年\n- 技术水平：重度手机用户，会用各种 App\n- 一句话描述：一个被琐事淹没的年轻职场人\n\n### 第二维：行为习惯\n- 典型场景：早上到公司，打开电脑，开始处理各种事情\n- 当前方案：用便签纸记，有时用手机备忘录\n- 失败经历：试过 Todoist、滴答清单，太复杂，录入任务比做任务还累\n\n### 第三维：深层动机\n- 表面需求：记住每天要做的事\n- 真实恐惧：怕遗漏重要事项，被领导批评\n- 深层渴望：下班时看着清空的列表，感到「今天我搞定了一切」\n```\n\n### 案例二：数据分析报告的「老板」 ​\nmarkdown\n```\n## 用户画像：王总\n\n### 第一维：表面属性\n- 基本信息：45 岁，部门总监，管理 20 人团队\n- 技术水平：会用 Excel 基础功能，不会写公式\n- 一句话描述：一个没时间看细节、只想要答案的决策者\n\n### 第二维：行为习惯\n- 典型场景：每周一早上 30 分钟看各种报表\n- 当前方案：下属发 Excel 或 PPT，他快速翻阅\n- 失败经历：收到过 50 页的分析报告，翻了两页就放下了\n\n### 第三维：深层动机\n- 表面需求：了解业务数据\n- 真实恐惧：做出错误决策，让团队白忙活\n- 深层渴望：看一眼就知道「该关注什么」「该做什么」\n```\n\n### 案例三：吃药提醒的父母 ​\nmarkdown\n```\n## 用户画像：妈妈\n\n### 第一维：表面属性\n- 基本信息：62 岁，退休教师，独居\n- 技术水平：能发微信、看短视频，其他 App 用得少\n- 一句话描述：一个希望自己能照顾好自己、不给儿女添麻烦的老人\n\n### 第二维：行为习惯\n- 典型场景：早饭后、晚饭后需要吃药\n- 当前方案：靠记忆，有时设手机闹钟\n- 失败经历：用过儿子装的健康 App，界面太复杂，不敢乱点\n\n### 第三维：深层动机\n- 表面需求：按时吃药\n- 真实恐惧：忘吃药病情加重、给儿女添负担\n- 深层渴望：证明自己还能照顾好自己，让儿女放心\n```\n\n## 常见错误 ​\n\n### 错误一：把自己当用户 ​\n这是最常见的陷阱。\n\n你觉得「这个功能很有用」，但你不是目标用户。60 岁的妈妈不需要「数据统计」功能，即使你觉得这个功能「应该有」。\n\n解决方法：写画像时，问自己「这是用户想要的，还是我想要的？」\n\n### 错误二：画像太泛 ​\n\n「年轻人」「职场人士」「需要管理时间的人」——这些描述等于没说。\n\n解决方法：画像要具体到「你能想象出这个人长什么样」的程度。给他起个名字，描述他的一天。\n\n### 错误三：只有表面属性，没有深层动机 ​\n\n知道用户是「28 岁的运营」没有用，知道他「害怕被认为不靠谱」才有用。\n\n解决方法：对每个需求连问 5 次「为什么」，直到挖到情感层面。\n\n## 本节要点 ​\n\n三维用户画像让你从「了解用户」到「理解用户」：\n\n- 一维画像只有数据，三维画像有血有肉\n- 第三维（深层动机）是设计决策的核心\n- 连问 5 次「为什么」，挖掘用户真正的恐惧和渴望\n接下来，我们把这个立体的用户放进一个完整的旅程中——用户旅程地图。",
      "word_count": 2949,
      "estimated_time": 5
    },
    {
      "id": "lesson-042",
      "chapter_id": "chapter-02",
      "lesson_number": 20,
      "title": "2.4.4 用户旅程地图：把故事可视化",
      "content": "# 2.4.4 用户旅程地图：把故事可视化 ​\n\n## 什么是用户旅程地图 ​\n\n用户旅程地图是一个可视化工具，它把用户与产品互动的完整过程画出来。\n\n你可以把它理解为「用户故事的分镜脚本」——不只是讲发生了什么，还要画出每一步用户的行为、想法和情绪。\n\n为什么需要把故事「画出来」？\n\n- 文字描述容易遗漏细节，图表更全面\n- 情绪变化一目了然，能快速定位问题\n- 方便与他人（或 AI）沟通，减少误解\n## 旅程地图的五个维度 ​\n\n一份完整的用户旅程地图包含五个维度：\n维度记录的内容回答的问题阶段用户与产品互动的主要阶段用户的旅程分几步？行为用户在每个阶段做了什么用户具体做了什么操作？想法用户在每个阶段想什么用户脑子里在想什么？情绪用户在每个阶段的情绪用户感到开心、困惑还是沮丧？痛点/机会问题和改进空间哪里可以做得更好？\n## 案例：待办清单的用户旅程 ​\n\n让我们为小李画一份完整的用户旅程地图：\n\n### 旅程地图表格 ​\n阶段用户行为用户想法情绪痛点/机会发现在应用商店搜索「待办」\"又一个待办 App？希望别太复杂\"😐 怀疑第一印象很重要，简洁的介绍文案下载安装下载、打开 App\"看看长什么样\"😐 中性加载速度要快，别让用户等首次使用添加第一个任务\"就这？挺简单的\"😊 惊喜零门槛添加任务，创造正面印象完成任务点击完成，任务划掉\"有点爽\"😄 满足完成时的反馈要有成就感日常使用每天早上列待办，做完划掉\"脑子轻松多了\"😌 安心形成习惯，成为日常的一部分遇到边界想要某个没有的功能\"要是能有 XX 就好了\"😕 轻微失望记录需求，判断是否真的需要长期使用已经用了几个月\"没有它我会焦虑\"😊 依赖这是成功的标志推荐他人向朋友安利\"你也试试，特别简单\"😄 分享欲口碑传播的机会\n### 情绪曲线 ​\n\n把情绪变化连成线，就形成了「情绪曲线」：\n\n`高 😄 ─────────────────────────────────────────────\n      │                   ╱─╲              ╱─────\n      │                  ╱   ╲            ╱\n      │                 ╱     ╲          ╱\n中 😐 │────╲           ╱       ╲        ╱\n      │     ╲         ╱         ╲      ╱\n      │      ╲       ╱           ╲    ╱\n      │       ╲─────╱             ╲──╱\n低 😞 ─────────────────────────────────────────────\n      发现   下载   首次   完成   日常   遇到边界   长期   推荐`从这个曲线可以看出：\n\n- 情绪最低点：发现阶段（怀疑）和遇到边界时（失望）\n- 情绪最高点：首次使用和完成任务时（惊喜和满足）\n这些情绪波动告诉你：\n\n- 在「发现」阶段要做好第一印象\n- 「首次使用」的体验要尽可能简单\n- 「完成任务」时要给足正反馈\n## 简化版：适合个人项目 ​\n\n上面的旅程地图很完整，但做个人项目时不需要这么复杂。\n\n一个简化版的旅程地图只需要关注四个关键阶段：\n阶段你需要回答的问题发现用户怎么知道这个工具的？他的第一反应是什么？首次使用用户第一次用时会做什么？有没有门槛？核心流程用户最常重复做的事情是什么？体验流畅吗？长期价值用户为什么会持续使用？什么会让他推荐给别人？\n简化版模板：\nmarkdown\n`## 简化版用户旅程\n\n### 发现阶段\n- 用户如何发现这个工具：[来源]\n- 用户的第一反应：[想法]\n- 关键挑战：[如何让用户愿意尝试]\n\n### 首次使用\n- 用户第一步会做什么：[行为]\n- 可能遇到的困惑：[痛点]\n- 期望的感受：[情绪]\n\n### 核心流程\n- 用户最常做的操作：[行为]\n- 这个过程顺畅吗：[体验评估]\n- 如何让体验更好：[机会]\n\n### 长期价值\n- 用户为什么会持续使用：[价值]\n- 什么会让用户推荐给别人：[触发点]`\n## 非产品场景的旅程应用 ​\n旅程地图不只适用于做产品。任何需要理解「用户完整体验」的场景都可以用。\n\n### 场景一：数据分析——老板看报告的旅程 ​\n阶段老板的行为老板的想法痛点/机会收到报告看到邮件标题\"又一份报告……\"标题要直接说结论打开报告快速扫一眼\"多少页？关键是什么？\"第一页要有摘要找结论翻到关键图表\"所以呢？我该做什么？\"图表要有明确结论做决策根据数据决定下一步\"这个分析靠谱吗？\"数据要有来源和信心度\n洞察：老板没有时间看过程，只想要答案。报告的结构应该是「结论→证据→细节」，而不是「背景→分析→结论」。\n\n### 场景二：自动化脚本——使用前后的对比 ​\n阶段使用脚本前使用脚本后触发周五下午，该汇总数据了周五下午，运行脚本执行打开 5 个 Excel，复制粘贴 2 小时等待 30 秒检查检查有没有漏数据、格式对不对快速浏览结果结束身心疲惫，终于搞完了轻松完成，开始周末情绪😩 疲惫、怕出错😌 轻松、有成就感\n洞察：自动化脚本的价值不只是「省时间」，还有「省心力」和「减少出错焦虑」。\n\n## 关键洞察：痛点最高处就是最大机会 ​\n\n从旅程地图中找到的最有价值的信息是：情绪最低的地方。\n\n那通常就是你最应该解决的问题。\n场景情绪最低点机会待办清单发现阶段的怀疑用极简设计打消疑虑数据报告老板找不到结论第一页就给答案自动化脚本手动执行时的疲惫让脚本一键运行吃药提醒记不清吃没吃过明确显示今天的状态\n## 本节要点 ​\n\n用户旅程地图帮你把故事变成可操作的分析工具：\n\n- 旅程地图有五个维度：阶段、行为、想法、情绪、痛点\n- 情绪曲线让你一眼看出问题在哪\n- 个人项目可以用简化版：发现→首次使用→核心流程→长期价值\n- 情绪最低的地方就是最大的机会\n现在，你已经掌握了故事思维的核心工具。接下来，我们看看如何把这些运用到 Prompt 写作中，让 AI 给出更精准的输出。",
      "word_count": 2579,
      "estimated_time": 5
    },
    {
      "id": "lesson-043",
      "chapter_id": "chapter-02",
      "lesson_number": 21,
      "title": "2.4.5 用故事思维写 Prompt：让 AI 真正理解你",
      "content": "# 2.4.5 用故事思维写 Prompt：让 AI 真正理解你 ​\n\n## 同样的需求，不同的结果 ​\n\n来看两个 Prompt 的对比：\n\n### 无故事版本 ​\n\n`帮我做一个待办清单工具，需要这些功能：\n1. 添加任务\n2. 完成任务\n3. 查看任务列表`\n### 有故事版本 ​\n\n```\n我想做一个待办清单工具，先介绍一下背景：\n\n我是一个互联网公司的运营，每天大概有 10 件以上的事要处理——工作任务、要回的消息、要买的东西、要处理的杂事。\n\n我试过用便签纸，但经常丢；试过几个待办 App，但都太复杂了，光是录入任务就累得不想用。我的核心痛点是：怕忘事，脑子里总装着「还有什么没做完」的焦虑。\n\n我希望有一个工具能：\n- 打开就能添加，不用选分类、填日期、设优先级\n- 一眼看到今天要做什么\n- 做完一件就划掉，获得那种「搞定」的爽感\n\n请帮我设计这个工具的界面和核心功能。\n```\n第二个 Prompt 比第一个长很多，但 AI 的输出会有本质区别。\n\n## 区别在哪里 ​\n方面无故事版本有故事版本AI 知道用户是谁❌ 不知道✅ 忙碌的职场人AI 知道使用场景❌ 不知道✅ 每天处理 10+ 事项AI 知道约束条件❌ 不知道✅ 用过复杂 App，需要极简AI 知道核心痛点❌ 不知道✅ 怕忘事、怕焦虑AI 能推断优先级❌ 只能猜✅ 简单 > 功能多\n有了故事背景，AI 可以做出更合理的设计决策：\n\n- 界面会更简洁，而不是堆满功能\n- 添加任务会设计成一步完成，而不是多个表单\n- 完成任务时会加入满足感的反馈\n## 故事化 Prompt 的四个要素 ​\n\n一个好的故事化 Prompt 应该包含四个要素：\n要素回答的问题作用身份我是谁？让 AI 理解用户特征现状我现在怎么做？遇到什么问题？让 AI 理解背景和约束痛点我最困扰的是什么？让 AI 明确核心问题期望我希望达到什么效果？让 AI 知道成功标准\n## 通用故事化 Prompt 模板 ​\n\n可以直接复制使用的模板：\nmarkdown\n`我想做 [项目类型]，先介绍一下背景：\n\n## 我是谁\n[描述用户身份、基本情况]\n\n## 我的现状\n[描述现在是怎么做的、用什么工具、有什么问题]\n\n## 我的痛点\n[描述最困扰的问题、为什么困扰]\n\n## 我的期望\n[描述希望达到的效果，包括功能和感受]\n\n请帮我 [具体请求：设计/实现/分析]。`\n## 多场景 Prompt 示例 ​\n\n### 场景一：做产品 ​\nmarkdown\n```\n我想做一个习惯打卡工具，先介绍一下背景：\n\n## 我是谁\n我是一个想养成早起习惯的上班族，之前坚持过很多次都失败了。\n\n## 我的现状\n- 用过几个习惯 App，界面花哨、功能太多\n- 每天要点好几下才能完成打卡，烦得不想用\n- 最终都是用了几天就放弃了\n\n## 我的痛点\n打卡太麻烦，让我觉得「打卡」本身成了负担，而不是帮助。\n\n## 我的期望\n- 打开就能打卡，最好就一个按钮\n- 能看到连续打卡天数，给我坚持的动力\n- 界面极简，没有多余的东西分散注意力\n\n请帮我设计这个工具的界面和交互流程。\n```\n\n### 场景二：数据分析 ​\nmarkdown\n```\n我需要做一份销售数据分析，先介绍一下背景：\n\n## 我是谁\n我是一个电商公司的运营，需要向老板汇报 Q3 的销售情况。\n\n## 我的现状\n- 手里有三个月的订单数据（Excel 格式）\n- 老板每周一早上只有 15 分钟看报告\n- 上次做的报告太长，老板看了两页就放下了\n\n## 我的痛点\n不知道老板最关心什么，报告总是抓不住重点。\n\n## 我的期望\n- 一份老板能在 5 分钟内看完的报告\n- 第一页就能看到最重要的结论\n- 有明确的行动建议，不只是数据展示\n\n请帮我规划这份报告的结构和核心图表。\n```\n\n### 场景三：自动化脚本 ​\nmarkdown\n```\n我想写一个自动化脚本，先介绍一下背景：\n\n## 我是谁\n我是公司的财务，每周五要汇总 5 个部门的周报。\n\n## 我的现状\n- 每周五下午花 2 小时做这个事情\n- 流程是：打开 5 个 Excel → 复制数据 → 粘贴到汇总表 → 调整格式\n- 有时候会漏数据或者格式出错，要反复检查\n\n## 我的痛点\n这个工作重复又无聊，但不能出错，所以特别累心。\n\n## 我的期望\n- 点一下就能自动汇总\n- 输出的格式和我手动做的一样\n- 我只需要快速检查一下结果就行\n\n请帮我设计这个脚本的逻辑，用 Python 实现。\n```\n\n### 场景四：给家人做工具 ​\nmarkdown\n```\n我想给我 60 岁的妈妈做一个吃药提醒，先介绍一下背景：\n\n## 我是谁（用户是我妈妈）\n- 62 岁，退休教师，独居\n- 有高血压，每天早晚各吃一次药\n- 会用微信、看短视频，其他 App 用得少\n\n## 她的现状\n- 靠记忆吃药，经常忘记自己吃过没有\n- 有时候重复吃，有时候忘吃\n- 不愿意麻烦我，但我其实很担心\n\n## 她的痛点\n记性不好，但又不想承认自己记性不好。\n\n## 她的期望\n- 字要大，她眼神不太好\n- 操作要少，最好就一个按钮\n- 能让我远程看到她今天吃药没有\n\n请帮我设计一个她能用的吃药提醒页面。\n```\n\n## AI 输出对比 ​\n以待办清单为例，看看两种 Prompt 的 AI 输出差异：\n\n### 无故事版本的典型输出 ​\n\n`这是一个基础的待办清单设计：\n\n1. 顶部有一个输入框，用于添加任务\n2. 下方是任务列表，每个任务有：\n   - 复选框（标记完成）\n   - 任务文本\n   - 删除按钮\n3. 可以考虑添加以下功能：\n   - 任务分类\n   - 截止日期\n   - 优先级标签\n   ...`\n### 有故事版本的典型输出 ​\n\n```\n基于你的需求，我建议一个极简设计：\n\n界面只有两个元素：\n1. 一个大输入框，点击就能开始输入，回车直接添加\n2. 任务列表，点击任务就标记完成（有划线动画和轻微震动反馈）\n\n设计原则：\n- 没有分类、日期、优先级——减少录入负担\n- 完成动画要有满足感——一个简单的「√」动画\n- 整体色调简洁，不花哨\n\n特别说明：\n- 考虑到你说「录入比做事还累」，所以删掉了所有非必要字段\n- 考虑到你说「搞定的爽感」，完成时会有小动画\n...\n```\n区别很明显：有故事的版本给出了更贴合需求的设计，而且能解释「为什么这样设计」。\n\n## 本节要点 ​\n\n故事化 Prompt 不是为了「写得长」，而是为了「让 AI 真正理解你」：\n\n- 四个要素：身份、现状、痛点、期望\n- 好的 Prompt 让 AI 能做出推断，而不只是执行指令\n- 模板可以直接复制使用，根据场景填充内容\n接下来，我们通过实战练习，把故事思维应用到你自己的项目中。",
      "word_count": 2835,
      "estimated_time": 5
    },
    {
      "id": "lesson-044",
      "chapter_id": "chapter-02",
      "lesson_number": 22,
      "title": "2.4.6 实战练习：为你的项目应用故事思维",
      "content": "# 2.4.6 实战练习：为你的项目应用故事思维 ​\n\n现在，让我们把本节学到的故事思维工具应用到你自己的项目中。\n\n准备好你想做的那个项目想法，跟着下面的练习一步步完成。\n\n## 练习一：写一个用户故事 ​\n\n用「开端→冲突→解决→结局」的结构，为你的项目写一个用户故事。\n\n### 模板 ​\nmarkdown\n`## 用户故事：[给你的用户起个名字]\n\n### 开端：用户的日常\n[描述用户是谁，他的日常生活/工作是什么样的]\n（1-2 句话）\n\n### 冲突：用户的困境\n[描述用户遇到了什么问题，为什么这让他困扰]\n（2-3 句话）\n\n### 解决：用户发现你的产品\n[描述用户如何使用你的产品，解决了什么问题]\n（1-2 句话）\n\n### 结局：用户获得的价值\n[描述问题解决后，用户的生活/工作有什么改变，他有什么感受]\n（1-2 句话）`\n### 示例 ​\nmarkdown\n```\n## 用户故事：小王\n\n### 开端：用户的日常\n小王是一个喜欢读书的产品经理，每天通勤时会在手机上看电子书。\n\n### 冲突：用户的困境\n他看书时经常划线标记好句子，但这些划线散落在不同的书里。\n想回顾时要一本本翻，很麻烦，慢慢就不划了。\n他觉得很多好内容「看过就忘」，很可惜。\n\n### 解决：用户发现你的产品\n他发现了一个工具，能自动收集所有书的划线，按书籍整理好。\n\n### 结局：用户获得的价值\n现在他通勤时经常翻翻之前的划线，觉得「读过的书真正变成了自己的」。\n```\n\n## 练习二：画一个三维用户画像 ​\n用三维构建法，为你的目标用户画一个立体的画像。\n\n### 模板 ​\nmarkdown\n`## 用户画像：[名字]\n\n### 第一维：表面属性\n- 年龄/职业/生活状态：\n- 技术熟练度：\n- 一句话描述这个人：\n\n### 第二维：行为习惯\n- 典型使用场景（时间、地点、状态）：\n- 现在怎么解决这个问题：\n- 试过什么方法，为什么没用：\n\n### 第三维：深层动机\n- 表面上他说需要什么：\n- 实际上他害怕什么：\n- 真正渴望什么感受：`\n### 小技巧：连问 5 次「为什么」 ​\n填写第三维时，对你写的每个答案问「为什么」：\n问题我的回答用户需要什么？[你的回答]为什么需要这个？[继续追问]为什么这很重要？[继续追问]如果没有会怎样？[继续追问]他最担心的是什么？[这通常就是深层动机]\n## 练习三：画一个简化版用户旅程 ​\n\n为你的用户画一个简化版的旅程地图，关注四个关键阶段。\n\n### 模板 ​\nmarkdown\n`## 简化版用户旅程\n\n### 阶段 1：发现\n- 用户如何知道这个产品/工具：\n- 用户的第一反应：\n- 这个阶段的关键挑战：\n\n### 阶段 2：首次使用\n- 用户第一步会做什么：\n- 可能遇到的困惑：\n- 期望给用户什么感受：\n\n### 阶段 3：核心流程（日常使用）\n- 用户最常重复的操作是什么：\n- 这个流程目前顺畅吗（1-5 分）：\n- 如何让这个流程更好：\n\n### 阶段 4：长期价值\n- 用户为什么会持续使用：\n- 什么会让用户推荐给别人：`\n## 自检清单 ​\n完成上面的练习后，用这个清单检查你的故事是否足够立体：\n\n### 故事完整性检查 ​\n\n- [ ] 我能清楚说出用户是谁（有名字、有形象）\n- [ ] 我能描述用户的日常（典型的一天/一周）\n- [ ] 我能说出用户现在用什么方法解决问题\n- [ ] 我知道用户为什么对现有方法不满意\n- [ ] 我理解用户的深层动机（恐惧/渴望/期待）\n### 设计指导性检查 ​\n\n- [ ] 基于这个故事，我能判断「这个功能该不该做」\n- [ ] 基于这个故事，我能判断「哪个功能更重要」\n- [ ] 这个故事能帮助 AI 理解我的需求\n- [ ] 读这个故事，别人也能「看到」这个用户\n### 常见问题排查 ​\n问题症状解决方法用户太抽象\"年轻人\"\"职场人士\"具体到一个人，给他起个名字只有表面属性只写了年龄职业补充行为习惯和深层动机痛点不够深\"想要更方便\"连问 5 次「为什么」故事是自己的把自己当用户问「真正的用户会这样想吗」\n## 进阶：把练习成果变成 Prompt ​\n\n完成练习后，你可以用这个模板把成果整合成一个故事化 Prompt：\nmarkdown\n`我想做 [你的项目]，先介绍一下背景：\n\n## 我是谁\n[从练习二的第一维提取]\n\n## 我的现状\n[从练习二的第二维提取]\n\n## 我的痛点\n[从练习二的第三维提取]\n\n## 我的期望\n[从练习一的「结局」提取]\n\n## 用户旅程\n[从练习三提取，可以简化为几个关键点]\n\n请帮我 [设计/实现/规划] 这个项目。`\n## 本节要点 ​\n三个练习帮你把故事思维落地到自己的项目：\n\n- 用户故事：用四幕结构描述用户从困境到解决的过程\n- 三维画像：从表面属性、行为习惯、深层动机三个维度理解用户\n- 用户旅程：关注发现、首次使用、核心流程、长期价值四个阶段\n完成这些练习后，你就拥有了一份可以直接用于 Prompt 写作的「用户故事素材库」。",
      "word_count": 2121,
      "estimated_time": 4
    },
    {
      "id": "lesson-045",
      "chapter_id": "chapter-02",
      "lesson_number": 23,
      "title": "2.4.7 本节核心要点",
      "content": "# 2.4.7 本节核心要点 ​\n\n## 核心收获 ​\n\n经过本节学习，你已经掌握了故事思维的核心工具：\n\n✓ 故事结构：用「开端→冲突→解决→结局」的结构描述需求，让 AI 真正理解你想做什么\n\n✓ 三维画像：从表面属性、行为习惯、深层动机三个维度构建用户形象，特别是挖掘用户内心的恐惧和渴望\n\n✓ 用户旅程：把用户与产品的互动过程可视化，在情绪最低处找到最大的机会\n\n## 故事思维速查表 ​\n工具用途核心问题故事结构描述需求用户经历了什么？三维画像理解用户用户是谁？他真正想要什么？用户旅程发现问题用户在哪里最困扰？故事化 Prompt与 AI 沟通如何让 AI 理解背景？\n## 一句话总结 ​\n\n故事思维的本质是：把抽象的「用户」变成有血有肉的「人」。\n\n当你能「看到」这个人、理解他的处境、感受他的焦虑和渴望，你就能做出真正解决问题的产品。\n\n## 下节预告 ​\n\n现在，你已经掌握了四个思维工具：\n\n- 任务思维：知道用户要完成什么任务\n- 逆向思维：知道什么会导致失败\n- 减法思维：知道什么功能可以不做\n- 故事思维：知道用户是谁、经历了什么\n在下一节，我们将用三个灵魂问题把这些工具串联起来。\n\n这三个问题是：\n\n- 用户是谁？\n- 痛点在哪？\n- 为什么选你？\n在动手之前回答好这三个问题，能帮你避免大多数失败项目的命运。",
      "word_count": 572,
      "estimated_time": 3
    },
    {
      "id": "lesson-046",
      "chapter_id": "chapter-02",
      "lesson_number": 24,
      "title": "2.5.2 问题一：用户是谁？",
      "content": "# 2.5.2 问题一：用户是谁？ ​\n\n这个问题看起来很简单，但大多数人的回答都不及格。\n\n## 模糊回答 vs 具体回答 ​\n❌ 模糊（不及格）✅ 具体（及格）想学英语的人28岁外企员工，英语中等，想提升口语用于工作会议喜欢记账的人刚毕业的年轻人，月薪8k-15k，想知道钱花哪了需要专注的人在家办公的自由职业者，容易被短视频分散注意力老年人62岁的妈妈，会用微信发语音，其他App用得少\n## 为什么要这么具体 ​\n\n三个原因：\n\n1. 你无法为\"所有人\"设计\n\n\"想学英语的人\"可以是8岁小学生、28岁白领、58岁退休教师。他们的需求完全不同。试图满足所有人，结果是谁都不满意。\n\n2. 具体的用户画像能指导设计决策\n\n当你面临\"要不要加这个功能\"的选择时，问自己：\"小王（你的具体用户）需要这个吗？\"答案会清晰很多。\n\n3. AI 也需要具体的用户信息\n\n当你告诉 AI \"帮我做一个英语学习App\"，AI 会做一个泛泛的产品。当你告诉 AI \"帮我做一个给外企员工用的英语口语练习工具，主要场景是准备工作会议\"，AI 的产出会精准得多。\n\n## 不同场景下\"用户\"的变体 ​\n\n\"用户是谁\"这个问题，在不同场景下有不同的含义：\n场景\"用户\"指的是谁举例做产品/工具使用这个产品的人用待办清单App的职场人做数据分析看这份分析报告的人需要决策的部门总监写自动化脚本受益于这个脚本的人每周被Excel汇总折磨的自己给家人做工具实际使用的家人62岁需要吃药提醒的妈妈\n注意：用户可以是别人，也可以是自己。\n\n## 当用户是自己时怎么回答 ​\n\n很多人做个人工具时会说：\"用户就是我自己啊，还需要回答吗？\"\n\n需要。而且要更具体。\n\n不是\"我自己\"，而是\"在什么情境下的我自己\"：\n❌ 模糊✅ 具体我自己每周五下午需要汇总5个部门Excel的我我自己早上通勤时想听英语但找不到合适内容的我我自己月底看账单一脸懵、不知道钱花哪了的我\n这种具体描述能帮你聚焦到真正的使用场景，避免做出一个\"理论上有用、实际上不用\"的东西。\n\n## 检验方法：微信测试法 ​\n\n问自己两个问题：\n\n1. 你能给这个用户起个名字吗？\n\n- 能（\"小王，28岁产品经理\"）→ 说明足够具体\n- 不能（\"想学英语的人\"）→ 说明太模糊\n2. 如果要给这个用户发一条微信，你会怎么称呼TA？\n\n- 能具体称呼（\"王哥\"、\"妈\"、\"老板\"）→ 说明你心里有一个真实的人\n- 只能泛泛称呼（\"亲爱的用户\"）→ 说明你还没想清楚\n## 常见误区 ​\n\n### 误区一：把用户群体当用户个体 ​\n\n\"年轻人\"不是用户，\"25岁在上海工作的产品经理小王\"才是用户。\n\n群体是统计概念，个体才能指导设计。\n\n### 误区二：描述人口属性而非使用场景 ​\n\n\"28岁女性\"不如\"每天通勤1小时、想利用这段时间学点东西的上班族\"有用。\n\n年龄性别只是标签，使用场景才能指导功能。\n\n### 误区三：用户≠付费者 ​\n\n做给老板看的数据报告，用户是老板，不是你自己。做给妈妈用的吃药提醒，用户是妈妈，不是你。\n\n搞清楚谁真正在用，才能做出他们真正需要的东西。\n\n## 快速自检 ​\n\n在进入下一个问题之前，确认你能完成这个填空：\n\n`我的用户是 [一个具体的人/角色描述]，\nTA 在 [什么场景/情境] 下会用到我做的东西。`如果填不出来，回到 2.4 节的三维用户画像工具，做一个更系统的分析。",
      "word_count": 1427,
      "estimated_time": 3
    },
    {
      "id": "lesson-047",
      "chapter_id": "chapter-02",
      "lesson_number": 25,
      "title": "2.5.3 问题二：痛点在哪？",
      "content": "# 2.5.3 问题二：痛点在哪？ ​\n\n知道了用户是谁，接下来要问：这个用户正在被什么问题困扰？\n\n## 假痛点 vs 真痛点 ​\n假痛点（表面需求）真痛点（深层问题）\"我想学英语\"\"开会听不懂老外说什么，很尴尬\"\"我想记账\"\"月底钱花光了，不知道花哪了，很焦虑\"\"我想提高效率\"\"明明可以2小时完成的工作，我拖了一整天\"\"我想让数据更清晰\"\"老板问我Q3销售怎么样，我支支吾吾说不清楚\"\n假痛点是用户\"说\"的，真痛点是用户\"感受到\"的。\n\n## 识别真痛点的三个特征 ​\n\n一个痛点是不是真的，看这三点：\n特征说明检验问题有情绪真痛点会引发负面情绪：焦虑、尴尬、沮丧、愤怒描述这个问题时，用户会不会皱眉头？正在发生不是\"将来可能会痛\"，而是\"现在就很痛\"用户这周遇到过这个问题吗？愿意付出用户愿意花时间、花钱、改变习惯来解决如果有解决方案，用户会立刻用吗？\n三个特征都满足，才是值得解决的真痛点。\n\n## 追问技巧：连续问5个\"为什么\" ​\n\n表面需求往往不是真痛点。要找到真痛点，需要连续追问\"为什么\"。\n\n示例：从\"我想学英语\"到真痛点\n层次问题回答表面你为什么想学英语？因为工作需要第2层工作为什么需要英语？要和外国客户交流第3层交流有什么问题？每次开会我都听不太懂第4层听不懂会怎样？错过重要信息，做错决策深层这为什么困扰你？老板开始质疑我的能力，我怕影响晋升\n真正的痛点不是\"想学英语\"，而是\"害怕因为英语不好而影响职业发展\"。\n\n理解了这一层，你做的英语学习工具就会聚焦\"工作场景的实用表达\"，而不是\"从ABC开始教\"。\n\n## 痛点强度评估 ​\n\n不是所有痛点都值得解决。可以用一个简单的矩阵来评估：\n评估维度低分（1-2）中分（3）高分（4-5）频率一年遇到一两次每月遇到几次每天/每周都遇到严重程度有点不方便挺烦的严重影响工作/生活\n频率 × 严重程度 = 痛点强度\n\n- 16-25分：非常值得解决\n- 9-15分：可以解决\n- 1-8分：可能不值得专门做一个工具\n示例评估：\n痛点频率严重程度总分每周汇总5个部门的Excel5（每周）4（很烦，浪费2小时）20分偶尔忘记重要会议2（偶尔）5（后果严重）10分手机照片太多找不到3（经常）2（不太影响）6分\n## 不同场景的痛点模式 ​\n\n不同类型的项目，痛点的表现形式不同：\n场景典型痛点模式举例做产品/工具用户在完成某任务时遇到的障碍\"记录待办太麻烦，所以总是忘\"数据分析决策者缺乏信息或信息不清晰\"不知道Q3业绩下滑的原因\"自动化脚本重复性劳动消耗时间和精力\"每周花2小时手动合并Excel\"给家人做现有工具不适合特定人群\"妈妈记不住吃药时间，现有App太复杂\"\n## 识别\"假痛点\"的三个信号 ​\n\n有些痛点看起来像真的，但其实不值得解决：\n\n信号1：用户说\"有空的话想...\"\n\n\"有空的话想学学英语\"——这不是痛点，这是愿望。真正的痛点是\"不得不\"，不是\"想要\"。\n\n信号2：用户已经有凑合能用的方案\n\n如果用户已经用便签纸管理待办，而且用得还行，说明痛点不够强烈。真正的痛点是\"现有方案完全不行\"。\n\n信号3：描述时没有具体场景\n\n\"我想提高效率\"——什么效率？在什么场景下？如果说不出具体场景，大概率是假痛点。\n\n## 快速检验：消失测试 ​\n\n问自己这个问题：\n\n\"如果这个问题明天就消失了，用户会有多高兴？\"\n\n- 会非常高兴、如释重负 → 真痛点\n- 会有点高兴 → 弱痛点\n- 无所谓 → 假痛点\n## 快速自检 ​\n\n在进入下一个问题之前，确认你能完成这个填空：\n\n`我的用户正在被 [具体的问题] 困扰，\n这个问题让TA感到 [具体的负面情绪]，\nTA [每天/每周/每月] 都会遇到这个问题。`如果填不出来，试着用\"5个为什么\"追问法，从表面需求挖到深层痛点。",
      "word_count": 1582,
      "estimated_time": 3
    },
    {
      "id": "lesson-048",
      "chapter_id": "chapter-02",
      "lesson_number": 26,
      "title": "2.5.4 问题三：为什么选你？",
      "content": "# 2.5.4 问题三：为什么选你？ ​\n\n这是三个问题中最难回答的一个。\n\n知道了用户是谁、痛点在哪，还要回答：凭什么用户要用你做的东西，而不是别的方案？\n\n## 这个问题为什么难 ​\n\n市场上可能已经有：\n\n- 100 个待办清单 App\n- 50 个习惯打卡工具\n- 20 个数据可视化软件\n- 无数个 Excel 模板\n用户为什么要用你做的，而不是这些已有的产品？\n\n如果回答不出来，说明你做的东西没有存在的理由。\n\n## 不同场景下\"为什么选你\"的含义 ​\n\n这个问题在不同场景下，问法略有不同：\n场景问题变体要回答的核心做产品为什么用户选你而非竞品？你的独特价值是什么做个人工具为什么自己做而非用现成的？现有工具哪里不满足你写自动化脚本为什么值得花时间做？投入产出是否划算给家人做为什么不直接用市面上的App？现有App对这个人不适用在哪\n## 差异化的四个来源 ​\n\n如果要为用户提供一个选择你的理由，可以从这四个方向找：\n差异化来源说明示例更聚焦只解决一个具体问题，不贪多只管\"今天要做什么\"，不做长期规划更简单砍掉80%功能，把20%做到极致只有添加、完成、查看，没有分类标签优先级更便宜免费或低成本提供类似价值免费、无广告、不需要注册新场景在别人没覆盖的场景下解决问题专为60岁以上老人设计，大字、大按钮、无干扰\n注意：差异化不是\"更多\"。\n\n\"我的App有更多功能\" ≠ 差异化\n\n\"我的App专门解决XX人的XX问题\" = 差异化\n\n## 做个人工具时的\"为什么选你\" ​\n\n当你给自己做工具时，\"为什么选你\"变成了\"为什么值得自己做\"。\n\n需要回答这个问题：现有工具哪里不行，以至于我必须自己做一个？\n现有方案问题在哪自己做的理由用手机备忘录记待办没有提醒，经常忘需要一个到点提醒的简单工具用现成的记账App分类太细，记起来太麻烦只需要一个\"今天花了多少\"的极简记录手动合并Excel每周花2小时，太浪费时间写个脚本一键完成，每周省2小时\n如果现有工具已经够用，就没必要自己做。承认这一点不丢人。\n\n## 投入产出计算 ​\n\n对于自动化脚本和个人工具，可以做一个简单的投入产出计算：\n\n`节省的时间 = 每次节省的分钟数 × 每月发生的次数 × 使用的月数\n开发成本 = 用 AI 做出来需要的小时数\n\n如果 节省的时间 > 开发成本 × 3，就值得做`示例：\n\n- 每周手动合并Excel需要2小时\n- 预计用1年，共52周\n- 节省时间 = 2小时 × 52 = 104小时\n- 用AI写脚本预计需要3小时\n- 104 > 3 × 3 = 9，值得做\n## 30秒电梯演讲模板 ​\n\n如果你能用30秒向别人解释清楚\"为什么选你\"，说明你想明白了。\n\n试着用这个模板：\n\n`对于 [目标用户]，\n他们在 [什么场景] 遇到 [什么问题]。\n\n现有的解决方案是 [竞品或现有方法]，\n但它的问题是 [为什么不够好]。\n\n我做的 [产品/工具] 不同，因为 [你的独特价值]。`示例：\n\n对于每周需要汇总多个部门数据的运营人员，他们在做周报时要花2小时手动复制粘贴Excel。现有的方法是一个个打开文件手动操作，但这太浪费时间而且容易出错。我写的这个脚本不同，因为它可以一键合并所有文件，5分钟完成原来2小时的工作。\n\n## 先调研再动手 ​\n\n在回答\"为什么选你\"之前，先做一个简单的调研：\n\n调研清单：\n\n- [ ] 搜索一下：有没有现成的工具/App 能解决这个问题？\n- [ ] 如果有，下载试用：它哪里好？哪里不行？\n- [ ] 问问周围的人：他们现在怎么解决这个问题？\n- [ ] 如果现有方案够用：是否真的需要自己做？\n很多时候，调研完你会发现：已经有很好的工具了，直接用就行。\n\n这不是失败，这是节省时间。\n\n## 快速自检 ​\n\n在进入下一节之前，确认你能完成这个填空：\n\n`用户应该选择我做的东西，而不是 [现有方案]，\n因为 [你的独特价值/差异点]。`如果填不出来，可能有两个情况：\n\n- 你还没调研现有方案是什么\n- 你做的东西确实没有独特价值，需要重新思考定位",
      "word_count": 1706,
      "estimated_time": 3
    },
    {
      "id": "lesson-049",
      "chapter_id": "chapter-02",
      "lesson_number": 27,
      "title": "2.5.5 灵魂三问自检清单",
      "content": "# 2.5.5 灵魂三问自检清单 ​\n\n在打开 AI 工具、写第一行 Prompt 之前，用这个清单做一次快速自检。\n\n## 红绿灯自检法 ​\n\n对每个问题做一个判断：\n状态含义下一步🟢 绿灯能用一句话清晰回答可以开始🟡 黄灯有想法但说不清楚需要再想想，或先做最小实验验证🔴 红灯完全回答不出来停下来，回到前面的章节做系统分析\n规则：三个问题都是绿灯，才能开始动手。\n\n## 自检模板 ​\n\n复制这个模板，填写你的答案：\nmarkdown\n`## 灵魂三问自检\n\n**项目名称**：____________________\n\n### 问题1：用户是谁？ [🟢/🟡/🔴]\n\n一句话描述：____________________\n\n用户的名字（虚构）：____________________\n\n检验：能给TA发微信吗？ □ 能 □ 不能\n\n### 问题2：痛点在哪？ [🟢/🟡/🔴]\n\n表面需求：____________________\n\n深层痛点（带情绪）：____________________\n\n痛点验证：\n- □ 有负面情绪（焦虑/烦躁/尴尬）\n- □ 正在发生（这周遇到过）\n- □ 愿意付出（会立刻用解决方案）\n\n痛点强度：频率（__）× 严重程度（__）= __分\n\n### 问题3：为什么选你？ [🟢/🟡/🔴]\n\n现有解决方案：____________________\n\n我的差异点：____________________\n\n一句话总结：用户应该选我，因为____________________\n\n### 自检结果\n\n- 问题1：[🟢/🟡/🔴]\n- 问题2：[🟢/🟡/🔴]\n- 问题3：[🟢/🟡/🔴]\n\n**是否可以开始**：□ 可以（全绿） □ 需要完善（有黄） □ 先停下来（有红）`\n## 每个问题的及格线 ​\n问题及格标准不及格信号用户是谁能给这个用户起名字、能描述TA的具体场景只能说\"年轻人\"\"上班族\"等模糊群体痛点在哪能说出用户的情绪、能说出发生频率只能说\"想要XX\"\"希望XX\"为什么选你能说出现有方案的不足、能说出自己的差异说不出竞品是什么，或只能说\"我更好\"\n## 快速版（3分钟完成） ​\n如果时间紧，至少回答这三个问题：\n\n- 谁会用这个？（一个具体的人）\n- TA现在有多痛？（1-10分）\n- 现在TA用什么方法？我的方法好在哪？\n能顺利回答，就可以开始。卡住了，就停下来想清楚。",
      "word_count": 1014,
      "estimated_time": 3
    },
    {
      "id": "lesson-050",
      "chapter_id": "chapter-02",
      "lesson_number": 28,
      "title": "2.5.6 实战案例：四种场景的灵魂三问",
      "content": "# 2.5.6 实战案例：四种场景的灵魂三问 ​\n\n灵魂三问不只是用来\"做产品\"的。下面用四个不同场景的案例，展示这套框架的实际应用。\n\n## 案例一：待办清单工具（产品场景） ​\n\n原始想法：\"我想做一个待办清单\"\n\n### 灵魂三问分析 ​\n问题分析过程最终答案用户是谁？\"想管理任务的人\"太宽泛 → 聚焦到\"事情多、怕忘事的职场人\" → 给个名字小李，28岁运营，每天有10+件事要处理痛点在哪？\"想管理任务\"是表面 → 追问为什么 → 发现是\"总担心忘了什么重要的事\"的焦虑害怕遗漏重要事项，想要\"一切尽在掌握\"的安心感为什么选你？调研发现现有App功能太多太复杂 → 差异点：极简到只有三个功能最简单的待办工具，打开就能用，3秒添加任务\n### 自检结果 ​\n\n- 用户是谁：🟢 具体到\"28岁运营小李\"\n- 痛点在哪：🟢 有情绪（焦虑）、高频（每天）\n- 为什么选你：🟢 有差异（极简 vs 复杂）\n结论：可以开始\n\n## 案例二：Q3销售分析报告（数据分析场景） ​\n\n原始想法：\"老板让我做一个Q3销售分析\"\n\n### 灵魂三问分析 ​\n问题分析过程最终答案用户是谁？不是\"公司\"，是\"看这个报告的人\" → 是销售总监王总王总，45岁销售总监，每周一早上有30分钟看报表痛点在哪？不是\"想看数据\"，是\"需要快速做出决策\" → 追问发现是\"怕做错决策、浪费资源\"担心看不清趋势、做出错误判断，需要\"一眼看出该关注什么\"为什么选你？这是内部任务，没有\"竞品\" → 问题变成\"为什么是这种呈现方式\"30分钟内能看完、能直接得出结论、不需要再追问细节\n### 自检结果 ​\n\n- 用户是谁：🟢 具体到\"王总，周一早上看报表\"\n- 痛点在哪：🟢 有情绪（担心决策错误）、有场景\n- 为什么选你：🟡 \"为什么这样呈现\"还需要细化\n结论：基本可以开始，呈现方式需要再想想\n\n### 延伸思考 ​\n\n数据分析场景的\"为什么选你\"，核心是呈现方式的选择：\n\n- 为什么用柱状图而不是表格？因为对比更直观\n- 为什么只放5个关键指标？因为王总只有30分钟\n- 为什么先放结论后放数据？因为决策者要先知道\"该怎么办\"\n## 案例三：Excel自动汇总脚本（自动化场景） ​\n\n原始想法：\"每周汇总Excel太烦了，想写个脚本\"\n\n### 灵魂三问分析 ​\n问题分析过程最终答案用户是谁？就是我自己 → 但要具体化每周五下午需要汇总5个部门Excel的我痛点在哪？\"太烦\"不够具体 → 追问发现是\"每周浪费2小时做重复劳动，还容易出错\"每周浪费2小时、容易复制粘贴出错、做完很烦躁为什么选你？问\"为什么值得自己做\" → 计算投入产出投入3小时开发，每周省2小时，3周回本，一年省100+小时\n### 自检结果 ​\n\n- 用户是谁：🟢 具体到\"周五下午汇总Excel的我\"\n- 痛点在哪：🟢 有频率（每周）、有时间成本（2小时）、有情绪（烦躁）\n- 为什么选你：🟢 投入产出算清楚了（3小时换100小时）\n结论：可以开始\n\n### 投入产出计算 ​\n项目数值每次手动操作时间2小时每年发生次数52次每年总耗时104小时预计开发时间3小时回本周期1.5周一年净节省101小时\n## 案例四：给妈妈做吃药提醒（给家人场景） ​\n\n原始想法：\"想给妈妈做一个吃药提醒的小工具\"\n\n### 灵魂三问分析 ​\n问题分析过程最终答案用户是谁？不是\"老年人\"，是\"我妈妈\" → 要具体描述她的情况62岁的妈妈，会发微信语音，其他App用得少，眼神不太好痛点在哪？\"忘吃药\"是表面 → 追问发现深层是\"怕给儿女添麻烦\"和\"担心身体出问题\"忘吃药会担心病情加重，但又不想总麻烦儿女提醒为什么选你？调研发现现有健康App界面太复杂 → 妈妈用不来专为妈妈设计：大字、大按钮、只有\"该吃药了\"一个提醒\n### 自检结果 ​\n\n- 用户是谁：🟢 具体到\"62岁的妈妈，会用微信，眼神不好\"\n- 痛点在哪：🟢 有情绪（担心）、有频率（每天要吃药）\n- 为什么选你：🟢 有差异（专为妈妈设计 vs 通用健康App）\n结论：可以开始\n\n### 设计启示 ​\n\n当用户是家人时，\"为什么选你\"的核心往往是适配性：\n\n- 现有App对这个人来说太复杂 → 你可以做一个极简版\n- 现有App没有考虑这个群体的特殊需求 → 你可以专门适配\n- 家人不好意思付费 → 你可以免费给TA用\n## 四个案例的对比 ​\n场景用户痛点特征\"为什么选你\"的核心产品某类人群中的具体个体功能+情感需求差异化定位数据分析看报告的决策者信息不清晰、决策困难呈现方式的选择自动化自己重复劳动、浪费时间投入产出是否划算给家人做具体的家人现有工具不适用专门适配TA的需求\n## 练习：用灵魂三问分析你的想法 ​\n\n选择一个你最近想做的项目（产品、工具、脚本、分析报告都可以），填写下面的表格：\nmarkdown\n```\n## 我的灵魂三问分析\n\n**项目**：____________________\n\n| 问题 | 我的回答 | 状态 |\n|-----|---------|------|\n| 用户是谁？ | | 🟢/🟡/🔴 |\n| 痛点在哪？ | | 🟢/🟡/🔴 |\n| 为什么选你？ | | 🟢/🟡/🔴 |\n\n**是否可以开始**：____________________\n```",
      "word_count": 2208,
      "estimated_time": 4
    },
    {
      "id": "lesson-051",
      "chapter_id": "chapter-02",
      "lesson_number": 29,
      "title": "2.5.7 本节核心要点",
      "content": "# 2.5.7 本节核心要点 ​\n\n## 灵魂三问速记 ​\n\n在动手之前，花3分钟回答：\n\n`✓ 用户是谁——具体到能给TA发微信、能叫出TA的名字\n✓ 痛点在哪——追问到能感受到情绪、能说出发生频率\n✓ 为什么选你——找到与现有方案的差异，或证明值得自己做`\n## 红绿灯法则 ​\n\n- 🟢 三个问题都能一句话回答 → 可以开始\n- 🟡 有的问题说不清楚 → 需要再想想\n- 🔴 有的问题完全答不上来 → 先停下来回答不清楚就动手，做出来的东西大概率没人用（包括自己）。\n\n## 不同场景的核心问法 ​\n场景用户是谁痛点在哪为什么选你做产品用这个产品的人TA完成任务时的障碍你的差异化价值数据分析看报告的决策者TA决策时缺什么信息你选择这种呈现方式的理由自动化自己什么重复劳动在消耗你投入产出是否划算给家人做那个家人现有工具哪里不适合TA你能专门为TA适配什么\n## 下一步 ​\n\n完成灵魂三问自检后，你已经准备好进入下一节：把这些思考应用到不同场景中。\n\n如果你的三个问题都是绿灯，恭喜你——你比80%的人都更清楚自己在做什么。",
      "word_count": 466,
      "estimated_time": 3
    },
    {
      "id": "lesson-052",
      "chapter_id": "chapter-02",
      "lesson_number": 30,
      "title": "2.6.1 核心洞见：一套思维，多种场景",
      "content": "# 2.6.1 核心洞见：一套思维，多种场景 ​\n\n## 为什么思维工具不是「产品经理专用」 ​\n\n前面五节讲的思维工具，名字听起来都很「产品化」：JTBD、MVP、用户画像、PRD……\n\n但如果你仔细看它们的本质，会发现一个共同点：\n\n它们都在解决同一个问题——如何把模糊的想法变成清晰的定义。\n思维工具表面看是本质是JTBD思维理解用户需求搞清楚「我要完成什么任务」逆向思维预防产品失败提前想清楚「什么会出错」减法思维砍掉不必要的功能识别「什么是真正重要的」故事思维设计用户旅程描述「谁在什么情况下做什么」灵魂三问验证产品方向确认「问题定义是否清晰」\n「定义问题」这个能力，不管你做什么都需要。\n\n你做数据分析，需要定义「这个分析要回答什么问题」。 你写自动化脚本，需要定义「这个脚本要解决什么重复劳动」。 你给自己做工具，需要定义「我真正的痛点是什么」。 你给家人做网页，需要定义「他们会在什么场景下使用」。\n\n## 一个贯穿示例：同一个人，四种场景 ​\n\n让我们用一个虚构人物「小王」来说明，同一套思维工具如何应用于不同场景。\n\n小王的背景：28岁，在一家电商公司做运营，会用 Excel，不会写代码。最近开始尝试用 AI 编程工具。\n\n### 场景 A：小王要做一份数据分析 ​\n\n情况：老板要求小王分析「为什么上个月退货率上升了」。\n\n没有思维工具时，小王可能会这样告诉 AI：\n\n`帮我分析一下这份退货数据`AI 会生成一堆图表，但小王不知道该看哪个，也不知道怎么向老板汇报。\n\n用了思维工具后，小王会先问自己：\n问题小王的回答谁要看这个分析？（灵魂三问）老板，他需要在周会上汇报给CEO他们要做什么决策？（JTBD思维）决定是否调整退货政策什么会让这个分析没用？（逆向思维）只说「退货率上升了」但不说原因最核心的问题是什么？（减法思维）退货率上升的主要原因是什么？\n然后小王会这样告诉 AI：\n\n`我是电商运营，老板要在周会上向CEO汇报「上月退货率上升原因」。\n\n核心问题：退货率上升的主要原因是什么？\n\n需要的分析：\n1. 按商品类别分析，哪类退货最多\n2. 按退货原因分析，最常见的3个原因\n3. 对比上月和上上月，变化最大的指标\n\n输出要求：3张图表，每张配一句结论，最后给出2-3个可能的原因假设。\n\n数据在这里：[上传Excel]`\n### 场景 B：小王要写一个自动化脚本 ​\n情况：小王每天早上要从5个平台下载销售数据，手动汇总到一张表里，花费约40分钟。\n\n没有思维工具时，小王可能会这样告诉 AI：\n\n`帮我写一个Python脚本，自动汇总销售数据`AI 会问「数据从哪里来」「格式是什么」，小王答不上来，项目就卡住了。\n\n用了思维工具后，小王会先评估：\n问题小王的回答这个任务多久做一次？（频率）每天每次花多少时间？（耗时）40分钟步骤是否固定？（规则性）是，每天都一样什么情况下会出错？（逆向思维）某个平台改版了、文件格式变了先自动化哪一步？（减法思维）先做「合并5个Excel」，下载暂时手动\n然后小王会这样告诉 AI：\n\n`我的重复任务：每天早上从5个平台下载销售数据Excel，手动合并到一张汇总表。\n\n目前我的工作流程：\n1. 手动下载5个Excel（暂时不自动化）\n2. 打开每个Excel，复制「日期」「商品名」「销量」「金额」这四列\n3. 粘贴到汇总表\n4. 按日期排序\n\n希望自动化的部分：\n第2-4步，把5个Excel合并成一个汇总表。\n\n文件说明：\n- 5个Excel都放在 D:\\销售数据\\每日\\ 文件夹\n- 文件名格式：平台名_日期.xlsx（如 淘宝_20241201.xlsx）\n- 每个文件的数据在Sheet1，第一行是表头\n\n请帮我写一个Python脚本，实现自动合并。`\n### 场景 C：小王要给自己做一个小工具 ​\n情况：小王想做一个「每日复盘」小工具，记录每天做了什么、学到什么。\n\n没有思维工具时，小王可能会想：\n\n`我要做一个复盘工具，要有：\n- 每日记录\n- 周报生成\n- 月度统计\n- 标签分类\n- 搜索功能\n- 数据导出\n- 图表可视化\n……`然后这个项目永远做不完。\n\n用了思维工具后，小王会先问自己：\n问题小王的回答我真正的痛点是什么？（灵魂三问）每天忙完不知道时间花在哪了，第二天又重复同样的错误我会在什么场景下用？（故事思维）晚上睡前，躺在床上用手机，花2分钟记一下什么功能是第一天就必须有的？（减法思维）能快速记录「今天做了什么」「明天要改进什么」什么会让我做完就不用？（逆向思维）太复杂、打开慢、需要填很多东西\n然后小王会这样告诉 AI：\n\n`我要做一个极简每日复盘网页。\n\n使用场景：\n- 晚上睡前用手机打开\n- 2分钟内完成记录\n- 不需要登录\n\n核心功能（只需要这些）：\n1. 两个输入框：「今天做了什么」「明天要改进什么」\n2. 一个保存按钮\n3. 能看到最近7天的记录\n4. 数据保存在浏览器本地\n\n不需要的功能：\n- 不需要标签分类\n- 不需要搜索\n- 不需要统计图表\n- 不需要导出`\n### 场景 D：小王要给爸妈做一个工具 ​\n情况：小王的妈妈60岁，经常忘记和老朋友视频聊天的时间。\n\n没有思维工具时，小王可能会做一个功能很全的「日程管理App」——但妈妈根本不会用。\n\n用了思维工具后，小王会先观察和询问：\n问题小王的回答妈妈是谁？技术水平如何？（故事思维）60岁，只会用微信，不会装App她的真实痛点是什么？（灵魂三问）不是「管理日程」，而是「记住周三下午3点要和李阿姨视频」什么会让她用不了？（逆向思维）字太小、步骤太多、需要登录她会在什么场景下用？（故事思维）周三下午，提前看一眼今天要做什么\n然后小王会这样告诉 AI：\n\n`我要给我妈做一个「今日提醒」网页。\n\n用户情况：\n- 60岁，只会用微信\n- 不会安装App，但会打开微信里的链接\n- 视力一般，需要大字\n\n使用场景：\n- 我把网页链接发到家庭群\n- 妈妈点开就能看到「今天要做什么」\n\n核心功能（只需要这些）：\n1. 大字显示「今天是星期X」\n2. 显示今天的提醒事项（如「下午3点和李阿姨视频」）\n3. 我能远程帮她添加/修改提醒\n\n设计要求：\n- 字体至少20px\n- 按钮要大，容易点到\n- 不需要登录\n- 页面打开就能看到信息，不需要任何操作`\n## 共性：都是在「定义问题」 ​\n四个场景，表面上完全不同：\n\n- 场景A是数据分析\n- 场景B是自动化脚本\n- 场景C是个人工具\n- 场景D是给家人做工具\n但用到的思维工具是完全一样的：\n步骤思维工具在四个场景中都在问第一步JTBD + 灵魂三问这个东西要帮谁完成什么任务？第二步故事思维在什么场景下使用？第三步逆向思维什么情况下会失败/出错/用不了？第四步减法思维最核心的功能是什么？先做哪个？\n思维工具是「操作系统」，场景只是「应用程序」。\n\n掌握了思维工具，你就能应对任何场景。\n\n## 接下来 ​\n\n在接下来的四个小节，我们会逐一深入每个场景：\n\n- 场景特有的挑战是什么\n- 思维工具具体怎么用\n- 完整的 Prompt 模板\n- 常见误区和避坑指南\n让我们从「数据分析场景」开始。",
      "word_count": 2971,
      "estimated_time": 5
    },
    {
      "id": "lesson-053",
      "chapter_id": "chapter-02",
      "lesson_number": 31,
      "title": "2.6.2 数据分析场景：让 AI 做出有价值的分析",
      "content": "# 2.6.2 数据分析场景：让 AI 做出有价值的分析 ​\n\n## 数据分析的 JTBD 本质 ​\n\n很多人以为数据分析就是「做几张图表」。但如果你用 JTBD 思维来看，数据分析真正要完成的任务是：\n\n帮助某个人回答某个业务问题，从而做出更好的决策。\n表面需求JTBD 视角的真实任务做一份销售报表帮老板判断「Q3业绩是否达标」分析用户行为数据帮产品经理决定「下一版优先做什么功能」统计问卷结果帮市场部判断「用户对新品的接受度」\n如果你不知道分析要回答什么问题，AI 生成的图表再漂亮也没用。\n\n## 思维工具在数据分析中的应用 ​\n思维工具在数据分析中要问的问题JTBD思维这个分析要回答什么业务问题？谁会用这个分析做什么决策？逆向思维什么会让这个分析没有价值？数据质量有问题？选错了指标？图表看不懂？减法思维最核心的 1-3 个问题是什么？不要做 20 张图，先回答最重要的问题故事思维看这个分析的人是谁？他们的背景是什么？用什么表达方式他们最容易理解？灵魂三问谁要看？他们关心什么？为什么我的分析能帮到他们？\n## 常见误区：「图表越多越专业」 ​\n\n❌ 错误做法：\n\n`帮我分析这份销售数据，做成图表`AI 可能会生成 15 张图表：柱状图、折线图、饼图、热力图……\n\n问题是：\n\n- 你不知道该看哪张\n- 老板问「所以结论是什么」，你答不上来\n- 做了很多工作，但没有回答任何业务问题\n✅ 正确做法：\n\n先想清楚要回答什么问题，再让 AI 帮你分析。\n\n## 数据分析需求描述模板 ​\n\n在开始分析之前，先填写这个模板：\nmarkdown\n`## 分析背景\n- 我的角色：[你在公司的职位/角色]\n- 分析目的：[这个分析要支持什么决策]\n- 汇报对象：[谁会看这个分析]\n- 使用场景：[在什么会议/报告中使用]\n\n## 核心问题\n这个分析要回答的核心问题是：\n[用一句话描述，如「Q3业绩下滑的主要原因是什么」]\n\n## 数据说明\n- 数据来源：[Excel/数据库/问卷/等]\n- 数据范围：[时间范围、样本量等]\n- 关键字段：[列出最重要的几个字段]\n\n## 输出要求\n- 图表数量：[建议 3-5 张，聚焦核心问题]\n- 图表类型偏好：[柱状图/折线图/等，可选]\n- 结论格式：[每张图配一句结论 / 最后给总结 / 等]\n\n## 数据文件\n[上传你的数据]`\n## 实战案例：Q3 销售分析 ​\n\n### 场景 ​\n小李是一家电商公司的销售运营，老板下周要向 CEO 汇报 Q3 业绩。老板让小李「分析一下为什么 Q3 比 Q2 下滑了」。\n\n### 小李的思考过程 ​\n思维工具小李的思考JTBD思维老板要向 CEO 汇报，他需要的是「原因解释」而不是「数据罗列」逆向思维如果我只说「下滑了 15%」但不说原因，老板在 CEO 面前会很尴尬减法思维核心问题就一个：下滑的主要原因是什么。其他都是辅助故事思维CEO 时间宝贵，5 分钟内要讲清楚，图表要简洁明了灵魂三问老板 → 想知道原因 → 我的分析能给出可能的原因假设\n### 小李给 AI 的 Prompt ​\nmarkdown\n`## 分析背景\n- 我的角色：电商公司销售运营\n- 分析目的：帮老板向CEO解释Q3业绩下滑原因\n- 汇报对象：老板（他会转述给CEO）\n- 使用场景：下周的高管周会，老板有5分钟汇报时间\n\n## 核心问题\nQ3销售额比Q2下滑了，主要原因是什么？\n\n## 需要的分析\n1. 整体对比：Q3 vs Q2 的总销售额，确认下滑幅度\n2. 拆分分析：按产品线/区域/客户类型拆分，找到下滑最严重的部分\n3. 原因探索：是客单价下降？还是订单量下降？还是某个大客户流失？\n\n## 输出要求\n- 3-5张清晰的图表\n- 每张图表配一句话结论\n- 最后给出 2-3 个可能的原因假设（不需要100%确定，给方向就行）\n\n## 数据说明\n- 数据是Q2和Q3的销售明细\n- 包含字段：日期、产品线、区域、客户名、订单金额\n- 共约5000条记录\n\n## 数据文件\n[上传Excel]`\n### AI 会给出什么 ​\n基于这样清晰的需求描述，AI 可能会：\n\n- 生成 Q3 vs Q2 的总销售额对比图，标注下滑 15%\n- 按产品线拆分的柱状图，发现「家电品类」下滑最严重（-30%）\n- 进一步分析家电品类，发现是「订单量」下降而非「客单价」下降\n- 给出假设：可能是夏季促销力度不够 / 竞品有大促活动 / 某款主力产品缺货\n这样的分析老板拿到就能直接用。\n\n## 进阶场景：问卷数据分析 ​\n\n问卷分析和销售分析的思路相同，但有一些特殊注意点：\n注意点说明样本量要说明「共收集 X 份有效问卷」，让结论有依据交叉分析不只看总体，还要看「不同人群的差异」开放题文字回答要做关键词提取或情感分析\n### 问卷分析 Prompt 示例 ​\nmarkdown\n`## 分析背景\n- 我的角色：市场部实习生\n- 分析目的：了解用户对新产品概念的接受度\n- 汇报对象：市场总监\n- 使用场景：新品立项会议\n\n## 核心问题\n1. 用户对新产品的整体接受度如何？（看购买意愿评分）\n2. 不同年龄段的用户，态度有什么差异？\n3. 用户最担心的问题是什么？（从开放题中提取）\n\n## 数据说明\n- 问卷共 20 题，包含单选、多选、评分题、开放题\n- 有效样本 326 份\n- 关键字段：年龄、性别、购买意愿（1-5分）、担心的问题（开放题）\n\n## 输出要求\n- 关键指标用大字展示（如「平均购买意愿 3.8 分」）\n- 交叉分析用分组柱状图\n- 开放题用词云或关键词列表\n\n## 数据文件\n[上传Excel]`\n## 数据分析自检清单 ​\n在把分析结果发出去之前，检查这几点：\n\n- [ ] 我能用一句话说清楚「这个分析回答了什么问题」吗？\n- [ ] 看这个分析的人，能在 30 秒内抓到重点吗？\n- [ ] 每张图表都有明确的结论，而不只是展示数据吗？\n- [ ] 我有没有做太多图表，导致重点被淹没？\n- [ ] 我的分析能帮对方做出决策吗？还是只是「展示了数据」？\n## 核心要点 ​\n\n✓ 数据分析的本质是「回答业务问题」，而不是「做漂亮的图表」\n\n✓ 开始分析之前，先用灵魂三问确认：谁要看？他们想知道什么？\n\n✓ 图表贵精不贵多，3-5 张聚焦核心问题的图表，比 20 张散乱的图表有价值得多",
      "word_count": 2654,
      "estimated_time": 5
    },
    {
      "id": "lesson-054",
      "chapter_id": "chapter-02",
      "lesson_number": 32,
      "title": "2.6.3 自动化脚本场景：识别值得自动化的任务",
      "content": "# 2.6.3 自动化脚本场景：识别值得自动化的任务 ​\n\n## 自动化的价值公式 ​\n\n不是所有重复任务都值得自动化。在动手之前，先算一笔账：\n\n自动化价值 = 频率 × 单次耗时 × 持续年数\n任务频率单次耗时持续年数每年节省时间每周汇总5个部门的Excel每周1次2小时3年104小时/年每天发送日报邮件每天1次10分钟2年61小时/年每月整理发票每月1次3小时5年36小时/年每年做一次年终汇总每年1次8小时10年8小时/年\n一般来说，每年能节省 20 小时以上的任务，就值得花时间自动化。\n\n## 思维工具在自动化中的应用 ​\n思维工具在自动化中要问的问题JTBD思维这个任务帮我完成什么？我现在怎么做的？每次花多少时间？逆向思维什么情况下自动化会出错？文件格式变了？网站改版了？如何处理异常？减法思维先自动化最痛、最频繁的那一步，而不是一次性自动化整个流程故事思维完整描述使用场景：什么时候运行？在哪运行？结果保存到哪？灵魂三问谁用这个脚本？什么任务最痛？为什么值得花时间自动化？\n## 值得自动化的任务特征 ​\n\n问自己这三个问题，每个问题打分（1-5分）：\n评估维度1分3分5分频率每年一两次每月几次每天/每周单次耗时5分钟以内15-30分钟超过30分钟规则性每次都不一样大致相同但有变化步骤完全固定\n总分 12 分以上：非常值得自动化总分 9-11 分：可以考虑自动化总分 8 分以下：可能不值得花时间\n\n### 评估示例 ​\n任务频率耗时规则性总分建议每周汇总部门Excel54514立刻自动化每天检查邮箱并转发特定邮件52411可以自动化偶尔需要批量改文件名2349可以做，但优先级不高每年做一次年终PPT1528不太值得自动化\n## 常见陷阱：一次性自动化整个流程 ​\n\n❌ 错误做法：\n\n「我每天要下载5个平台的数据，合并成一张表，生成图表，然后发邮件给老板。我想把整个流程都自动化。」\n\n问题：\n\n- 5个平台的下载方式可能都不一样\n- 有的可能需要登录、有的可能有验证码\n- 一旦某个环节出错，整个流程就卡住了\n- 开发难度太高，最后做不完\n✅ 正确做法：\n\n先自动化最痛的那一步。\n步骤耗时难度建议下载5个平台数据15分钟高（需要登录、反爬虫）暂时手动合并成一张表30分钟低（固定格式）先自动化这步生成图表10分钟中第二步自动化发邮件5分钟低第三步自动化\n先把「合并Excel」自动化，能立刻节省一半时间。剩下的以后再说。\n\n## 自动化需求描述模板 ​\nmarkdown\n`## 任务背景\n- 这个任务我多久做一次：[每天/每周/每月]\n- 每次花多少时间：[X分钟/小时]\n- 我已经做了多久：[X个月/年]\n- 预计还会做多久：[X个月/年]\n\n## 当前工作流程\n请详细描述你现在是怎么一步步完成这个任务的：\n1. 第一步：[具体操作]\n2. 第二步：[具体操作]\n3. ...\n\n## 希望自动化的部分\n本次只自动化：[选择最痛的1-2个步骤]\n暂时不自动化：[其他步骤，说明原因]\n\n## 文件/数据说明\n- 输入：[文件位置、格式、命名规则]\n- 输出：[期望的输出位置、格式]\n\n## 可能出错的情况\n- 情况1：[如某个文件不存在]\n- 情况2：[如文件格式不对]\n希望的处理方式：[跳过 / 报错提醒 / 等]`\n## 实战案例：周报 Excel 汇总 ​\n\n### 场景 ​\n小张是部门助理，每周一要把5个小组的周报Excel合并成一份汇总表，发给部门经理。\n\n### 小张的评估 ​\n维度评分说明频率5每周一次耗时4约40分钟规则性5每周完全一样的操作总分14非常值得自动化\n### 小张的当前流程 ​\n\n- 打开「周报」文件夹，找到本周5个小组发来的Excel\n- 逐个打开，复制「本周完成」「下周计划」两列\n- 粘贴到汇总表的对应行\n- 调整格式（字体、边框）\n- 保存，发邮件给经理\n### 小张给 AI 的 Prompt ​\nmarkdown\n`## 任务背景\n- 频率：每周一上午\n- 耗时：约40分钟\n- 已做了1年，预计还会做2年以上\n\n## 当前工作流程\n1. 打开 D:\\工作\\周报\\2024\\12月\\ 文件夹\n2. 里面有5个Excel，文件名格式：XX组周报_1209.xlsx\n3. 每个Excel的Sheet1都有同样的结构：\n   - A列：姓名\n   - B列：本周完成\n   - C列：下周计划\n   - 第一行是表头\n4. 我需要把5个Excel的内容合并到一个汇总表\n5. 汇总表要按小组分块，每个小组之间空一行\n\n## 希望自动化的部分\n自动合并5个Excel，生成汇总表。\n\n暂时不自动化：发邮件（我想自己检查一遍再发）\n\n## 文件说明\n- 输入：D:\\工作\\周报\\2024\\12月\\ 下的所有 .xlsx 文件\n- 输出：在同一文件夹下生成「周报汇总_1209.xlsx」\n\n## 可能出错的情况\n- 某个小组没交周报（文件不存在）→ 希望跳过，但最后提醒我\n- 某个文件格式不对（没有这三列）→ 希望跳过，并提醒我\n\n请帮我写一个Python脚本，运行后自动完成汇总。`\n### 这个 Prompt 好在哪里 ​\n特点说明频率和耗时清楚AI 知道这是值得做的任务当前流程详细AI 知道要复制哪些列、格式是什么文件位置明确AI 知道从哪读、写到哪异常处理明确AI 知道遇到问题怎么办范围明确只自动化合并，不自动化发邮件\n## 进阶场景 ​\n\n### 场景1：文件批量重命名 ​\nmarkdown\n```\n## 任务\n我有200张照片，命名是 IMG_0001.jpg 到 IMG_0200.jpg。\n我想把它们重命名为「2024年12月-001.jpg」这样的格式。\n\n## 希望的结果\n- IMG_0001.jpg → 2024年12月-001.jpg\n- IMG_0002.jpg → 2024年12月-002.jpg\n- ...\n\n## 文件位置\nD:\\照片\\待整理\\\n\n请写一个Python脚本，运行后自动重命名。\n运行前先列出「将会重命名的文件」让我确认。\n```\n\n### 场景2：定时提醒 ​\nmarkdown\n```\n## 任务\n每天下午5点，提醒我「该写今日总结了」。\n\n## 方式\n弹出一个系统通知就行。\n\n## 环境\nWindows 11，Python已安装。\n\n请告诉我怎么设置，让这个提醒每天自动运行。\n```\n\n## 自动化自检清单 ​\n在运行脚本之前，检查这几点：\n\n- [ ] 我测试过脚本在「正常情况」下能正确运行吗？\n- [ ] 我测试过脚本在「异常情况」下（如文件不存在）的表现吗？\n- [ ] 我有没有备份原始文件，以防脚本出错？\n- [ ] 脚本运行后，我会检查结果再进行下一步吗？\n- [ ] 我知道脚本做了什么，而不是「反正能用就行」吗？\n## 核心要点 ​\n\n✓ 自动化之前先算账：频率 × 耗时 × 年数，值得才做\n\n✓ 不要一次性自动化整个流程，先做最痛的那一步\n\n✓ 把当前的手动步骤详细写出来，AI 才知道要自动化什么\n\n✓ 想清楚「可能出错的情况」，脚本才能健壮",
      "word_count": 2960,
      "estimated_time": 5
    },
    {
      "id": "lesson-055",
      "chapter_id": "chapter-02",
      "lesson_number": 33,
      "title": "2.6.4 个人工具场景：警惕过度设计的陷阱",
      "content": "# 2.6.4 个人工具场景：警惕过度设计的陷阱 ​\n\n## 个人工具的特殊优势 ​\n\n给自己做工具，有一个巨大的优势：你自己就是用户，不需要猜测需求。\n\n你知道自己：\n\n- 什么时候会用这个工具\n- 在什么设备上用\n- 能接受什么程度的复杂度\n- 什么功能是真正需要的\n这是做产品的人梦寐以求的「用户洞察」——而你天然拥有。\n\n## 个人工具的特殊陷阱 ​\n\n但这个优势也会变成陷阱：你很容易高估自己的需求。\n你想象中的需求实际情况我需要分类功能，按工作/生活/学习分开做了之后发现懒得分类，全堆在一起我需要统计图表，看看每月花了多少钱做了之后发现从来不看我需要多设备同步做了之后发现只在一台设备上用我需要提醒功能做了之后发现权限设置太麻烦，放弃了\n最后你会发现：做了10个功能，常用的只有2个。\n\n## 思维工具在个人工具中的应用 ​\n思维工具在个人工具中要问的问题JTBD思维我要完成什么任务？现有的工具为什么不满足我？逆向思维什么会让我做完就不用？（太复杂？打开慢？需要填很多东西？）减法思维第一天必须有的功能是什么？只做这一个故事思维我会在什么场景下用？手机还是电脑？白天还是晚上？灵魂三问我自己的真实痛点是什么？（不是「可能有用」，而是「真的很痛」）\n## 「过度设计」检测清单 ​\n\n在开始之前，用这个清单检测你的想法是否「过度设计」：\n信号问题如果答案是「是」功能太多你的功能列表超过5个了吗？砍到3个以内解决假痛点这个痛点你这周遇到过吗？如果没有，可能不是真痛点现有工具能用现有的App/工具能解决80%的问题吗？如果能，考虑不做想象的使用场景你能具体描述「今天几点我会用它」吗？如果说不清，可能不会用完美主义你是不是在想「要做就做好」？先做一个能用的，再说「做好」\n如果有3个以上的「是」，建议重新审视这个项目。\n\n## 个人工具需求描述模板 ​\nmarkdown\n`## 我要解决的问题\n一句话描述痛点：[如「每天不知道时间花在哪了」]\n\n这个痛点多久出现一次：[每天/每周/偶尔]\n出现时我有什么感受：[焦虑/烦躁/沮丧]\n\n## 现有方案为什么不行\n我现在怎么解决这个问题：[如「用手机备忘录记」]\n为什么不满意：[如「太麻烦，经常忘记记」]\n\n## 使用场景\n我会在什么时候用：[如「晚上睡前」]\n我会用什么设备：[手机/电脑/都有]\n我能接受的操作复杂度：[30秒内完成/1分钟内完成]\n\n## 第一版只需要的功能\n只要这一个功能：[如「快速记录今天做了什么」]\n\n不需要的功能（以后再说）：\n- [如「分类功能」]\n- [如「统计图表」]\n- [如「多设备同步」]\n\n## 数据保存\n可以保存在浏览器本地（最简单）`\n## 实战案例：极简记账 ​\n\n### 小美的情况 ​\n小美每个月发完工资，到月底就不知道钱花哪了。她想做一个记账工具。\n\n### 小美最初的想法 ​\n\n`我想做一个个人财务管理系统：\n- 收支记录\n- 分类统计（餐饮/交通/购物/娱乐...）\n- 预算管理\n- 月度报表\n- 图表可视化\n- 多账户（微信/支付宝/银行卡）\n- 周期性支出（房租/话费）\n- 数据导出`问题：这个列表太长了，做不完。\n\n### 用思维工具重新审视 ​\n问题小美的诚实回答你真正的痛点是什么？月底不知道钱花哪了，想知道「大头」在哪这个痛点多久出现一次？每个月底你会在什么场景下记账？买完东西用手机顺手记你能接受多复杂的操作？最好3秒内完成，太麻烦就懒得记了现有App为什么不用？太复杂，每次要选分类，烦\n### 小美重新定义的第一版 ​\nmarkdown\n`## 我要解决的问题\n月底不知道钱花哪了，想知道大头在哪。\n\n## 使用场景\n- 买完东西在手机上顺手记一下\n- 3秒内完成\n- 月底看一眼「本月花了多少」\n\n## 第一版只需要\n1. 一个输入框，输入金额和简单备注（如「午饭 35」）\n2. 一个数字显示「本月累计支出」\n3. 能看到最近的记录列表\n\n就这样。不需要分类、不需要图表、不需要多账户。\n\n## 技术要求\n- 手机上打开\n- 数据保存在浏览器本地\n- 不需要登录`\n### 这个版本为什么好 ​\n对比原版简化版开发时间可能几周可能1小时使用门槛需要配置分类、账户打开就能用会不会坚持用大概率放弃更可能坚持能不能解决核心痛点能，但被其他功能淹没能，而且很直接\n## 进阶场景 ​\n\n### 场景1：极简番茄钟 ​\nmarkdown\n```\n## 痛点\n工作时容易走神，想用番茄钟但现有App太花哨。\n\n## 使用场景\n电脑上开着，专注工作时用。\n\n## 第一版只需要\n1. 点一下开始25分钟倒计时\n2. 时间到了响一声\n3. 显示今天完成了几个番茄\n\n不需要：统计报表、自定义时长、白噪音、任务关联。\n```\n\n### 场景2：阅读笔记收集器 ​\nmarkdown\n```\n## 痛点\n在微信读书上划了很多线，但散落在各本书里，想集中看。\n\n## 使用场景\n读完一本书后，把划线内容整理到一起。\n\n## 第一版只需要\n1. 一个输入框，粘贴划线内容\n2. 能标注是哪本书的\n3. 能浏览所有笔记\n\n不需要：分类标签、搜索、导出、分享。\n```\n\n## 「做还是不做」决策流程 ​\n\n```\n我有一个工具想法\n    ↓\n这个痛点这周出现过吗？ → 没有 → 可能是假痛点，观察一下\n    ↓ 是\n现有工具能解决吗？ → 能 → 用现有工具\n    ↓ 不能\n我能描述具体使用场景吗？ → 不能 → 想法还不成熟，再想想\n    ↓ 能\n第一版只做1个核心功能 → 开始\n```\n\n## 个人工具自检清单 ​\n\n- [ ] 我能用一句话说清楚「这个工具解决什么问题」吗？\n- [ ] 这个痛点我这周遇到过吗？\n- [ ] 我能描述「今天什么时候会用它」吗？\n- [ ] 第一版的功能列表是否只有1-2个？\n- [ ] 我有没有克制住「既然做了就做全」的冲动？\n## 核心要点 ​\n✓ 给自己做工具的优势是「你就是用户」，陷阱是「容易高估需求」\n\n✓ 问自己：这个痛点我这周遇到过吗？如果没有，可能不值得做\n\n✓ 第一版只做一个核心功能，能用就行，其他以后再说\n\n✓ 「做完就不用」的工具，不如「简陋但一直在用」的工具",
      "word_count": 2585,
      "estimated_time": 5
    },
    {
      "id": "lesson-056",
      "chapter_id": "chapter-02",
      "lesson_number": 34,
      "title": "2.6.5 家人工具场景：站在他们的角度设计",
      "content": "# 2.6.5 家人工具场景：站在他们的角度设计 ​\n\n## 这个场景的特殊挑战 ​\n\n给家人做工具，和给自己做完全不同。\n给自己做给家人做你是用户，知道自己要什么你要猜他们需要什么你会自己调试、自己修他们遇到问题只会说「用不了」你可以接受一定的复杂度他们可能完全不能接受复杂度你知道「这个按钮是什么意思」他们可能看不懂界面\n核心挑战：你习以为常的东西，对他们可能完全陌生。\n\n## 思维工具在这个场景的特殊应用 ​\n思维工具给家人做工具时的特别关注JTBD思维他们真正要完成的任务是什么？（往往比你想的简单）逆向思维什么会让他们用不了？（字太小、步骤太多、需要登录）减法思维只保留他们真正需要的功能（可能只有1个）故事思维站在他们的角度想象使用场景：什么时候用？在哪用？灵魂三问他们是谁？（年龄、技术水平）他们的真实痛点？\n## 用户调研：观察 > 询问 ​\n\n给家人做工具，不能只靠「问」。因为：\n\n- 他们可能说不清自己的需求\n- 他们可能说「什么都想要」（因为不知道开发成本）\n- 他们可能说「你做的我都喜欢」（因为不想麻烦你）\n更好的方法是观察。\n观察点你能发现什么他们用手机做什么最多微信？看视频？通话？他们遇到什么问题会求助你这就是真痛点他们怎么用现有的App步骤是否顺利？哪里会卡住？他们的手机字体设置多大反映他们需要的字号\n## 非技术用户的设计原则 ​\n\n### 原则1：字要大 ​\n用户年龄建议基础字号40-50岁16-18px50-60岁18-20px60岁以上20px以上\n在 Prompt 里明确说：「字体至少 20px」。\n\n### 原则2：步骤要少 ​\n好的设计不好的设计打开就能看到信息需要登录才能看点一下就完成操作需要选择多个选项操作后立刻有反馈操作后没有变化\n理想情况：打开→看到→操作→完成，总共不超过3步。\n\n### 原则3：反馈要明确 ​\n好的反馈不好的反馈「已保存」文字明确出现只是某个图标变了颜色成功后有「✓」的动画什么提示都没有出错时说「请重试」只显示错误代码\n### 原则4：容错要高 ​\n好的设计不好的设计点错了可以撤回点错了没有后悔的机会填错了有提示「请输入数字」填错了直接报错支持多种输入格式格式稍有不对就不认\n## 家人工具需求描述模板 ​\nmarkdown\n`## 用户是谁\n- 关系：[如「我妈」]\n- 年龄：[如「62岁」]\n- 技术水平：[如「只会用微信，不会装App」]\n- 视力状况：[如「需要大字」]\n- 常用设备：[如「华为手机」]\n\n## 他们的痛点\n用一句话描述：[如「经常忘记吃药时间」]\n\n这个问题多久出现一次：[如「每天」]\n现在怎么解决：[如「我每天打电话提醒，但有时我也忘了」]\n为什么现有App不行：[如「药物提醒App太复杂，她不会设置」]\n\n## 使用场景\n什么时候用：[如「早中晚饭后」]\n在什么设备上用：[如「手机」]\n怎么打开这个工具：[如「我把链接发到家庭群，她点开」]\n\n## 核心功能（只需要这些）\n1. [如「显示今天要吃的药」]\n2. [如「吃完了点一下标记为已吃」]\n\n## 设计要求\n- 字体大小：[如「至少20px」]\n- 按钮大小：[如「容易点到，不容易误触」]\n- 登录要求：[如「不需要登录」]\n- 反馈方式：[如「操作后有明确的文字提示」]\n\n## 不需要的功能\n- [如「不需要历史记录」]\n- [如「不需要云同步」]\n- [如「不需要多用户」]`\n## 实战案例：吃药提醒 ​\n\n### 小明的情况 ​\n小明的妈妈62岁，每天要吃3种药（早上、中午、晚上各一次）。妈妈经常忘记吃药，小明想做一个提醒工具。\n\n### 小明的用户调研（观察） ​\n观察发现妈妈手机字体设置开到最大妈妈最常用的功能微信、打电话妈妈怎么记事情用纸条贴在冰箱上妈妈之前用过提醒App吗用过，但不会设置，放弃了\n### 小明给 AI 的 Prompt ​\nmarkdown\n`## 用户是谁\n- 我妈，62岁\n- 只会用微信，不会安装和设置App\n- 视力一般，手机字体开到最大\n\n## 痛点\n每天要吃3种药，经常忘。我不在身边，没法每天提醒。\n\n## 使用场景\n- 我把网页链接发到家庭微信群\n- 妈妈点开链接，看到今天要吃什么药\n- 吃完了点一下「已吃」\n\n## 核心功能（只需要这些）\n1. 显示今天要吃的药，分早/中/晚三栏\n2. 每种药旁边有一个大按钮「已吃」\n3. 点了「已吃」后，那一行变成绿色，显示「✓ 已吃」\n4. 第二天自动重置（所有药变回「未吃」状态）\n\n## 设计要求\n- 字体至少 22px\n- 按钮要大，宽度至少占屏幕一半\n- 颜色对比要明显（深色字，浅色背景）\n- 不需要登录\n- 打开就能看到今天的药，不需要任何操作\n- 数据保存在浏览器本地\n\n## 不需要的功能\n- 不需要添加/编辑药物功能（我帮她在代码里写死）\n- 不需要提醒推送（她不会设置权限）\n- 不需要历史记录\n- 不需要多用户\n\n## 药物列表（直接写在代码里）\n- 早上：降压药\n- 中午：维生素D\n- 晚上：钙片`\n### 这个设计好在哪里 ​\n设计点为什么这样做不需要登录减少一个步骤，减少出错可能药物写死在代码里妈妈不需要学会「添加药物」不需要推送提醒避免权限设置问题，由小明定时发消息提醒点击后变绿色+文字提示明确的反馈，妈妈知道操作成功了第二天自动重置不需要手动操作\n## 进阶场景 ​\n\n### 场景1：视频通话快捷入口 ​\nmarkdown\n```\n## 用户\n爸妈，60多岁，想和孙子视频但找不到微信视频通话入口。\n\n## 痛点\n每次视频都要问「怎么弄」，其实就是微信里点几下，但他们记不住。\n\n## 解决方案\n做一个简单网页，上面就一个大按钮「给孙子打视频」。\n\n## 功能\n1. 一个大大的按钮，写着「给孙子视频」\n2. 点击后弹出提示：\n   「1. 打开微信\n    2. 找到「小明」的聊天\n    3. 点右下角的「+」\n    4. 点「视频通话」」\n3. 配上截图说明\n\n（其实不能直接调起微信视频，但可以做一个图文教程）\n```\n\n### 场景2：生日相册 ​\nmarkdown\n```\n## 用户\n妈妈，过生日想给她一个惊喜。\n\n## 功能\n1. 打开看到大字「妈妈生日快乐」\n2. 下面是家人的祝福语和照片\n3. 自动播放背景音乐（可选）\n4. 支持左右滑动看不同的祝福\n\n## 设计要求\n- 字要大\n- 照片要清晰\n- 操作要简单（最好只需要滑动）\n- 发一个链接就能打开，不需要装任何东西\n```\n\n## 可访问性检查清单 ​\n发给家人之前，检查这几点：\n\n- [ ] 我在自己手机上测试过了吗？\n- [ ] 我把字体调大后还能正常显示吗？\n- [ ] 所有按钮都足够大，容易点到吗？\n- [ ] 操作后有明确的反馈吗？\n- [ ] 我妈/爸能理解界面上的每个文字吗？\n- [ ] 网络不好的时候能正常打开吗？\n- [ ] 我写了简单的使用说明发给他们了吗？\n## 核心要点 ​\n\n✓ 给家人做工具，要用「观察」而不只是「询问」来了解需求\n\n✓ 字要大、步骤要少、反馈要明确、容错要高\n\n✓ 不要做「完整」的工具，做「他们能用」的工具\n\n✓ 测试时把自己想象成从没用过智能手机的人",
      "word_count": 3012,
      "estimated_time": 6
    },
    {
      "id": "lesson-057",
      "chapter_id": "chapter-02",
      "lesson_number": 35,
      "title": "2.6.6 本节总结：场景化思维速查表",
      "content": "# 2.6.6 本节总结：场景化思维速查表 ​\n\n## 核心洞见回顾 ​\n\n本节的核心观点是：\n\n前面学的思维工具不是「产品经理专用」，而是「定义问题专用」。不管你想做什么，核心思维方式都是一样的。\n\n## 场景速查表 ​\n场景核心问题首要思维工具常见陷阱数据分析这个分析要回答什么业务问题？JTBD思维做了50张图但不知道结论是什么自动化脚本这个任务值得花时间自动化吗？逆向思维+减法思维一次性想自动化整个流程个人工具我的真实痛点是什么？减法思维过度设计，做完就不用家人工具他们会在什么场景下怎么用？故事思维按自己的习惯设计，家人用不了\n## 思维工具 × 场景 应用矩阵 ​\n思维工具数据分析自动化脚本个人工具家人工具JTBD思维谁要看？要做什么决策？这个任务帮我完成什么？我要完成什么任务？他们要完成什么任务？逆向思维什么会让分析没价值？什么情况下脚本会出错？什么会让我做完就不用？什么会让他们用不了？减法思维最核心的3个问题是什么？先自动化最痛的那一步第一版只做1个功能只保留他们需要的功能故事思维谁在什么场景下看这个分析？什么时候运行？结果存哪？我什么时候用？用什么设备？他们什么时候用？怎么打开？灵魂三问谁？关心什么？为什么有价值？谁用？什么最痛？为什么值得做？我是谁？痛点是什么？他们是谁？真实痛点是什么？\n## 通用 Prompt 框架 ​\n\n不管你做什么场景，这个框架都适用：\nmarkdown\n`## 背景\n- 我是：[你的角色/身份]\n- 我要做：[一句话描述目标]\n- 给谁用/谁会看：[用户/受众]\n- 使用场景：[什么时候、在哪、用什么设备]\n\n## 核心问题/任务\n[用一句话描述要解决的核心问题或完成的核心任务]\n\n## 详细说明\n[根据场景填写具体信息：数据说明/当前流程/功能需求等]\n\n## 第一版只需要\n[列出1-3个核心功能/核心输出]\n\n## 不需要\n[明确说不做什么，避免AI过度发挥]\n\n## 可能出错的情况\n[如果适用，列出异常情况及期望的处理方式]`\n## 开始新项目前的5个问题 ​\n在开始任何项目之前，花5分钟问自己这5个问题：\n#问题如果答不上来1这个东西要帮谁完成什么任务？任务不明确，先想清楚再动手2我/用户会在什么场景下使用？场景不清，设计出来可能没人用3什么情况下会失败/出错/用不了？没想过这个问题，容易踩坑4第一版最核心的1个功能是什么？想做的太多，可能做不完5我能用1句话向别人解释这是什么吗？如果说不清，可能自己也没想清楚\n5个问题都能回答，就可以开始了。\n\n## 场景选择决策树 ​\n\n`我有一个想法，想用AI帮我做\n    ↓\n这是什么类型的任务？\n\n→ 我有一堆数据，想看出点东西 → 数据分析场景（2.6.2）\n→ 我有一个重复做的事情，想让它自动 → 自动化场景（2.6.3）\n→ 我想做一个给自己用的小工具 → 个人工具场景（2.6.4）\n→ 我想做一个给家人/朋友用的东西 → 家人工具场景（2.6.5）\n→ 我想做一个给很多人用的产品 → 回到2.1-2.5，走完整的产品思维流程`\n## 本节核心要点 ​\n✓ 思维工具是通用的——不管你做数据分析、自动化脚本还是小工具，核心思维方式都是「先想清楚问题」\n\n✓ 场景不同，侧重不同——数据分析侧重JTBD（回答什么问题），自动化侧重逆向思维（什么会出错），个人工具侧重减法思维（避免过度设计），家人工具侧重故事思维（站在他们角度）\n\n✓ Prompt质量取决于问题定义——AI是一个超级执行者，但「做什么」只有你能决定。问题定义得越清楚，AI的输出越有用\n\n✓ 先做最小版本——不管什么场景，第一版都只做最核心的1-2个功能，验证了再加\n\n## 下一章预告 ​\n\n你现在知道了如何在不同场景中应用思维工具。但还有一个问题：\n\n我怎么知道该做什么？\n\n很多人卡在「我不知道做什么项目」——其实不是没有问题，而是没学会发现问题。\n\n下一节 2.7 问题发现，我们会讲如何从日常生活中发现值得解决的问题。",
      "word_count": 1669,
      "estimated_time": 3
    },
    {
      "id": "lesson-058",
      "chapter_id": "chapter-02",
      "lesson_number": 36,
      "title": "2.7.2 问题就在你身边，只是你没注意",
      "content": "# 2.7.2 问题就在你身边，只是你没注意 ​\n\n## 一个思维实验 ​\n\n回想一下过去一周，你有没有：\n\n- 做过重复的手工操作？\n- 在多个地方复制粘贴同样的信息？\n- 等待某个人给你发送某个文件？\n- 用 Excel 做过让你觉得\"好烦\"的事？\n- 想找某个信息但找不到？\n- 觉得某个 App 不好用但又不得不用？\n每一个\"好烦\"的瞬间，都是一个潜在的问题。\n\n问题是：大多数人在\"烦\"完之后就忘了。他们继续忍受，继续抱怨，但从不停下来想一想——\"这个问题，能不能解决？\"\n\n## 五种发现问题的渠道 ​\n\n问题不会主动跳出来告诉你\"我在这里\"。你需要知道去哪里找。\n\n以下是五种最有效的问题发现渠道：\n\n### 渠道一：自己的重复劳动 ​\n\n观察点：什么事情你每天/每周都在做，而且做的时候感觉\"又来了\"？\n信号示例\"每次都要……\"每次开会前都要手动整理会议纪要模板\"又要……\"又要从5个Excel里汇总数据做周报\"总是……\"总是忘记给家人发提醒\n真实案例：Timesheetr 的诞生\n\n一位独立开发者厌倦了传统的时间表系统：每次记录工作时间都要打开复杂的软件，填写繁琐的表单，然后导出数据提交给 ERP 系统。他问自己：\"有没有可能做一个极简的工具，打开就能记，记完自动同步？\"\n\n于是他用几周时间做了一个轻量级的时间追踪工具 Timesheetr。核心功能只有三个：快速记录任务、自动计算时长、一键同步到 ERP。这个工具解决了他自己的痛点，也帮助了成千上万有同样困扰的自由职业者和咨询师。\n\n问自己：过去一周，你重复做了什么事情超过 3 次？\n\n### 渠道二：身边人的抱怨 ​\n\n观察点：家人、朋友、同事在抱怨什么？\n信号示例\"我妈说……\"我妈说手机上的图标太多了，找不到想用的\"同事吐槽……\"同事吐槽每次找历史文件都要翻半天\"朋友问我……\"朋友问我有没有什么工具可以记录读书笔记\n关键技巧：听\"过去的行为\"，而非\"未来的意愿\"\n\n这是《The Mom Test》一书的核心洞见：当你问别人\"你觉得这个工具怎么样\"或\"你会用吗\"，得到的答案往往是礼貌性的肯定。但如果你问\"你上次遇到这个问题是什么时候？你当时怎么解决的？\"，你会得到真实的信息。\n不要问要问\"你觉得这个想法好不好？\"\"你上次遇到这个问题是什么时候？\"\"你会用这样的工具吗？\"\"你现在怎么解决这个问题？花了多少时间？\"\"这个功能有用吗？\"\"你之前试过什么方法？为什么不管用？\"\n### 渠道三：现有工具的不满 ​\n\n观察点：什么 App 或网站你在用，但用得很不爽？\n信号示例\"如果它能……就好了\"如果这个日历能自动同步多个账户就好了\"为什么它不能……\"为什么这个笔记软件不能一键导出 PDF\"它什么都好，就是……\"它什么都好，就是每次打开太慢了\n真实案例：Tag Timelines 的诞生\n\n一位父亲在使用 Apple AirTag 追踪孩子的书包和家里的狗时，发现了一个问题：AirTag 只能显示当前位置，不能查看历史轨迹。他想知道\"孩子放学后去了哪里\"，但苹果的 Find My 应用做不到。\n\n他没有抱怨完就算了，而是问自己：\"我能不能自己做一个？\"\n\n于是他开发了 Tag Timelines，一个可以记录和展示 AirTag 位置历史的应用。这个工具不仅解决了他自己的问题，还吸引了大量有同样需求的用户——家长想追踪孩子的行踪，宠物主人想看狗狗在院子里跑了多远，商家想监控货物的运输路线。\n\n问自己：你最近用什么工具时，心里嘀咕过\"要是能……就好了\"？\n\n### 渠道四：工作流程的断点 ​\n\n观察点：在完成一件事的过程中，哪里\"卡\"了？\n信号示例\"我得先……然后……再……\"我得先从系统A导出，然后手动整理，再导入系统B\"每次到这一步就卡住\"每次到审批环节就要等三天\"如果这两个能连起来……\"如果微信群消息能自动同步到待办清单就好了\n这种\"断点\"往往是最有价值的问题。因为它不是某个工具不好用，而是两个工具之间没有打通。\n\n常见的工作流断点：\n\n- 从会议录音到会议纪要（需要手动转录和整理）\n- 从 Excel 数据到可视化图表（需要手动复制粘贴到另一个工具）\n- 从想法到待办事项（需要打开另一个 App 手动输入）\n- 从收据照片到报销单（需要手动填写信息）\n### 渠道五：信息获取的困难 ​\n\n观察点：什么信息你经常需要，但每次获取都很麻烦？\n信号示例\"我得去哪里查……\"我得去三个网站分别查比价\"这个信息存在哪来着\"这个客户的联系方式存在哪来着\"每次都要问别人\"每次都要问同事这个流程怎么走\n问自己：什么信息你每周至少要找一次，每次都要花超过 2 分钟？\n\n## 问题观察清单 ​\n\n用这份清单扫描你的日常生活，找出潜藏的问题：\nmarkdown\n`## 问题观察清单\n\n### 重复劳动\n- [ ] 我每天重复做的事情：________________\n- [ ] 我每周重复做的事情：________________\n- [ ] 做这些事时，最烦的环节是：________________\n\n### 身边人的抱怨\n- [ ] 家人最近抱怨过什么？________________\n- [ ] 同事/朋友吐槽过什么工具？________________\n- [ ] 有人向我求助过什么问题？________________\n\n### 现有工具的不满\n- [ ] 哪个常用 App 让我觉得\"要是能……就好了\"？________________\n- [ ] 哪个网站/软件我用得很不顺手？________________\n\n### 工作流断点\n- [ ] 完成某件事时，哪两个步骤之间需要\"手动搬运\"数据？________________\n- [ ] 哪些操作我总觉得\"应该能自动化\"？________________\n\n### 信息获取困难\n- [ ] 什么信息我经常要找，但总是记不住在哪？________________\n- [ ] 什么数据我需要从多个地方拼凑？________________`\n## 一个重要提醒 ​\n发现问题只是第一步。不是所有问题都值得解决，也不是所有问题都适合用 Vibe Coding 解决。\n\n下一节，我们会学习如何用\"烦恼日记\"系统性地记录问题，然后在 2.7.4 节学习如何筛选出真正值得投入的问题。\n\n现在，先完成上面的观察清单。给自己 10 分钟，静下心来扫描一下你的日常生活。\n\n你可能会惊讶地发现：问题一直都在，只是你之前没注意。",
      "word_count": 2698,
      "estimated_time": 5
    },
    {
      "id": "lesson-059",
      "chapter_id": "chapter-02",
      "lesson_number": 37,
      "title": "2.7.3 &quot;烦恼日记&quot;法：系统性发现问题",
      "content": "# 2.7.3 \"烦恼日记\"法：系统性发现问题 ​\n\n## 为什么需要\"记录\" ​\n\n上一节列出了五种发现问题的渠道。但有一个现实的挑战：\n\n大多数\"烦恼\"的瞬间，烦完就忘了。\n\n你在做周报时觉得\"好烦，又要从五个表格里复制数据\"，但做完之后，这个念头就消失了。下周再做时，同样的烦恼再来一次，你又忍了过去。\n\n这就是为什么我们需要一个系统性的方法——把这些稍纵即逝的\"烦恼瞬间\"捕捉下来。\n\n这个方法叫做\"烦恼日记\"。\n\n## 方法来源 ​\n\n\"烦恼日记\"的灵感来自两个地方：\n\n- \n哈佛大学幸福专家 Arthur C. Brooks 的\"痛苦日记\"：他建议记录生活中的痛苦时刻，一个月后回顾时写下学到了什么，六个月后写下从中获得的积极结果。这种方法帮助人们从困难中发现成长的机会。\n\n- \n产品经理的用户研究方法：优秀的产品经理会系统性地记录用户的抱怨和困扰，然后从中发现产品改进的机会。\n\n我们把这两个思路结合起来：用日记的形式，捕捉日常生活中的\"烦恼\"，然后从中筛选出值得用 Vibe Coding 解决的问题。\n\n## 7 天记录法 ​\n\n### 操作方法 ​\n\n连续 7 天，每天记录 1-3 个让你感到\"烦\"的瞬间。\n\n不需要长篇大论，只需要回答 5 个问题：\nmarkdown\n`## 烦恼日记模板\n\n**日期**：____\n**烦恼瞬间**：用一句话描述发生了什么\n**当时在做什么**：具体的任务或场景\n**为什么烦**：是太慢？太麻烦？太容易出错？\n**我最后怎么解决的**：忍着做完？找人帮忙？放弃了？\n**这件事多久发生一次**：每天？每周？每月？偶尔？`\n### 示例 1：职场人士 ​\nmarkdown\n```\n**日期**：周三\n**烦恼瞬间**：又要从 5 个 Excel 里汇总数据做周报\n**当时在做什么**：准备周五的部门汇报\n**为什么烦**：每周都要做，每次都要打开5个文件，复制粘贴，检查数据有没有错\n**我最后怎么解决的**：花了 40 分钟手动完成\n**这件事多久发生一次**：每周一次\n```\n\n### 示例 2：学生 ​\nmarkdown\n```\n**日期**：周四\n**烦恼瞬间**：又忘了论文的截止日期\n**当时在做什么**：刷手机时突然看到群里有人问论文的事\n**为什么烦**：日历、课程表、微信群消息……DDL 信息散落在各处\n**我最后怎么解决的**：熬夜赶完了\n**这件事多久发生一次**：每个月至少一次\n```\n\n### 示例 3：给家人做工具 ​\nmarkdown\n```\n**日期**：周日\n**烦恼瞬间**：我妈又打电话问我怎么用手机查天气\n**当时在做什么**：周末休息\n**为什么烦**：教过很多次了，她还是记不住步骤\n**我最后怎么解决的**：远程语音指导了 10 分钟\n**这件事多久发生一次**：每周至少一次\n```\n\n## 如何避免\"记了就忘\" ​\n记录的最大障碍是：当烦恼发生时，你正在忙别的事，没空停下来写日记。\n\n以下是三个实用技巧：\n\n### 技巧 1：用最顺手的工具 ​\n\n不要专门下载一个新 App。用你已经在用的工具：\n工具用法手机备忘录烦恼发生时，打开备忘录，写一句话关键词，晚上补全微信\"文件传输助手\"给自己发一条语音或文字，晚上整理纸笔在办公桌上放一张纸，随手记Notion/Flomo如果你已经在用，直接创建一个\"烦恼\"收集页面\n### 技巧 2：设置晚间提醒 ​\n\n每天晚上 9 点，给自己设一个提醒：\"今天有什么事让我觉得烦？\"\n\n这个提醒会帮你回忆当天的经历，把那些差点被遗忘的烦恼捞回来。\n\n### 技巧 3：降低记录门槛 ​\n\n不需要每次都写完整的 5 个问题。烦恼发生时，先记下关键词，比如\"Excel 汇总\"或\"又教妈用手机\"。晚上再补充细节。\n\n记住：记录的目的是捕捉问题，不是写作文。一句话足矣。\n\n## 第 8 天：分析你的烦恼清单 ​\n\n7 天后，你手上会有 7-20 条烦恼记录。现在是时候分析它们了。\n\n### 分析步骤 ​\n\n第一步：按频率分类\n频率分数说明每天发生5 分高频痛点，解决价值大每周发生4 分中频痛点，值得关注每月发生2 分低频，但如果很痛也值得解决偶尔发生1 分可能不值得专门做工具\n第二步：按痛苦程度分类\n痛苦程度分数判断标准非常痛苦5 分每次做都想骂人比较烦3 分做的时候心情不好，但能忍有点不爽1 分轻微不便，无所谓\n第三步：按问题归属分类\n归属说明适合做什么只有我有非常个人化的问题个人工具我身边的人也有小范围共性问题可以给家人/同事用的工具很多人都有普遍性问题可能有产品化潜力\n### 计算优先级分数 ​\n\n`优先级分数 = 频率分数 × 痛苦程度分数`示例计算：\n烦恼频率痛苦分数归属Excel 汇总每周(4)非常痛苦(5)20可能很多人有教妈用手机每周(4)比较烦(3)12我家人有忘记 DDL每月(2)非常痛苦(5)10我自己有\n优先级分数越高，越值得优先解决。\n\n## 从烦恼到项目：三个转化案例 ​\n\n### 案例 1：Excel 汇总 → 自动化数据脚本 ​\n\n烦恼：每周要从 5 个部门的 Excel 文件里汇总数据，做成一份周报。\n\n转化过程：\n\n- 识别规律：每个文件的格式是固定的，需要提取的列是固定的\n- 最小方案：写一个脚本，自动读取 5 个文件，提取指定列，合并输出\n- MVP 描述：一个能自动汇总 5 个 Excel 文件数据的小工具\n给 AI 的 Prompt：\n\n`我需要一个工具，能自动汇总多个 Excel 文件。\n具体需求：\n- 读取指定文件夹下的所有 .xlsx 文件\n- 从每个文件的 Sheet1 提取 A、B、D 列\n- 合并成一个新的 Excel 文件\n- 输出到指定位置`\n### 案例 2：找不到文件 → 个人知识库 ​\n烦恼：工作中的资料散落在微信群、邮件、云盘、本地文件夹……每次要找某个文档都像大海捞针。\n\n转化过程：\n\n- 识别规律：问题不是文件太多，而是没有统一的入口\n- 最小方案：做一个简单的\"索引页\"，记录常用文件的位置和关键词\n- MVP 描述：一个可以搜索的个人资料索引网页\n给 AI 的 Prompt：\n\n`我需要一个简单的个人知识库网页。\n具体需求：\n- 能添加条目，每个条目包含：标题、描述、链接/位置、标签\n- 能按标签筛选\n- 能搜索标题和描述\n- 数据保存在浏览器本地`\n### 案例 3：教父母用手机 → 简化版入口页面 ​\n烦恼：父母的手机上有几十个 App，他们常用的其实只有 5 个（微信、电话、相册、天气、日历），但每次都找不到。\n\n转化过程：\n\n- 识别规律：问题不是不会用，而是入口太多、太乱\n- 最小方案：做一个超大图标的\"快捷入口\"网页，只放他们最常用的 5 个功能\n- MVP 描述：一个大字版的手机快捷入口页面\n给 AI 的 Prompt：\n\n`我需要给我 60 多岁的父母做一个手机快捷入口网页。\n具体需求：\n- 页面只有 5 个大按钮：打电话、微信、看天气、看照片、看日历\n- 每个按钮足够大（至少占屏幕宽度的 40%）\n- 字体要大（至少 24px）\n- 点击后跳转到对应的 App 或网页\n- 页面设为手机浏览器主页`\n## 一个重要提醒 ​\n烦恼日记的目的不是收集尽可能多的问题，而是帮你发现那些值得投入时间解决的问题。\n\n7 天后，你手上可能有 20 个烦恼。但真正值得做成项目的，可能只有 1-2 个。\n\n下一节，我们会学习如何用更精细的标准，筛选出最适合用 Vibe Coding 解决的问题。",
      "word_count": 3140,
      "estimated_time": 6
    },
    {
      "id": "lesson-060",
      "chapter_id": "chapter-02",
      "lesson_number": 38,
      "title": "2.7.4 什么样的问题适合用 Vibe Coding 解决",
      "content": "# 2.7.4 什么样的问题适合用 Vibe Coding 解决 ​\n\n## 不是所有问题都适合 ​\n\n通过前面的观察和记录，你可能已经积累了一些待解决的问题。但在投入时间之前，需要做一个重要的判断：\n\n这个问题，适合用 Vibe Coding 解决吗？\n\nVibe Coding 的优势是快速、低门槛、容错性高。但它也有明确的边界。选对问题，事半功倍；选错问题，可能浪费时间，甚至造成风险。\n\n## 五维评估法 ​\n\n我们用五个维度来评估一个问题是否适合用 Vibe Coding 解决。每个维度满分 5 分，总分 25 分。\n\n### 维度一：重复性（这件事多久发生一次？） ​\n频率分数说明每天发生5 分高频问题，解决后每天都能受益每周发生4 分中频问题，值得投入每月发生3 分低频但如果很痛也值得每季度/每年1 分太低频，专门做工具可能不划算只发生一次0 分手动做完就行，不值得做工具\n判断技巧：问自己\"如果这个问题今天解决了，下周我还会遇到吗？\"\n\n### 维度二：规则性（这件事有固定的步骤吗？） ​\n规则性分数说明步骤完全固定5 分可以写成清晰的流程图大部分固定，少数需要判断4 分可以做主流程，特殊情况手动处理一半固定一半灵活3 分需要更多人工介入大部分需要判断1 分难以自动化完全靠经验和直觉0 分不适合做成工具\n判断技巧：试着把这件事的步骤写下来。如果写不出来，说明规则性不够。\n\n示例：\n任务规则性分数从 5 个 Excel 汇总数据列名固定，提取规则固定5 分判断一封邮件该不该回复需要理解内容和上下文1 分把会议录音转成文字步骤固定（上传→转录→输出）5 分决定要不要投资一只股票涉及大量主观判断0 分\n### 维度三：可验证性（怎么知道做对了？） ​\n可验证性分数说明结果非黑即白5 分要么对要么错，一眼能看出来有明确的检查标准4 分可以对照清单验证需要人工审核3 分做完后要花时间检查好坏难以判断1 分很难说\"做完了\"还是\"做对了\"完全主观0 分没有标准答案\n判断技巧：问自己\"如果 AI 帮我做完了，我怎么知道它做得对不对？\"\n\n示例：\n任务可验证性分数计算 5 个表格的数据总和对照原数据可以验算5 分写一封得体的邮件需要人判断语气是否合适2 分生成一张营销海报审美因人而异1 分\n### 维度四：敏感性（涉及的数据有多敏感？） ​\n敏感性分数说明完全不敏感5 分公开信息，无隐私，无风险轻微敏感4 分个人偏好、日程安排等中等敏感2 分涉及工作内容，需要注意高度敏感1 分涉及他人隐私或商业机密极度敏感0 分密码、支付信息、医疗记录等\n判断技巧：问自己\"如果这些数据被泄露了，会有什么后果？\"\n\n红线：以下类型的数据，不建议用 Vibe Coding 处理：\n\n- 银行账户、支付信息、密码\n- 身份证号、护照号等身份信息\n- 医疗记录、健康数据\n- 他人的隐私信息（未经授权）\n### 维度五：容错性（做错了会怎样？） ​\n容错性分数说明做错了没任何影响5 分最坏情况就是重做做错了有点麻烦4 分需要花时间修复，但不严重做错了比较麻烦3 分需要他人帮忙或花较多时间修复做错了很严重1 分可能影响工作或他人做错了不可挽回0 分涉及资金、法律、安全\n判断技巧：问自己\"如果工具出 bug 了，最坏的情况是什么？\"\n\n示例：\n任务容错性分数生成一个个人用的待办清单最坏就是数据丢失，重新记5 分生成一份给老板看的周报可能出错要修改，但影响不大4 分自动发送邮件给客户发错了可能影响公司形象2 分自动执行股票交易做错了可能损失真金白银0 分\n## 问题筛选评分表 ​\n\n把你从烦恼日记中选出的问题，用这个表格打分：\nmarkdown\n`## 问题筛选评分表\n\n**问题描述**：____________________\n\n| 维度 | 分数（0-5） | 备注 |\n|-----|------------|------|\n| 重复性 |  |  |\n| 规则性 |  |  |\n| 可验证性 |  |  |\n| 敏感性（越不敏感越高分） |  |  |\n| 容错性（越容错越高分） |  |  |\n| **总分** |  |  |\n\n**判断标准**：\n- 20-25 分：非常适合，可以立即开始\n- 15-19 分：比较适合，注意低分项的风险\n- 10-14 分：谨慎考虑，可能需要专业支持\n- 10 分以下：不建议用 Vibe Coding 解决`\n## 红线清单：这些问题不要碰 ​\n无论评分多高，以下类型的问题都不建议用 Vibe Coding 解决：\n红线类型原因示例涉及资金流动安全风险极高，一旦出错可能造成真实损失自动转账、支付、理财操作涉及用户隐私法律风险，数据泄露可能违法收集他人信息、处理医疗数据涉及监管合规需要专业资质和知识医疗诊断、法律咨询、财务报表需要长期维护技术债务会累积，Vibe Coding 难以持续多年运营的商业系统高并发场景需要专业的后端架构同时几千人使用的应用\n记住：Vibe Coding 的定位是\"快速验证\"和\"个人工具\"，不是替代专业开发。\n\n## 灰色地带：需要专业支持的情况 ​\n\n有些问题不在红线内，但也不是完全适合自己用 Vibe Coding 解决。这时候你有两个选择：\n\n### 选择一：降级问题范围 ​\n\n把问题缩小到安全范围内。\n\n示例：\n\n- 原问题：\"做一个给客户用的预约系统\" → 涉及用户数据\n- 降级后：\"做一个只有我自己用的日程管理工具\" → 只涉及自己的数据\n### 选择二：寻求专业支持 ​\n\n如果你确实需要做一个涉及敏感领域的产品，考虑：\n\n- 找一个有经验的开发者帮你审核关键部分\n- 使用成熟的第三方服务（如支付用 Stripe、认证用 Auth0）\n- 把敏感部分外包，自己只做非敏感部分\n## 边界情况判断 ​\n\n### \"我的数据只给自己用，算不算敏感？\" ​\n\n如果只是自己的个人数据（日程、读书笔记、待办事项），且存储在本地或个人账户里，通常是安全的。\n\n但要注意：如果你的\"个人工具\"以后可能给别人用，就要提前考虑数据安全。\n\n### \"我想做的东西有一点点涉及敏感信息，怎么办？\" ​\n\n尽量把敏感信息\"剥离\"出来：\n\n- 不在工具里存储敏感信息，只存储索引\n- 敏感信息用链接指向原始位置，不复制到工具里\n- 不做\"自动处理\"敏感信息的功能，保留人工确认环节\n### \"我不确定我的问题适不适合，怎么办？\" ​\n\n两个建议：\n\n- 先做一个\"最安全\"的版本：只解决核心问题，不涉及任何灰色地带\n- 在 2.5 节学过的\"灵魂三问\"自检清单里再过一遍\n## 核心要点 ​\n\n做好问题筛选，能帮你：\n\n✓ 把有限的时间投入到最有价值的问题上\n\n✓ 避免在不适合的问题上浪费精力\n\n✓ 识别需要专业支持的场景，避免踩坑\n\n记住：不是所有问题都要靠自己解决。知道什么不做，和知道什么要做一样重要。",
      "word_count": 2858,
      "estimated_time": 5
    },
    {
      "id": "lesson-061",
      "chapter_id": "chapter-02",
      "lesson_number": 39,
      "title": "2.7.5 给不同人群的问题发现建议",
      "content": "# 2.7.5 给不同人群的问题发现建议 ​\n\n每个人的生活场景不同，发现问题的方式也不同。本节为四类典型读者提供针对性的问题发现指南。\n\n## 如果你是职场人士 ​\n\n你的优势：工作流程中充满了可优化的环节。\n\n### 三个高频问题方向 ​\n方向典型问题MVP 形态数据汇总每周从多个来源收集数据做报表自动汇总脚本信息同步需要在多个系统之间手动复制信息数据搬运工具重复沟通反复回答相同的问题或发送相同的内容常用回复模板库\n### 从问题到项目的完整路径 ​\n\n场景：你是一名市场运营，每周要做一份渠道数据周报。\n\n烦恼：需要从 5 个不同的广告平台导出数据，复制到 Excel，手动计算汇总指标，然后做成 PPT。整个过程要花 2-3 小时。\n\n问题拆解：\n\n- 数据导出：目前需要手动登录 5 个平台 → 暂时无法自动化（涉及账号安全）\n- 数据汇总：把 5 个 Excel 合并成一个 → 可以自动化\n- 指标计算：计算环比、同比、转化率 → 可以自动化\n- 生成报告：做成可视化图表 → 可以自动化\n最小方案：做一个工具，能自动合并 5 个 Excel 文件，计算核心指标，输出汇总表格。\n\n五维评分：\n\n- 重复性：每周一次 → 4 分\n- 规则性：列名固定，计算公式固定 → 5 分\n- 可验证性：可以对照原数据验算 → 5 分\n- 敏感性：公司内部数据，中等敏感 → 3 分\n- 容错性：做错了可以重新跑 → 4 分\n- 总分：21 分，非常适合\n### 职场人士的发现技巧 ​\n\n观察你的工作日志：连续三天，记录你做的每一件事和花费的时间。然后问自己：\n\n- 哪些事情花的时间和产出不成比例？\n- 哪些事情是\"搬砖\"性质的？\n- 哪些事情你做的时候脑子可以放空？\n这些\"脑子可以放空\"的任务，往往就是可以自动化的任务。\n\n## 如果你是学生 ​\n\n你的优势：学习场景中有大量信息管理和时间管理的需求。\n\n### 三个高频问题方向 ​\n方向典型问题MVP 形态DDL 管理作业、考试、活动的截止日期散落各处DDL 聚合提醒工具笔记整理课堂笔记、读书笔记、资料收集无法有效回顾简易笔记索引系统学习追踪不知道自己学了多少、进度如何学习打卡/进度追踪器\n### 从问题到项目的完整路径 ​\n\n场景：你是一名大三学生，同时在准备考研、实习和课程作业。\n\n烦恼：DDL 来自微信群、邮件、教务系统、实习公司的钉钉……经常漏掉重要截止日期。\n\n问题拆解：\n\n- DDL 来源分散 → 需要一个统一的收集入口\n- 没有提醒机制 → 需要在截止日期前提醒\n- 无法一眼看清优先级 → 需要按时间排序\n最小方案：做一个简单的 DDL 收集页面。手动添加每个 DDL（来源、截止时间、重要程度），按时间排序显示，临近截止时高亮提醒。\n\n五维评分：\n\n- 重复性：每天都会看 → 5 分\n- 规则性：添加和显示规则固定 → 5 分\n- 可验证性：DDL 到没到一眼能看出来 → 5 分\n- 敏感性：只是自己的日程 → 5 分\n- 容错性：漏了一个重新添加就行 → 5 分\n- 总分：25 分，完美适合\n### 学生的发现技巧 ​\n\n回忆你的\"焦虑时刻\"：\n\n- 什么时候你会感到焦虑？（考试前、DDL 前、选课时）\n- 焦虑的根源是什么？（信息不清楚、进度不可控、资料找不到）\n- 如果有一个工具能帮你，它应该做什么？\n焦虑往往指向真实的问题。\n\n## 如果你是自由职业者/创业者 ​\n\n你的优势：业务流程完全由自己控制，可以自由优化。\n\n### 三个高频问题方向 ​\n方向典型问题MVP 形态客户管理客户信息散落在微信、邮件、笔记里简易客户名录报价/合同每次都要改模板，容易出错报价单生成器项目追踪多个项目并行，不知道哪个该催款了项目状态看板\n### 从问题到项目的完整路径 ​\n\n场景：你是一名自由设计师，同时服务 8-10 个客户。\n\n烦恼：每个客户的项目进度、付款状态、下次跟进时间都在脑子里记着，经常忘记催尾款。\n\n问题拆解：\n\n- 项目信息没有统一记录 → 需要一个项目列表\n- 状态变化不好追踪 → 需要状态标签（进行中/待付款/已完成）\n- 不知道什么时候该跟进 → 需要下次跟进日期提醒\n最小方案：做一个项目看板。每个项目卡片包含：客户名、项目内容、当前状态、尾款金额、下次跟进日期。按状态分列显示。\n\n五维评分：\n\n- 重复性：每天都要看 → 5 分\n- 规则性：状态流转固定 → 5 分\n- 可验证性：项目有没有跟进一目了然 → 5 分\n- 敏感性：涉及客户信息和金额，中等敏感 → 3 分\n- 容错性：记错了可以改 → 4 分\n- 总分：22 分，非常适合\n### 自由职业者的发现技巧 ​\n\n复盘你的\"漏单时刻\"：\n\n- 什么时候你忘了跟进客户？\n- 什么时候你报价报错了？\n- 什么时候你发票开晚了？\n这些\"漏单\"背后，往往藏着系统性的问题。\n\n## 如果你想给家人做工具 ​\n\n你的优势：你最了解家人的需求，也最有动力帮他们解决问题。\n\n### 三个高频问题方向 ​\n方向典型问题MVP 形态操作简化手机功能太多，找不到常用的大字版快捷入口定时提醒吃药、浇花、缴费容易忘语音/短信提醒工具信息聚合想看天气、快递、新闻，但不会操作一页式信息看板\n### 从问题到项目的完整路径 ​\n\n场景：你妈妈 62 岁，智能手机用了 5 年，但还是经常打电话问你\"怎么看天气\"\"怎么给你爸打电话\"。\n\n烦恼：手机主屏上有 30 多个 App，她常用的其实只有 5 个，但每次都要找半天。\n\n问题拆解：\n\n- 入口太多 → 需要简化到只有常用功能\n- 图标太小 → 需要放大\n- 文字看不清 → 需要大字体\n- 不知道点哪个 → 需要明确的文字标签\n最小方案：做一个网页，放 5 个超大按钮：打电话给儿子、打电话给老伴、看天气、看微信、看照片。每个按钮配上清晰的文字标签，设为浏览器主页。\n\n五维评分：\n\n- 重复性：每天都用 → 5 分\n- 规则性：点击→跳转，完全固定 → 5 分\n- 可验证性：能不能用一试就知道 → 5 分\n- 敏感性：不涉及敏感信息 → 5 分\n- 容错性：点错了退出重来就行 → 5 分\n- 总分：25 分，完美适合\n### 给家人做工具的发现技巧 ​\n\n观察而非询问：\n\n- 不要问\"你需要什么工具\"（他们不知道）\n- 要观察\"他们做什么事情时卡住了\"\n记录他们的\"求助\"：\n\n- 每次家人打电话问你怎么操作，记下来\n- 问的次数最多的问题，就是最值得解决的问题\n设计时谨记：\n\n- 按钮要大（至少占屏幕宽度 40%）\n- 文字要大（至少 24px）\n- 步骤要少（最好一步到位）\n- 颜色要对比强烈（深色背景配浅色文字，或反过来）\n## 如果你完全没思路 ​\n\n有些人确实想不出任何问题。这很正常。两个建议：\n\n### 方法一：从模仿开始 ​\n\n去 GitHub、Product Hunt、少数派等平台，看看别人做了什么小工具。挑一个你觉得\"这个我也需要\"的，复刻一个自己的版本。\n\n在复刻的过程中，你会发现：\n\n- 原版哪里不好用 → 改进点\n- 你还需要什么功能 → 新需求\n- 这个工具可以用在其他场景 → 新想法\n### 方法二：从请求开始 ​\n\n问你身边的人：\"有什么事情你希望有人帮你做？\"\n\n- 问你的同事：\"你平时做什么事情最烦？\"\n- 问你的家人：\"你最近用手机遇到什么困难？\"\n- 问你的朋友：\"你有没有什么重复的任务特别想自动化？\"\n别人的问题，可能就是你的项目。\n\n## 核心要点 ​\n\n✓ 不同人群的问题发现渠道不同，要从自己的生活场景出发\n\n✓ 职场人士关注工作流程，学生关注信息管理，自由职业者关注客户管理\n\n✓ 给家人做工具时，观察比询问更有效\n\n✓ 完全没思路时，可以从模仿开始，或者直接问身边的人",
      "word_count": 3235,
      "estimated_time": 6
    },
    {
      "id": "lesson-062",
      "chapter_id": "chapter-02",
      "lesson_number": 40,
      "title": "2.7.6 实战练习：问题发现工作坊",
      "content": "# 2.7.6 实战练习：问题发现工作坊 ​\n\n本节是一个 30 分钟的实战练习，帮你从零开始找到一个值得用 Vibe Coding 解决的问题。\n\n准备好纸笔（或打开备忘录），让我们开始。\n\n## 练习 1：5 分钟头脑风暴（10 个烦恼） ​\n\n目标：快速列出你生活中的 10 个\"烦恼\"。\n\n规则：\n\n- 不要评判，不要筛选，想到什么写什么\n- 可以很小（每天找钥匙很烦）也可以很大（每周做周报很烦）\n- 不需要考虑\"能不能解决\"，先写下来\n计时：给自己 5 分钟，写满 10 条。\nmarkdown\n`## 我的 10 个烦恼\n\n1. ____________________\n2. ____________________\n3. ____________________\n4. ____________________\n5. ____________________\n6. ____________________\n7. ____________________\n8. ____________________\n9. ____________________\n10. ____________________`写不出来？试试这些提示：\n场景提问工作什么任务你做的时候会叹气？学习什么事情让你觉得\"又来了\"？生活什么东西你经常找不到？家人家人最近向你求助过什么？工具什么 App 你用得很不爽？\n## 练习 2：问题筛选评分（选出 Top 3） ​\n\n目标：从 10 个烦恼中筛选出 3 个最值得解决的。\n\n方法：快速评估每个烦恼的\"值得解决指数\"。\nmarkdown\n`## 快速筛选表\n\n| 烦恼 | 频率(1-5) | 痛苦度(1-5) | 乘积 |\n|-----|----------|------------|------|\n| 1.  |          |            |      |\n| 2.  |          |            |      |\n| 3.  |          |            |      |\n| 4.  |          |            |      |\n| 5.  |          |            |      |\n| 6.  |          |            |      |\n| 7.  |          |            |      |\n| 8.  |          |            |      |\n| 9.  |          |            |      |\n| 10. |          |            |      |`频率评分参考：\n\n- 5 分 = 每天发生\n- 4 分 = 每周发生\n- 3 分 = 每月发生\n- 2 分 = 每季度\n- 1 分 = 偶尔\n痛苦度评分参考：\n\n- 5 分 = 每次做都想骂人\n- 4 分 = 很烦但能忍\n- 3 分 = 有点不爽\n- 2 分 = 轻微不便\n- 1 分 = 无所谓\n选出乘积最高的 3 个问题：\nmarkdown\n`## 我的 Top 3 问题\n\n1. ____________________（乘积：___）\n2. ____________________（乘积：___）\n3. ____________________（乘积：___）`\n## 练习 3：五维详细评分（选出 Top 1） ​\n目标：用完整的五维评估法，从 Top 3 中选出最适合的一个。\n\n对每个问题进行详细评分：\nmarkdown\n`## 问题 1：____________________\n\n| 维度 | 分数(0-5) | 理由 |\n|-----|----------|------|\n| 重复性 |  |  |\n| 规则性 |  |  |\n| 可验证性 |  |  |\n| 敏感性 |  |  |\n| 容错性 |  |  |\n| **总分** |  |  |\n\n## 问题 2：____________________\n\n| 维度 | 分数(0-5) | 理由 |\n|-----|----------|------|\n| 重复性 |  |  |\n| 规则性 |  |  |\n| 可验证性 |  |  |\n| 敏感性 |  |  |\n| 容错性 |  |  |\n| **总分** |  |  |\n\n## 问题 3：____________________\n\n| 维度 | 分数(0-5) | 理由 |\n|-----|----------|------|\n| 重复性 |  |  |\n| 规则性 |  |  |\n| 可验证性 |  |  |\n| 敏感性 |  |  |\n| 容错性 |  |  |\n| **总分** |  |  |`选出总分最高的那个问题：\nmarkdown\n`## 我选择的问题\n\n____________________（总分：___）`\n## 练习 4：灵魂三问预检 ​\n目标：用第 2.5 节学过的灵魂三问，快速检验你选择的问题是否足够清晰。\nmarkdown\n`## 灵魂三问\n\n**问题一：谁有这个问题？**\n（可以是\"我自己\"、\"我和同事\"、\"我妈\"、\"很多人\"……）\n\n答：____________________\n\n**问题二：这个问题的痛点具体是什么？**\n（用一句话描述\"烦\"在哪里）\n\n答：____________________\n\n**问题三：为什么现有方案解决不了？**\n（你现在怎么做的？为什么不满意？）\n\n答：____________________`自检：如果这三个问题你都能清晰回答，说明你对问题的理解已经足够深入，可以进入下一步了。\n\n## 练习 5：一句话 MVP 描述 ​\n\n目标：把你要做的东西，用一句话描述出来。\n\n这句话的格式是：\n\n`一个能 [核心功能] 的 [工具类型]，解决 [谁] 的 [什么问题]。`示例：\n\n- 一个能自动汇总多个 Excel 文件数据的脚本，解决我的每周做周报时手动复制粘贴的问题。\n- 一个能聚合显示所有 DDL的网页，解决我的截止日期散落各处容易忘记的问题。\n- 一个能一键访问常用功能的大字版网页，解决我妈的找不到手机里常用 App的问题。markdown\n`## 我的 MVP 一句话描述\n\n一个能____________________的____________________，\n解决____________________的____________________的问题。`\n## 进阶练习（可选）：The Mom Test 式验证 ​\n如果你想进一步验证这个问题是否值得做，可以尝试这个练习：\n\n目标：找 3 个人，用\"过去行为\"问题验证他们是否也有这个问题。\n\n方法：\n\n不要问：\n\n- ❌ \"你觉得这个工具有用吗？\"（会得到礼貌的肯定）\n- ❌ \"你会用这样的工具吗？\"（假设性问题不可靠）\n要问：\n\n- ✅ \"你上次遇到 [这个问题] 是什么时候？\"\n- ✅ \"你当时怎么解决的？\"\n- ✅ \"这个问题大概多久发生一次？\"\n- ✅ \"你之前试过用什么工具解决吗？为什么不管用？\"\n记录模板：\nmarkdown\n`## 访谈记录\n\n### 访谈对象 1：____（身份：____）\n\nQ：你上次遇到这个问题是什么时候？\nA：\n\nQ：你当时怎么解决的？\nA：\n\nQ：这个问题多久发生一次？\nA：\n\n结论：这个人是否也有这个问题？是 / 否\n\n### 访谈对象 2：____（身份：____）\n\nQ：你上次遇到这个问题是什么时候？\nA：\n\nQ：你当时怎么解决的？\nA：\n\nQ：这个问题多久发生一次？\nA：\n\n结论：这个人是否也有这个问题？是 / 否\n\n### 访谈对象 3：____（身份：____）\n\nQ：你上次遇到这个问题是什么时候？\nA：\n\nQ：你当时怎么解决的？\nA：\n\nQ：这个问题多久发生一次？\nA：\n\n结论：这个人是否也有这个问题？是 / 否`验证结果：\n\n- 3/3 人都有这个问题 → 问题很普遍，值得做\n- 2/3 人有这个问题 → 问题比较普遍，可以做\n- 1/3 人有这个问题 → 问题可能只是你个人的，做个人工具\n- 0/3 人有这个问题 → 重新审视你对问题的理解\n## 完成练习后 ​\n\n恭喜你！如果你完成了上面的练习，你已经：\n\n- ✅ 列出了 10 个生活中的烦恼\n- ✅ 用评分法筛选出了最值得解决的问题\n- ✅ 用灵魂三问验证了对问题的理解\n- ✅ 写出了 MVP 的一句话描述\n下一步，你可以：\n\n- 回到第 2.5 节，用完整的灵魂三问模板深入分析\n- 跳到第 3 章，学习如何把这个想法变成 AI 能懂的 Prompt\n- 直接动手，打开 AI 工具，把你的 MVP 描述发给 AI\n记住：不需要等到\"完美\"才开始。有了清晰的问题定义，你已经比大多数人领先了一大步。",
      "word_count": 3726,
      "estimated_time": 7
    },
    {
      "id": "lesson-063",
      "chapter_id": "chapter-02",
      "lesson_number": 41,
      "title": "2.7.7 本节核心要点",
      "content": "# 2.7.7 本节核心要点 ​\n\n## 三条核心原则 ​\n\n✓ 问题不是想出来的，是观察出来的。 每一个\"好烦\"的瞬间，都是发现问题的线索。通过五种渠道（重复劳动、身边人抱怨、现有工具不满、工作流断点、信息获取困难），系统性地扫描你的日常生活。\n\n✓ 用\"烦恼日记\"捕捉问题，用五维评分筛选问题。 连续 7 天记录烦恼，然后用重复性、规则性、可验证性、敏感性、容错性五个维度打分，选出最适合用 Vibe Coding 解决的问题。\n\n✓ 知道什么不做，和知道什么要做一样重要。 涉及资金、隐私、监管、高并发、长期维护的问题，不适合用 Vibe Coding 解决。识别边界，避免踩坑。\n\n## 问题发现检查清单 ​\n\n在动手做项目之前，确认你已经完成以下步骤：\nmarkdown\n`## 问题发现自检清单\n\n### 问题来源\n- [ ] 我已经识别出这个问题来自哪个渠道（重复劳动/他人抱怨/工具不满/流程断点/信息困难）\n- [ ] 我记录了这个问题发生的频率和痛苦程度\n\n### 问题筛选\n- [ ] 我已经用五维评分法评估了这个问题\n- [ ] 总分达到 15 分以上\n- [ ] 这个问题不在\"红线清单\"内（不涉及资金/隐私/监管）\n\n### 问题定义\n- [ ] 我能用一句话描述\"谁有这个问题\"\n- [ ] 我能用一句话描述\"痛点具体是什么\"\n- [ ] 我能用一句话描述\"为什么现有方案解决不了\"\n\n### MVP 描述\n- [ ] 我已经写出了 MVP 的一句话描述\n- [ ] 这个描述足够具体，AI 能理解我要做什么`\n## 本节工具速查 ​\n工具用途位置问题观察清单系统性扫描五种问题渠道2.7.2 节烦恼日记模板记录和分析烦恼瞬间2.7.3 节五维评分表评估问题是否适合 Vibe Coding2.7.4 节问题筛选评分表从多个问题中选出最优2.7.4 节红线清单识别不应该碰的问题类型2.7.4 节The Mom Test 访谈模板验证他人是否也有这个问题2.7.6 节\n## 本节学到的关键概念 ​\n概念一句话解释五种问题发现渠道重复劳动、身边人抱怨、现有工具不满、工作流断点、信息获取困难烦恼日记法连续 7 天记录烦恼瞬间，用频率×痛苦度计算优先级五维评估法重复性、规则性、可验证性、敏感性、容错性，总分 25 分The Mom Test问过去的行为而非未来的意愿，获得真实的问题验证\n## 常见问题 ​\nQ：我做完练习，发现我的问题评分很低，怎么办？\n\nA：这是好事！说明你避免了一个不适合的问题。回到烦恼日记，换一个问题评估。也可以考虑把问题\"降级\"到更安全的范围（比如只做个人使用的版本）。\n\nQ：我的问题只有我自己有，这样值得做吗？\n\nA：完全值得。给自己做一个好用的工具，本身就是 Vibe Coding 的价值所在。而且，解决自己问题的过程中，你会学到技能、建立信心，为将来做更大的项目打下基础。\n\nQ：我做完访谈，发现别人不太有这个问题，怎么办？\n\nA：两种选择：(1) 把它当作个人工具来做，不追求普遍性；(2) 重新理解问题，也许你问的方式需要调整，也许问题的本质和你想的不一样。\n\n## 下一步 ​\n\n你已经完成了\"问题发现\"这一关键步骤。\n\n接下来，进入 2.8 本章总结，我们会回顾整个\"心法篇\"的七大思维工具，并给你一份完整的开发前检查清单。\n\n有了清晰的问题定义，加上前面学过的 JTBD、减法思维、灵魂三问等工具，你已经具备了\"从想法到行动\"的完整思维框架。\n\n下一章（第 3 章），我们将学习如何把这些想法变成 AI 能懂的语言——Prompt 的艺术。\n\n记住：最难的不是写代码，而是想清楚要解决什么问题。\n\n现在，你已经学会了如何发现问题。接下来，让我们把问题变成现实。",
      "word_count": 1569,
      "estimated_time": 3
    },
    {
      "id": "lesson-064",
      "chapter_id": "chapter-02",
      "lesson_number": 42,
      "title": "2.8.2 开发前检查清单",
      "content": "# 2.8.2 开发前检查清单 ​\n\n在你打开AI工具、写第一行Prompt之前，用这份清单做最后的检查。\n\n## 60秒快速版：红绿灯判断法 ​\n\n没有时间做完整检查？用这三个问题快速判断：\n#问题你的回答1这个东西是给谁用的？（能说出具体的人或自己）2它解决什么问题？（能描述一个具体的烦恼场景）3第一版只做什么？（能用一句话说清楚）\n判断标准：\n\n- 🟢 三个问题都能一句话回答 → 可以开始\n- 🟡 有的问题说不清楚 → 需要再想想，回顾对应章节\n- 🔴 有的问题完全答不上来 → 先停下来，从2.1节重新开始\n## 5分钟完整版：分维度检查 ​\n\n如果你有5分钟，用这份更完整的清单：\n\n### 问题定义（30秒） ​\nmarkdown\n`□ 我知道这个问题来自哪里（自己的烦恼/他人的抱怨/工作流断点）\n□ 这个问题重复出现，不是一次性的\n□ 我能用一句话描述这个问题`\n### 用户理解（60秒） ​\nmarkdown\n```\n□ 我知道用户是谁（具体到能叫出名字或描述特征）\n□ 我知道用户现在怎么解决这个问题（替代方案）\n□ 我理解用户的情绪（焦虑？烦躁？无奈？）\n□ 我知道用户会在什么场景下使用\n```\n\n### 风险预判（60秒） ​\nmarkdown\n```\n□ 我想过什么情况下会失败\n□ 我有一个\"避坑清单\"或预防措施\n□ 我知道这个项目的边界（什么不做）\n```\n\n### MVP范围（60秒） ​\nmarkdown\n```\n□ 我的核心假设是什么（一句话）\n□ 我知道怎么验证这个假设（什么标准算成功）\n□ 第一版的核心功能不超过3个\n□ 我有一个明确的\"不做清单\"\n```\n\n### 最终确认（30秒） ​\nmarkdown\n```\n□ 我能用灵魂三问的格式总结：\n  - 用户是谁：_______________\n  - 痛点在哪：_______________\n  - 为什么选我/为什么值得做：_______________\n```\n\n## 问题诊断表 ​\n如果你发现自己卡住了，对照这张表找到问题：\n你的状态可能的原因建议行动不知道做什么项目没有系统地观察生活中的问题回到2.7节，用\"烦恼日记\"记录一周想做的功能太多，不知道砍哪个没有明确核心假设回到2.3节，问自己\"第一版要验证什么\"说不清楚用户是谁用户画像太模糊回到2.4节，用三维画像法重新描述担心做出来没人用没有做风险预判回到2.2节，做一次Pre-mortem分析解释不清楚这个东西有什么用任务定义不清晰回到2.1节，用JTBD模板重新描述不知道自己的项目和别人有什么区别没想清楚差异化回到2.5节，回答\"为什么选你\"场景特殊，不知道怎么调整没有场景化思考回到2.6节，找到对应场景的侧重点\n## 可复制的检查清单模板 ​\n\n在开始每个新项目时，复制这份模板填写：\nmarkdown\n`# 项目启动检查清单\n\n## 基本信息\n- 项目名称：\n- 开始日期：\n- 预计完成第一版时间：\n\n## 问题定义\n- 问题来源：□ 自己的烦恼 □ 他人的抱怨 □ 工作流断点 □ 其他\n- 问题描述（一句话）：\n\n## 灵魂三问\n1. 用户是谁：\n2. 痛点在哪：\n3. 为什么做这个/为什么选我：\n\n## MVP定义\n- 核心假设：\n- 验证标准（什么情况算成功）：\n- P0功能（不超过3个）：\n  1. \n  2. \n  3. \n\n## 不做清单\n- 功能不做：\n- 用户不服务：\n- 场景不覆盖：\n\n## 风险预判\n- 最可能导致失败的原因：\n- 预防措施：\n\n## 最终确认\n- [ ] 我能用一句话向别人解释这是什么\n- [ ] 我知道第一版要验证什么\n- [ ] 我有信心在 ___ 天内完成第一版`\n## 不同场景的简化检查 ​\n并非所有项目都需要完整检查。根据你的场景，选择合适的深度：\n场景必须检查可选检查给自己用的小工具问题定义 + MVP范围用户理解（自己就是用户）数据分析/报告问题定义 + 用户理解（谁看）风险预判自动化脚本问题定义 + 风险预判（容错性）用户理解给家人/朋友做用户理解 + MVP范围风险预判想给很多人用的产品全部检查无\n## 本节要点 ​\n\n✓ 60秒版是底线：无论多急，三个问题必须能回答。\n\n✓ 诊断表帮你定位问题：卡住了不要硬冲，找到问题根源再继续。\n\n✓ 不同场景深度不同：给自己用的工具不需要完整的用户画像，但核心假设必须清楚。\n\n接下来，我们将总结本章学到的内容，并预告下一章的学习重点。",
      "word_count": 1871,
      "estimated_time": 3
    },
    {
      "id": "lesson-065",
      "chapter_id": "chapter-02",
      "lesson_number": 43,
      "title": "2.8.3 从心法到技法",
      "content": "# 2.8.3 从心法到技法 ​\n\n## 你已经学会了什么 ​\n\n完成第二章的学习后，你具备了以下能力：\n能力具体表现对应章节发现问题能从日常生活中识别值得解决的问题2.7定义任务能用\"任务视角\"描述用户需求，而不是列功能清单2.1预判风险能提前识别可能导致失败的因素2.2聚焦核心能把想法收敛到可验证的最小版本2.3理解用户能构建有血有肉的用户画像2.4自我检验能用三个问题判断是否准备好开始2.5场景适配能根据不同场景调整思考重点2.6\n这些能力的共同点是：帮你想清楚\"做什么\"和\"为什么做\"。\n\n## 心法与技法的关系 ​\n\n本章叫\"心法篇\"，下一章叫\"技法篇\"。它们解决的是不同的问题：\n维度心法（第2章）技法（第3章）核心问题做什么？为什么做？怎么让AI理解我要做什么？输入模糊的想法清晰的需求输出清晰的需求AI能执行的指令关键能力产品思维、用户洞察Prompt工程、需求表达\n心法是技法的前提。\n\n如果你自己都没想清楚要做什么，写出来的Prompt也会是模糊的。AI会给你一个\"看起来像那么回事\"的结果，但不是你真正想要的。\n\n反过来，如果你想得很清楚，但不知道怎么表达给AI，AI也无法帮你。\n\n两者缺一不可。\n\n## 从\"想清楚\"到\"说清楚\" ​\n\n下一章你将学习如何把本章的思考成果，转化为AI能理解的语言：\n\n### 3.1 提示词工程基础 ​\n\n你会学到：\n\n- 为什么\"上下文\"比\"指令\"更重要\n- 如何把用户画像和任务描述融入Prompt\n- 好Prompt和差Prompt的区别\n### 3.2 用户旅程地图 ​\n\n你会学到：\n\n- 如何把用户的完整体验转化为开发步骤\n- 从\"用户做什么\"推导\"系统做什么\"\n### 3.3 编写第一份PRD ​\n\n你会学到：\n\n- 什么是PRD（产品需求文档）\n- 如何用结构化的格式描述需求\n- 让AI不再\"胡编乱造\"的秘诀\n### 3.4 功能优先级 ​\n\n你会学到：\n\n- P0/P1/P2的具体含义\n- 如何用优先级控制AI的输出范围\n- 让AI\"先做这个，暂时不做那个\"\n## 一个预告：本章思考 → 下章Prompt ​\n\n看看本章的输出如何变成下一章的输入：\n\n本章你完成的思考：\n\n`用户：25岁职场新人，怕遗漏任务被批评\n任务：快速记录今天要做的事，不遗漏重要任务\n场景：早上到公司，打开电脑\nMVP：添加任务、完成任务、查看今日任务\n不做：分类、标签、提醒、统计`下一章你将写出的Prompt：\nmarkdown\n`## 背景\n我是一个25岁的职场新人，经常因为忘记任务被领导批评。\n我需要一个极简的每日待办工具。\n\n## 用户场景\n每天早上到公司，打开电脑，快速记下今天要做的事。\n下班前检查是否都完成了。\n\n## 核心功能（P0）\n1. 添加任务：输入框 + 回车即可添加\n2. 完成任务：点击任务左侧的圆圈打勾\n3. 查看任务：打开页面就能看到今日所有任务\n\n## 这一版不需要\n- 任务分类或标签\n- 截止日期或提醒\n- 历史记录或统计\n- 用户登录\n\n## 设计要求\n- 界面极简，打开就是任务列表\n- 添加任务必须在3秒内完成\n- 手机也能正常使用`看到区别了吗？\n\n同样是\"做一个待办清单\"，经过本章的思考，你的Prompt从一句模糊的想法，变成了一份AI能精确执行的需求说明。\n\n## 写在最后 ​\n\n如果你认真完成了这一章的学习和练习，恭喜你——你已经比大多数Vibe Coding初学者领先了一大步。\n\n大多数人的做法是：有了想法 → 直接告诉AI → 发现不对 → 不断修改Prompt → 越改越乱 → 放弃。\n\n你的做法将是：有了想法 → 想清楚 → 写出清晰的Prompt → AI一次给出接近预期的结果 → 微调 → 完成。\n\n区别不在于你用了什么AI工具，而在于你在开口之前想了多少。\n\n记住\n\nAI是一个超级执行者，但\"做什么\"只有你能决定。\n\n想清楚再动手，永远是最快的路。\n\n准备好了吗？让我们进入下一章，学习如何把你的想法\"说\"给AI听。\n\n👉 第3章：技法——与AI对话的艺术",
      "word_count": 1701,
      "estimated_time": 3
    },
    {
      "id": "lesson-066",
      "chapter_id": "chapter-02",
      "lesson_number": 44,
      "title": "A. 思维模型速查表",
      "content": "# A. 思维模型速查表 ​\n\n本附录汇总第二章七个思维模型的核心模板，每个模板都附有填写示例和使用场景说明。\n\n## 模板使用顺序建议 ​\n\n`问题发现 → JTBD → 逆向思维 → 减法思维 → 故事思维 → 灵魂三问 → 场景适配\n    ↓         ↓         ↓           ↓           ↓           ↓\n 找到问题   定义任务   预防失败    聚焦MVP    理解用户    最终自检`不必每次都走完整流程。简单项目可以跳过部分步骤，但灵魂三问是最后的底线检查。\n\n## 1. JTBD 任务描述模板 ​\n\n适用场景：当你有了一个想法，需要明确「用户到底要完成什么任务」时使用。\n\n### 模板 ​\nmarkdown\n`当 [用户类型] 在 [具体场景] 时，\n想要 [完成的任务]，\n以便于 [获得的结果或感受]。`\n### 填写示例 ​\nmarkdown\n```\n当 职场新人 在 早上到公司开始工作 时，\n想要 快速记录今天要做的事，\n以便于 不会遗漏重要任务，可以安心投入工作。\n```\n\n### 进阶：三层任务 ​\n任务层次问题示例功能任务要完成什么具体事情？记录和查看待办事项情感任务想要什么感受？减少焦虑，感到安心社会任务想被别人如何看待？在同事面前显得靠谱\n## 2. Pre-mortem 预演失败模板 ​\n适用场景：在开始项目前，用逆向思维提前识别可能导致失败的因素。\n\n### 模板 ​\nmarkdown\n`## Pre-mortem 分析\n\n假设 [时间] 后项目失败了，可能的原因是：\n\n| 失败原因 | 可能性(高/中/低) | 严重性(高/中/低) | 预防措施 |\n|---------|----------------|----------------|---------|\n| 1.      |                |                |         |\n| 2.      |                |                |         |\n| 3.      |                |                |         |\n\n最需要警惕的风险（可能性高 + 严重性高）：\n_______________\n\n对应的具体行动：\n_______________`\n### 填写示例 ​\nmarkdown\n```\n## Pre-mortem 分析\n\n假设 3个月 后项目失败了，可能的原因是：\n\n| 失败原因 | 可能性 | 严重性 | 预防措施 |\n|---------|-------|-------|---------|\n| 功能太多，做不完 | 高 | 高 | 第一版只做3个核心功能 |\n| 用起来比便签还麻烦 | 中 | 高 | 添加任务必须在3秒内完成 |\n| 做完了自己都不用 | 中 | 高 | 先用一周纸质清单验证习惯 |\n\n最需要警惕的风险：功能太多，做不完\n\n对应的具体行动：明确P0功能只有3个，其他全部放入「不做清单」\n```\n\n## 3. MVP 设计模板 ​\n适用场景：当你需要确定第一版要做什么、不做什么时使用。\n\n### 模板 ​\nmarkdown\n`## MVP 设计\n\n**核心假设**：_______________\n（用一句话描述你要验证的最重要假设）\n\n**验证标准**：_______________\n（什么结果能证明假设成立？）\n\n**P0 功能（必须有，3个以内）**：\n1. _______________\n2. _______________\n3. _______________\n\n**不做清单（明确不做的事情）**：\n- 不做 _______________ ，因为 _______________\n- 不做 _______________ ，因为 _______________\n- 不做 _______________ ，因为 _______________`\n### 填写示例 ​\nmarkdown\n```\n## MVP 设计\n\n**核心假设**：一个极简的每日待办清单，比便签纸和手机备忘录更好用\n\n**验证标准**：自己连续使用7天，每天都用它记录和完成任务\n\n**P0 功能（必须有）**：\n1. 添加任务\n2. 完成任务（打勾）\n3. 查看今日任务\n\n**不做清单**：\n- 不做 多设备同步 ，因为 需要后端开发，大大增加复杂度\n- 不做 任务分类标签 ，因为 不是极简体验的核心\n- 不做 截止日期提醒 ，因为 先验证「记录」这个核心价值\n```\n\n## 4. 用户故事模板（三维画像） ​\n适用场景：当你需要清晰描述「用户是谁」时使用。\n\n### 模板 ​\nmarkdown\n`## 用户画像\n\n**用户名字**：_______________（给TA起个名字）\n\n**一句话描述**：_______________\n\n| 维度 | 内容 |\n|-----|------|\n| 表面属性 | 年龄、职业、每天处理多少事务 |\n| 行为习惯 | 日常使用什么工具、什么时候用、怎么用 |\n| 深层动机 | 害怕什么、追求什么、想成为什么样的人 |\n\n**使用场景**：\n- 场景1：_______________\n- 场景2：_______________\n- 场景3：_______________`\n### 填写示例 ​\nmarkdown\n```\n## 用户画像\n\n**用户名字**：小李\n\n**一句话描述**：25岁职场新人，怕遗漏任务被领导批评\n\n| 维度 | 内容 |\n|-----|------|\n| 表面属性 | 25岁，互联网公司运营，每天处理10-15件事务 |\n| 行为习惯 | 早上到公司先看邮件，用手机备忘录记事但经常忘记看 |\n| 深层动机 | 害怕遗漏任务被批评，想成为一个靠谱的人 |\n\n**使用场景**：\n- 场景1：早上到公司，打开电脑，快速记录今天要做的事\n- 场景2：工作中突然想起一件事，需要3秒内记下来\n- 场景3：下班前，检查今天的事情是否都完成了\n```\n\n## 5. 灵魂三问自检模板 ​\n适用场景：在开始动手前，做最后一次自检。三个绿灯才能开始。\n\n### 模板 ​\nmarkdown\n`## 灵魂三问自检\n\n**项目名称**：_______________\n\n| 问题 | 回答 | 状态 |\n|-----|------|------|\n| 用户是谁？ | _______________ | 🟢/🟡/🔴 |\n| 痛点在哪？ | _______________ | 🟢/🟡/🔴 |\n| 为什么选我？ | _______________ | 🟢/🟡/🔴 |\n\n**状态说明**：\n- 🟢 绿灯：能用一句话清晰回答\n- 🟡 黄灯：有想法但说不清楚\n- 🔴 红灯：完全回答不出来\n\n**结论**：□ 可以开始（全绿） □ 需要完善（有黄） □ 先停下来（有红）`\n### 填写示例 ​\nmarkdown\n```\n## 灵魂三问自检\n\n**项目名称**：极简待办清单\n\n| 问题 | 回答 | 状态 |\n|-----|------|------|\n| 用户是谁？ | 小李——25岁职场新人，怕遗漏任务 | 🟢 |\n| 痛点在哪？ | 经常忘事被批评，现有工具要么太复杂要么容易忘记看 | 🟢 |\n| 为什么选我？ | 打开就是今日待办，3秒添加任务，比便签和备忘录更顺手 | 🟢 |\n\n**结论**：☑ 可以开始（全绿）\n```\n\n## 6. 烦恼日记模板 ​\n适用场景：当你不知道做什么项目时，用这个方法发现值得解决的问题。\n\n### 模板 ​\nmarkdown\n`## 烦恼日记\n\n**日期**：_______________\n\n**烦恼瞬间**：_______________（一句话描述发生了什么）\n\n**当时在做什么**：_______________\n\n**为什么烦**：□ 太慢 □ 太麻烦 □ 容易出错 □ 其他：___\n\n**我最后怎么解决的**：□ 忍着做完 □ 找人帮忙 □ 放弃了 □ 其他：___\n\n**这件事多久发生一次**：□ 每天 □ 每周 □ 每月 □ 偶尔`\n### 填写示例 ​\nmarkdown\n```\n## 烦恼日记\n\n**日期**：周三\n\n**烦恼瞬间**：又要从5个Excel里汇总数据做周报\n\n**当时在做什么**：准备周五的部门汇报\n\n**为什么烦**：☑ 太麻烦（每次都要打开5个文件，复制粘贴，检查有没有错）\n\n**我最后怎么解决的**：☑ 忍着做完（花了40分钟）\n\n**这件事多久发生一次**：☑ 每周\n```\n\n## 7. 问题筛选评分表 ​\n适用场景：当你有多个问题/想法时，用这个表格筛选出最适合 Vibe Coding 解决的问题。\n\n### 模板 ​\nmarkdown\n`## 问题筛选评分表\n\n| 问题 | 重复性 | 规则性 | 可验证 | 不敏感 | 容错高 | 总分 |\n|-----|-------|-------|-------|-------|-------|-----|\n|     | /5    | /5    | /5    | /5    | /5    | /25 |\n\n**评分标准**：\n- 重复性：这个问题多久发生一次？（每天5分，每周4分，每月2分，偶尔1分）\n- 规则性：能用清晰的规则描述吗？（完全能5分，大部分能3分，说不清1分）\n- 可验证：自己用就能验证效果吗？（自己用5分，需要别人3分，很难验证1分）\n- 不敏感：不涉及隐私和资金吗？（完全不涉及5分，略有涉及3分，高度敏感1分）\n- 容错高：错了容易发现和修复吗？（很容易5分，一般3分，错了麻烦大1分）\n\n**建议**：总分 ≥ 18 分的问题适合用 Vibe Coding 解决`\n### 填写示例 ​\nmarkdown\n```\n## 问题筛选评分表\n\n| 问题 | 重复性 | 规则性 | 可验证 | 不敏感 | 容错高 | 总分 |\n|-----|-------|-------|-------|-------|-------|-----|\n| 待办遗漏 | 5 | 4 | 5 | 5 | 4 | 23 ✓ |\n| Excel汇总 | 4 | 5 | 5 | 4 | 4 | 22 ✓ |\n| 投资决策 | 2 | 2 | 1 | 2 | 1 | 8 ✗ |\n\n结论：「待办遗漏」和「Excel汇总」适合做，「投资决策」不适合\n```\n\n## 8. 场景化需求模板 ​\n适用场景：根据不同场景（数据分析、自动化脚本等）描述需求。\n\n### 数据分析需求模板 ​\nmarkdown\n```\n**背景**：我是_______________，需要向_______________汇报\n\n**核心问题**：我要回答「_______________」这个问题\n\n**需要的分析**：\n1. _______________\n2. _______________\n3. _______________\n\n**数据来源**：_______________\n\n**输出要求**：_______________（图表/表格/文字报告）\n```\n\n### 自动化脚本需求模板 ​\nmarkdown\n```\n**我的重复性任务**：_______________\n\n**目前我怎么做的**：\n1. _______________ （耗时___分钟）\n2. _______________ （耗时___分钟）\n3. _______________ （耗时___分钟）\n\n**我希望自动化的部分**：_______________\n\n**输入是什么**：_______________\n\n**输出是什么**：_______________\n\n**可能出错的情况**：_______________\n```\n\n## 快速查找指南 ​\n你的问题使用哪个模板不知道做什么项目烦恼日记 + 问题筛选评分表想清楚用户要完成什么JTBD 任务描述模板担心项目会失败Pre-mortem 模板不知道第一版做什么MVP 设计模板不清楚用户是谁用户故事模板不确定是否准备好开始灵魂三问自检模板要做数据分析数据分析需求模板要做自动化脚本自动化脚本需求模板",
      "word_count": 5146,
      "estimated_time": 10
    },
    {
      "id": "lesson-067",
      "chapter_id": "chapter-02",
      "lesson_number": 45,
      "title": "B. 扩展案例库",
      "content": "# B. 扩展案例库 ​\n\n本附录提供 6 个真实案例，展示如何在不同场景下应用第二章的思维模型。每个案例都包含：问题背景、思维模型应用过程、关键决策、最终结果。\n\n## 案例索引 ​\n场景案例核心思维模型产品验证Dropbox：用视频代替产品减法思维产品验证Airbnb：从气垫床到独角兽JTBD 思维数据分析电商渠道 ROI 分析灵魂三问数据分析销售周报自动化逆向思维个人工具吃药提醒给父母故事思维自动化Excel 多表汇总问题发现\n## 案例 1：Dropbox —— 用视频代替产品 ​\n\n场景类型：产品验证核心思维模型：减法思维\n\n### 背景 ​\n\n2007 年，Drew Houston 有一个想法：做一个能在多台电脑之间自动同步文件的工具。\n\n但他面临一个难题：这个产品需要开发复杂的后端系统、处理各种边界情况，开发周期可能需要一年以上。如果花一年时间做出来，结果没人用怎么办？\n\n### 思维模型应用：减法思维 ​\n\nHouston 问自己一个关键问题：我真正要验证的假设是什么？\n常见做法Houston 的做法先做一个能用的产品先验证「有没有人需要这个」功能越完善越好只需要让人「理解并想要」产品说话视频说话\n他的核心假设是：有足够多的人遇到「多设备文件同步」这个痛点，并且愿意为解决方案付费/注册。\n\n验证这个假设，并不需要一个完整的产品。一个能让人理解「这是什么、能解决什么问题」的视频就够了。\n\n### 关键决策 ​\n\nHouston 做了一个 3 分钟的演示视频，展示 Dropbox 的使用场景：\n\n- 在一台电脑上修改文件\n- 打开另一台电脑，文件自动同步了\n- 不需要 U 盘、不需要发邮件给自己\n视频发布在 Hacker News 上，配合一个注册等待列表页面。\n\n### 结果 ​\n\n- 一夜之间，等待列表从 5,000 人增长到 75,000 人\n- Houston 得到了明确的验证：这个问题值得解决，有大量人愿意使用\n- 基于这个验证结果，他开始认真开发产品\n### 启示 ​\n\n减法思维的核心不是「少做功能」，而是「想清楚要验证什么」。\n\nDropbox 的 MVP 不是一个「功能很少的产品」，而是一个「能验证核心假设的最小方案」。在这个案例中，验证假设的最小方案是一个视频，不是产品。\n\n## 案例 2：Airbnb —— 从气垫床到独角兽 ​\n\n场景类型：产品验证核心思维模型：JTBD 思维\n\n### 背景 ​\n\n2007 年，Brian Chesky 和 Joe Gebbia 付不起旧金山的房租。当时城里正在举办一个设计大会，酒店全部订满。他们想到一个主意：在客厅放几个气垫床，提供早餐，出租给参会者。\n\n这就是 Airbnb 的起源——AirBed & Breakfast（气垫床和早餐）。\n\n### 思维模型应用：JTBD 思维 ​\n\n最初，他们以为自己在解决的问题是「便宜住宿」。\n\n但通过和第一批房客交流，他们发现了更深层的任务：\n表面需求深层任务（JTBD）我需要便宜的住宿我想像当地人一样体验这个城市我需要一张床我想要比酒店更有人情味的住宿体验我想省钱我想把钱花在体验上，而不是标准化的酒店房间\n用 JTBD 模板描述：\n\n当 旅行者 在 去一个新城市参加活动 时， 想要 像当地人一样住在这个城市， 以便于 获得独特的、有人情味的旅行体验。\n\n### 关键决策 ​\n\n基于这个洞察，Airbnb 的定位从「便宜住宿」转变为「像当地人一样生活」。\n\n这影响了后续的产品设计：\n\n- 鼓励房东提供当地生活建议\n- 展示房源的独特个性，而非标准化配置\n- 强调「体验」而非「住宿」\n### 结果 ​\n\nAirbnb 成为估值超过 1000 亿美元的公司。他们的成功不是因为提供了更便宜的住宿，而是因为理解了用户真正要完成的任务。\n\n### 启示 ​\n\nJTBD 思维帮你看到功能背后的任务。\n\n如果 Airbnb 只停留在「便宜住宿」这个表面需求，他们可能会陷入和廉价酒店的价格战。正是因为理解了「像当地人一样生活」这个深层任务，他们开辟了一个全新的市场。\n\n## 案例 3：电商渠道 ROI 分析 ​\n\n场景类型：数据分析核心思维模型：灵魂三问\n\n### 背景 ​\n\n小王是一家电商公司的运营。老板让他「分析一下各渠道的投放效果」。\n\n他打开 Excel，面对一堆数据，不知道从何下手：\n\n- 要分析哪些指标？\n- 要做什么图表？\n- 报告应该多长？\n### 思维模型应用：灵魂三问 ​\n\n小王决定先用「灵魂三问」理清思路：\n\n问题 1：用户是谁？\n\n这份报告的「用户」是老板。老板关心的是「钱花得值不值」，不是「数据有多详细」。\n\n问题 2：痛点在哪？\n\n老板的痛点是：每个月在 5 个渠道投了 50 万广告费，但不知道哪个渠道效果最好，下个月预算该怎么分配。\n\n问题 3：为什么选我？\n\n老板选择让小王做这个分析，是因为小王能接触到各渠道的数据。老板需要的是「能支持决策的结论」，而不是「展示数据的报告」。\n\n### 关键决策 ​\n\n基于灵魂三问，小王明确了分析方向：\n之前的想法调整后的方向分析所有能分析的指标只分析 ROI 相关指标做各种漂亮的图表只做能回答「哪个渠道效果最好」的图报告越详细越好一页 PPT 说清楚结论\n他的核心交付变成了：\n\n「基于 Q3 数据，渠道 A 的 ROI 是 3.2，渠道 C 是 1.1。建议下季度将渠道 C 的预算转移 30% 到渠道 A。」\n\n### 结果 ​\n\n老板看完报告，5 分钟内做出了预算调整决策。老板评价：「终于有人能告诉我该怎么做了，而不是扔给我一堆数据。」\n\n### 启示 ​\n\n数据分析的价值不在于「分析了多少」，而在于「回答了什么问题」。\n\n在做数据分析前，先问自己灵魂三问：\n\n- 这份报告给谁看？\n- 他需要回答什么问题？\n- 他看完后应该能做什么决策？\n## 案例 4：销售周报自动化 ​\n\n场景类型：数据分析/自动化核心思维模型：逆向思维\n\n### 背景 ​\n\n小张每周五要从 5 个部门的 Excel 文件中汇总数据，生成一份销售周报。这个过程需要 2 小时，而且经常出错。\n\n他决定用 Vibe Coding 做一个自动化工具。\n\n### 思维模型应用：逆向思维 ​\n\n在动手之前，小张做了一个 Pre-mortem 分析：\n\n假设 1 个月后，这个自动化工具失败了，可能是什么原因？\n失败原因可能性预防措施部门改了 Excel 格式，脚本跑不了高加入格式检测，发现异常时报警而非静默失败汇总后的数据和手动汇总不一致中前几周自动化和手动并行，对比验证忘了新增的部门没有加入脚本中用文件夹扫描代替硬编码文件名脚本报错了不知道怎么修中让 AI 写详细的错误提示和日志\n### 关键决策 ​\n\n基于 Pre-mortem 分析，小张在给 AI 的 Prompt 中加入了这些要求：\n\n`请帮我写一个 Python 脚本，自动汇总多个 Excel 文件。\n\n特别要求：\n1. 自动扫描指定文件夹下的所有 .xlsx 文件\n2. 检测每个文件的格式是否符合预期，不符合时明确报错\n3. 汇总完成后，输出一份校验摘要（总行数、各部门数据条数）\n4. 每一步操作都写日志，方便排查问题`\n### 结果 ​\n第一周，脚本在汇总财务部数据时报错——因为财务部的表头多了一列。因为有格式检测和明确的错误提示，小张 5 分钟就定位并修复了问题。\n\n如果没有 Pre-mortem 分析，这个问题可能会导致汇总数据错误，直到老板发现才被追查。\n\n### 启示 ​\n\n逆向思维不是悲观主义，而是「提前踩坑」。\n\n对于自动化脚本来说，最危险的不是「跑不起来」，而是「跑起来了但结果不对」。Pre-mortem 帮你提前想到这些风险，并在设计时就加入防护措施。\n\n## 案例 5：吃药提醒给父母 ​\n\n场景类型：个人工具/给家人做核心思维模型：故事思维\n\n### 背景 ​\n\n小李的父母都 60 多岁了，需要每天定时吃降压药。但他们经常忘记，或者吃完了忘记自己吃没吃过。\n\n小李想用 Vibe Coding 做一个吃药提醒工具。\n\n### 思维模型应用：故事思维 ​\n\n小李没有直接开始设计功能，而是先用「三维画像」理解父母：\n维度内容表面属性60+ 岁，视力不太好，不太会用智能手机行为习惯早上起床后先看电视，手机主要用来接电话和微信深层动机不想给子女添麻烦，但又怕忘记吃药影响健康\n然后，他用「用户旅程」想象父母使用这个工具的场景：\n\n`早上 7:00\n├── 场景：爸妈刚起床，在客厅\n├── 触发：手机响了/震动了\n├── 行动：看手机，看到吃药提醒\n├── 障碍：字太小看不清？不知道点哪里确认？\n└── 期望感受：「哦，该吃药了」，点一下就完成`\n### 关键决策 ​\n基于故事思维的分析，小李确定了设计原则：\n常见做法小李的做法多种提醒方式可选只用最简单的方式：大字 + 震动记录吃药历史只问「吃了吗」，点「吃了」就完成可以设置多种药物先只支持一种药，降低复杂度精美的 UI 设计大按钮、大字体、高对比度\n给 AI 的 Prompt：\n\n`我要给 60 多岁的父母做一个吃药提醒网页。\n\n用户特点：\n- 视力不太好，需要大字体（至少 24px）\n- 不太会用手机，交互要极简\n- 不需要记录历史，只需要提醒和确认\n\n功能要求：\n- 显示当前时间和「该吃药了」提示\n- 一个巨大的「我吃了」按钮\n- 点击后显示「好的，明天同一时间再提醒你」\n- 页面可以设为手机浏览器主页`\n### 结果 ​\n父母真的开始用这个工具了。妈妈说：「这个比你之前教我用的那些 App 简单多了，我一看就懂。」\n\n### 启示 ​\n\n给别人做工具时，「故事思维」帮你站在对方角度思考。\n\n如果小李直接问父母「你想要什么功能」，他们可能说不清楚。但通过想象他们的一天、他们使用手机的场景、他们可能遇到的障碍，小李设计出了真正适合他们的工具。\n\n## 案例 6：Excel 多表汇总 ​\n\n场景类型：自动化核心思维模型：问题发现\n\n### 背景 ​\n\n小陈是公司的人事专员。每个月初，她需要从各部门收集考勤表，汇总成一份公司考勤总表。\n\n这件事她做了两年，每次都觉得烦，但从没想过可以自动化。\n\n### 思维模型应用：问题发现 ​\n\n某天，小陈开始记「烦恼日记」。一周后，她回顾记录：\nmarkdown\n`## 烦恼日记汇总\n\n| 日期 | 烦恼 | 频率 | 痛苦程度 |\n|-----|------|-----|---------|\n| 周一 | 考勤汇总做了3小时 | 每月1次 | 9分 |\n| 周二 | 有部门的表格格式又不对 | 每月1次 | 7分 |\n| 周四 | 汇总完发现数据对不上，重新做 | 每月常有 | 10分 |`她用「问题筛选评分表」分析这个问题：\n维度分数理由重复性4每月一次，固定发生规则性5规则很清晰：从指定列提取数据，合并到一张表可验证5自己用就能验证，对比手动结果不敏感4是内部数据，但不涉及薪资等核心敏感信息容错高4汇总后会人工复核，错了能发现总分22非常适合自动化\n### 关键决策 ​\n\n小陈决定用 Vibe Coding 解决这个问题。她用「自动化脚本需求模板」整理需求：\nmarkdown\n`**我的重复性任务**：每月汇总各部门考勤表\n\n**目前我怎么做的**：\n1. 打开各部门发来的 Excel 文件（20分钟找齐文件）\n2. 复制每个文件的 B-F 列数据（60分钟）\n3. 粘贴到汇总表，检查格式（40分钟）\n4. 核对总人数是否一致（20分钟）\n\n**我希望自动化的部分**：步骤 2 和步骤 3\n\n**输入**：一个文件夹，里面是各部门的 .xlsx 文件\n\n**输出**：一个汇总后的 .xlsx 文件\n\n**可能出错的情况**：\n- 有部门的表格列顺序不对\n- 有部门的表格多了或少了几列\n- 文件名格式不统一`\n### 结果 ​\n她用 AI 生成了一个 Python 脚本，现在每月的考勤汇总从 3 小时缩短到 10 分钟（主要是等脚本跑完和人工复核）。\n\n更重要的是，因为脚本会检测格式异常，她再也不用担心「汇总完才发现数据对不上」了。\n\n### 启示 ​\n\n很多值得自动化的问题，我们每天都在「忍着」。\n\n烦恼日记的价值不在于记录本身，而在于让你「看见」那些习以为常的痛点。当你把它们写下来、打分、排序，你就会发现：原来我每个月都在一件事上浪费 3 小时，而这件事完全可以交给 AI。\n\n## 案例总结 ​\n案例核心启示Dropbox验证假设的最小方案，可能不是产品本身Airbnb看到功能背后的任务，才能找到真正的市场电商 ROI 分析数据分析的价值在于支持决策，不在于展示数据销售周报自动化提前想失败原因，在设计时就加入防护吃药提醒给别人做工具，要站在对方角度想象使用场景Excel 汇总烦恼日记帮你发现值得自动化的问题\n这些案例的共同点是：在动手之前，先用思维模型想清楚问题。\n\n这就是第二章「心法」的核心价值——它不会帮你写代码，但会帮你少走弯路。",
      "word_count": 5415,
      "estimated_time": 10
    },
    {
      "id": "lesson-068",
      "chapter_id": "chapter-02",
      "lesson_number": 46,
      "title": "C. 常见误区诊断清单",
      "content": "# C. 常见误区诊断清单 ​\n\n本附录汇总第二章七个思维模型的常见误区。每个误区都配有「症状描述」「问题诊断」「改进建议」，帮助你自检和避坑。\n\n## 如何使用本清单 ​\n\n- 自检：对照每个误区的「症状」，看看自己是否踩坑\n- 诊断：理解为什么这是问题\n- 改进：按建议调整你的思路\n## 一、JTBD 思维的常见误区 ​\n\n### 误区 1.1：只描述功能，不描述任务 ​\n\n症状\n\n你的需求描述是这样的：\n\n「我想做一个待办清单 App，要有添加任务、删除任务、分类标签、截止日期……」\n\n问题诊断\n\n这是「功能清单」，不是「任务描述」。它告诉 AI 你想要什么功能，但没有说明用户要完成什么任务、为什么需要这些功能。\n\nAI 可能会照单全做，但做出来的东西不一定能解决真正的问题。\n\n改进建议\n\n用 JTBD 句式重新描述：\n\n「当职场新人在早上开始工作时，想要快速记录今天要做的事，以便于不会遗漏重要任务。」\n\n然后再推导功能：既然任务是「快速记录」，那么「添加任务」必须在 3 秒内完成。「分类标签」可能反而会拖慢速度，可以不做。\n\n### 误区 1.2：只看功能任务，忽略情感和社会任务 ​\n\n症状\n\n你只考虑用户「要做什么」，没有考虑用户「想要什么感受」和「想被如何看待」。\n\n问题诊断\n\n用户选择一个产品，往往不只是因为功能，还因为情感和社会因素。\n\n- 一个待办清单 App，功能任务是「记录任务」\n- 情感任务可能是「减少焦虑、感到掌控」\n- 社会任务可能是「在同事面前显得靠谱」\n如果你只关注功能任务，可能会做出一个「功能正确但没人想用」的产品。\n\n改进建议\n\n每次做 JTBD 分析时，都问自己三个问题：\n层次问题功能任务用户要完成什么具体事情？情感任务用户想要什么感受？社会任务用户想被别人如何看待？\n### 误区 1.3：把「我想做」当成「用户需要」 ​\n\n症状\n\n你的出发点是「我想做一个 xxx」，而不是「我发现用户需要 xxx」。\n\n问题诊断\n\n这是一个常见的心理偏差。我们往往会假设自己的想法就是用户的需求，而不去验证这个假设。\n\n结果是：花了大量时间做出来的东西，只有自己觉得好。\n\n改进建议\n\n把「我想做」转换成「用户需要」：\n原始想法转换后我想做一个待办清单谁需要待办清单？他们现在怎么解决这个问题？我觉得这个功能很酷有没有用户真的需要这个功能？\n最好的验证方式：找到 3 个目标用户，问问他们现在是怎么做的。\n\n## 二、逆向思维的常见误区 ​\n\n### 误区 2.1：只列风险，不想应对措施 ​\n\n症状\n\n你的 Pre-mortem 分析是这样的：\n\n「可能失败的原因：功能太多做不完、用户不买账、技术实现不了……」\n\n然后就没了。\n\n问题诊断\n\n列出风险只是第一步。如果没有对应的预防措施，这个分析就是空谈。\n\n改进建议\n\n每个风险必须配一个预防措施。用这个格式：\n\n`风险：_______________\n预防措施：_______________`如果想不出预防措施，说明这个风险需要更认真对待——要么它真的很难避免（那可能不该做），要么你还没想清楚（那需要继续思考）。\n\n### 误区 2.2：过度悲观，被风险吓住 ​\n\n症状\n\n你做完 Pre-mortem 分析后，发现有 10 个可能失败的原因，然后决定不做了。\n\n问题诊断\n\n逆向思维不是为了让你放弃，而是为了让你「明知有坑还能避开」。\n\n每个项目都有风险，关键是识别哪些是「致命风险」（必须避免），哪些是「可控风险」（可以接受）。\n\n改进建议\n\n用「可能性 × 严重性」矩阵评估每个风险：\n严重性高严重性低可能性高必须解决注意即可可能性低准备预案可以忽略\n只有「可能性高 + 严重性高」的风险是致命的。如果这类风险无法避免，可能确实不该做。但如果可以预防，那就做好预防措施，然后继续。\n\n### 误区 2.3：Pre-mortem 做一次就完了 ​\n\n症状\n\n你在项目开始时做了 Pre-mortem，然后再也没有回顾过。\n\n问题诊断\n\n项目进行过程中，会出现新的信息。当初没预料到的风险可能会出现，当初担心的风险可能已经化解。\n\n改进建议\n\n在项目关键节点（如 MVP 完成、第一次用户反馈后）重新审视 Pre-mortem 清单：\n\n- 有没有新增的风险？\n- 当初的预防措施有效吗？\n- 有没有风险已经可以划掉？\n## 三、减法思维的常见误区 ​\n\n### 误区 3.1：把 MVP 当成「简陋版」 ​\n\n症状\n\n你的 MVP 是「功能残缺、体验粗糙、凑合能用」的版本。\n\n问题诊断\n\nMVP 是「最小可验证版本」，不是「最小可运行版本」。\n\n关键区别：\n\n- 错误理解：功能越少越好，能跑就行\n- 正确理解：保留足以验证核心假设的功能，这些功能要做好\n如果你的 MVP 体验太差，用户可能因为「不好用」而放弃，而不是因为「不需要」而放弃。你就没法判断问题是出在产品还是需求。\n\n改进建议\n\nMVP 的原则是：功能要少，但核心功能要做到位。\n维度MVP 应该做的MVP 不应该做的功能数量只做 P0（3 个以内）不做 P1、P2功能深度P0 功能做到好用不凑合、不敷衍视觉设计清晰可用不需要精美\n### 误区 3.2：砍功能时心里过不去 ​\n\n症状\n\n你知道应该做 MVP，但每个功能都舍不得砍：\n\n「这个功能很重要啊……那个功能竞品都有……这个功能我都想好怎么做了……」\n\n问题诊断\n\n这是正常的心理。人类天生厌恶损失，砍掉已经想过的功能会让你觉得「亏了」。\n\n但如果不砍，你会花更多时间在不重要的功能上，拖延真正的验证。\n\n改进建议\n\n用「不做清单」代替「功能清单」。不是「删掉功能」，而是「把功能放到不做清单」。\n\n心理上的区别：\n\n- 「删掉」= 这个功能没了\n- 「放到不做清单」= 这个功能我想过了，决定不做，原因是 xxx，将来 xxx 时候再考虑\n### 误区 3.3：不做清单太空泛 ​\n\n症状\n\n你的不做清单是这样的：\n\n「不做复杂的功能」「不做不必要的功能」\n\n问题诊断\n\n这种不做清单等于没有。什么是「复杂」？什么是「不必要」？没有清晰的边界，遇到具体问题时还是会纠结。\n\n改进建议\n\n不做清单要具体到功能名称，并写明理由：\n\n`不做 多设备同步，因为 需要后端开发，大大增加复杂度\n不做 任务分类标签，因为 不是极简体验的核心\n不做 截止日期提醒，因为 先验证「记录」这个核心价值`\n## 四、故事思维的常见误区 ​\n\n### 误区 4.1：用户画像只有人口统计学特征 ​\n症状\n\n你的用户画像是这样的：\n\n「25-35 岁，大城市，大学学历，月收入 1-2 万」\n\n问题诊断\n\n这些信息对产品设计几乎没有帮助。知道用户是「25-35 岁」，并不能告诉你他需要什么功能、会在什么场景下使用、有什么顾虑。\n\n改进建议\n\n用「三维画像」代替人口统计学：\n维度应该包含的内容表面属性职业、每天处理多少事务、使用什么设备行为习惯什么时候用、怎么用、现在用什么替代方案深层动机害怕什么、追求什么、想成为什么样的人\n### 误区 4.2：用户是「一群人」而不是「一个人」 ​\n\n症状\n\n你说的用户是「年轻人」「上班族」「学生」这样的群体。\n\n问题诊断\n\n群体太抽象，无法指导具体的产品设计。「年轻人」里有学生、有职场新人、有创业者，他们的需求完全不同。\n\n改进建议\n\n给你的用户起个名字，把 TA 具体化到「能发微信问问」的程度：\n抽象具体年轻的上班族小李，25 岁，互联网公司运营，每天处理 10-15 件事务经常忘事的人小李，上周因为忘了给客户回邮件被领导批评\n### 误区 4.3：用户旅程只考虑「正常路径」 ​\n\n症状\n\n你的用户旅程是「打开 App → 添加任务 → 完成任务 → 关闭」。\n\n问题诊断\n\n这只是理想情况。真实场景中，用户会遇到各种意外：\n\n- 添加任务时被打断怎么办？\n- 任务太多看不过来怎么办？\n- 几天没用再打开时怎么办？\n改进建议\n\n在用户旅程中加入「异常路径」和「边界情况」：\n\n`正常路径：打开 → 添加 → 完成 → 关闭\n异常路径 1：打开 → 添加到一半被打断 → 下次打开时能看到草稿吗？\n异常路径 2：打开 → 看到 50 个未完成任务 → 会不会焦虑到关掉？\n边界情况：3 天没用 → 再打开时显示什么？`\n## 五、灵魂三问的常见误区 ​\n\n### 误区 5.1：用户描述太泛 ​\n症状\n\n你回答「用户是谁」时，说的是：\n\n「想提高效率的人」「有待办需求的人」「年轻人」\n\n问题诊断\n\n这种描述等于没有描述。「想提高效率的人」可能是学生、是职场人、是创业者，他们的需求差异巨大。\n\n判断标准：你能给这个用户发微信吗？如果不能，说明不够具体。\n\n改进建议\n\n用这个检验标准：我能不能用一句话描述 TA 是谁、TA 在什么场景下遇到什么问题？\n\n`❌ 想提高效率的人\n✅ 小李，25 岁职场新人，经常忘事被领导批评`\n### 误区 5.2：痛点只有「想要」没有「痛」 ​\n症状\n\n你描述的痛点是：\n\n「用户想要一个好用的待办清单」「用户想要更方便地记录任务」\n\n问题诊断\n\n「想要 xxx」是需求，不是痛点。痛点应该带有负面情绪：焦虑、烦躁、尴尬、害怕。\n\n如果用户只是「想要」而没有「痛」，他可能不会真的去用你的解决方案——因为现状还过得去。\n\n改进建议\n\n检验痛点的三个标准：\n标准问题有负面情绪用户会因为这个问题感到焦虑/烦躁/尴尬吗？正在发生用户这周遇到过这个问题吗？愿意付出如果有解决方案，用户会立刻用吗？\n三个都满足，才是真痛点。\n\n### 误区 5.3：「为什么选我」只说「我更好」 ​\n\n症状\n\n你回答「为什么选我」时，说的是：\n\n「因为我的产品更好」「因为我的设计更简洁」\n\n问题诊断\n\n「更好」不是差异化。用户为什么相信你「更好」？相比谁「更好」？好在哪里？\n\n改进建议\n\n用这个句式回答：\n\n「用户现在用 [现有方案] 解决这个问题，但 [痛点]。我的方案是 [具体差异]，所以用户应该选我。」\n\n`❌ 因为我的产品更好\n✅ 用户现在用手机备忘录记事，但经常忘记看。我的方案是「打开就是今日待办」，3秒添加任务，所以更适合需要快速记录的职场人。`\n## 六、场景应用的常见误区 ​\n\n### 误区 6.1：生搬硬套产品思维 ​\n症状\n\n你在做数据分析或自动化脚本时，也在纠结「用户画像」「MVP」「灵魂三问」。\n\n问题诊断\n\n思维模型是工具，不是教条。不同场景需要灵活调整：\n\n- 做产品：需要完整的用户画像、MVP 规划\n- 做数据分析：核心是「给谁看、回答什么问题」\n- 做自动化脚本：核心是「什么任务值得自动化」\n改进建议\n\n根据场景选择重点：\n场景重点模型次要模型产品/工具JTBD、减法、灵魂三问全部数据分析灵魂三问（给谁看、回答什么）逆向（什么会让分析出错）自动化脚本问题发现、逆向思维减法（先自动化哪一步）给家人做故事思维减法（极简设计）\n## 七、问题发现的常见误区 ​\n\n### 误区 7.1：烦恼日记只记不分析 ​\n\n症状\n\n你记了一周的烦恼日记，然后就放在那里了。\n\n问题诊断\n\n记录只是第一步。价值在于分析和筛选。\n\n改进建议\n\n第 8 天必须做分析：\n\n- 按频率和痛苦程度打分\n- 用「问题筛选评分表」评估每个问题\n- 选出分数最高的 1-2 个问题，开始做 JTBD 分析\n### 误区 7.2：选了一个「不适合自动化」的问题 ​\n\n症状\n\n你选择自动化的任务是：\n\n- 涉及大量主观判断（如「帮我写一份好的报告」）\n- 涉及敏感数据（如「自动交易股票」）\n- 错了后果很严重（如「自动给客户发合同」）\n问题诊断\n\n不是所有问题都适合用 Vibe Coding 解决。规则性低、敏感性高、容错性低的任务，应该谨慎处理。\n\n改进建议\n\n用「问题筛选评分表」评估，总分低于 15 分的问题，要么不做，要么只做辅助（人工复核）。\n\n## 自检清单总结 ​\n\n完成项目前，用这个清单快速自检：\n\n- [ ] 我用的是「任务描述」而非「功能清单」？\n- [ ] 我考虑了功能、情感、社会三层任务？\n- [ ] 每个风险都有对应的预防措施？\n- [ ] MVP 的核心功能做到位了，而不是凑合？\n- [ ] 不做清单是具体的功能名称，而非空泛描述？\n- [ ] 用户画像具体到「能发微信」的程度？\n- [ ] 痛点带有负面情绪，而非只是「想要」？\n- [ ] 「为什么选我」说清楚了和现有方案的差异？\n如果有任何一项打不了勾，回到对应章节重新思考。",
      "word_count": 5186,
      "estimated_time": 10
    },
    {
      "id": "lesson-069",
      "chapter_id": "chapter-02",
      "lesson_number": 47,
      "title": "D. 深度参考资源",
      "content": "# D. 深度参考资源 ​\n\n本附录提供第二章思维模型的原始出处、推荐书单和免费在线资源，帮助你进一步深入学习。\n\n## 一、框架原始出处 ​\n\n### JTBD（Jobs to be Done） ​\n\n提出者：Clayton Christensen（克莱顿·克里斯坦森）\n\nClayton Christensen 是哈佛商学院教授，被誉为「颠覆式创新之父」。他在研究创新时发现，理解用户真正要完成的「任务」比理解用户的人口统计学特征更有价值。\n\n核心著作：\n\n- 《与运气竞争》（Competing Against Luck, 2016）—— JTBD 框架的系统阐述\n- 《创新者的窘境》（The Innovator's Dilemma, 1997）—— 颠覆式创新理论\n经典案例：「奶昔的故事」\n\n一家快餐连锁店想提升奶昔销量。传统方法是做用户调研：口味偏好、价格敏感度、包装设计。\n\nChristensen 团队换了一个问题：「用户雇佣奶昔来完成什么任务？」\n\n调研发现，早晨买奶昔的人大多是通勤族。他们的任务不是「喝一杯饮料」，而是「在无聊的开车路上有点事做，同时填饱肚子到中午」。\n\n奶昔的竞争对手不是其他饮料，而是香蕉、甜甜圈、百吉饼。\n\n这个洞察改变了产品策略：让奶昔更稠（喝得更久）、更方便（单手拿）、更饱腹。\n\n### Pre-mortem（预演失败） ​\n\n提出者：Gary Klein（加里·克莱因）\n\nGary Klein 是认知心理学家，研究专家决策和直觉。他在 1989 年提出 Pre-mortem 技术，作为对抗「计划乐观偏差」的方法。\n\n核心论文：\n\n- \"Performing a Project Premortem\"（发表于 Harvard Business Review, 2007）\n方法原理：\n\n传统风险评估让人问「这个项目可能有什么风险？」——大多数人会因为乐观偏差而低估风险。\n\nPre-mortem 换一个问题：「假设项目已经失败了，写出失败原因。」\n\n这个心理技巧叫做「前瞻性后视」（prospective hindsight）。研究表明，当人们被要求解释一个已经发生的事件（即使是假设的），他们能想出比预测未来多 30% 的原因。\n\nKlein 的原话：\n\n「Pre-mortem 的价值在于，它给了团队成员说出担忧的许可。在传统的计划会议上，提出问题会被视为不配合。Pre-mortem 把这变成了一个游戏——谁能想出最有创意的失败原因？」\n\n### MVP（最小可行产品） ​\n\n提出者：Eric Ries（埃里克·莱斯）\n\nEric Ries 是硅谷创业者，精益创业运动的发起人。他在 2011 年出版的《精益创业》中系统阐述了 MVP 概念。\n\n核心著作：\n\n- 《精益创业》（The Lean Startup, 2011）\nMVP 的原始定义：\n\n「最小可行产品是新产品的一个版本，它允许团队以最小的努力收集关于客户的最大量的验证学习。」\n\n常见误解与澄清：\n误解Ries 的原意MVP = 功能最少的产品MVP = 能验证核心假设的最小方案MVP = 简陋、凑合MVP 的核心功能应该做好MVP 只适用于软件MVP 可以是视频、着陆页、手工服务\nRies 的名言：\n\n「如果你发布的第一个版本没有让你感到尴尬，那说明你发布得太晚了。」\n\n但他也强调：尴尬的应该是功能不够多，而不是核心功能做得不好。\n\n## 二、推荐书单 ​\n\n### 中文书籍 ​\n书名作者推荐理由《精益创业》Eric RiesMVP 和快速验证的系统方法《上瘾：让用户养成使用习惯的四大产品逻辑》Nir Eyal理解用户行为和习惯形成《用户思维+：好产品让用户为自己尖叫》Kathy Sierra从用户成功角度思考产品《创新者的窘境》Clayton Christensen理解颠覆式创新《启示录：打造用户喜爱的产品》Marty Cagan硅谷产品经理的实战方法\n### 英文书籍 ​\n书名作者推荐理由Competing Against LuckClayton ChristensenJTBD 框架的原著The Mom TestRob Fitzpatrick如何正确做用户访谈SprintJake KnappGoogle Ventures 的 5 天设计冲刺方法InspiredMarty Cagan产品发现和交付的最佳实践Shape UpBasecamp小团队如何高效做产品\n### 阅读建议 ​\n\n如果你只有时间读一本，推荐：\n\n- 中文：《精益创业》——系统理解 MVP 思维\n- 英文：The Mom Test——学会正确做用户访谈，避免「妈妈会说你的想法很好」的陷阱\n## 三、免费在线资源 ​\n\n### 视频课程 ​\n\nY Combinator Startup School\n\n- 网址：https://www.startupschool.org/\n- 内容：硅谷顶级孵化器的免费创业课程\n- 推荐章节： How to Get Startup Ideas（如何发现创业想法）\n- How to Talk to Users（如何与用户交流）\n- How to Plan an MVP（如何规划 MVP）\nLenny's Podcast\n\n- 网址：https://www.lennyspodcast.com/\n- 内容：产品经理访谈播客，有文字稿\n- 推荐集数： Jobs to be Done 专题（多位 JTBD 专家访谈）\n- 各大公司 PM 的产品发现方法\n### 模板和工具 ​\n\nReforge Artifacts\n\n- 网址：https://www.reforge.com/artifacts\n- 内容：来自 Airbnb、Uber、Spotify 等公司的真实产品文档模板\n- 推荐内容：JTBD 框架模板、用户研究指南\nStrategyzer\n\n- 网址：https://www.strategyzer.com/\n- 内容：商业画布和价值主张设计工具\n- 推荐内容：Value Proposition Canvas（价值主张画布）\nMiro Pre-mortem Template\n\n- 网址：https://miro.com/templates/pre-mortem/\n- 内容：可视化 Pre-mortem 分析模板\n### 文章和博客 ​\n\nStrategyn（Tony Ulwick 的公司）\n\n- 网址：https://strategyn.com/\n- 内容：JTBD 框架的进阶应用，Outcome-Driven Innovation 方法\nSilicon Valley Product Group（SVPG）\n\n- 网址：https://www.svpg.com/articles/\n- 内容：Marty Cagan 的产品管理文章\nPaul Graham 的博客\n\n- 网址：http://paulgraham.com/articles.html\n- 推荐文章： How to Get Startup Ideas\n- Do Things That Don't Scale\n## 四、进一步学习路径 ​\n\n根据你的兴趣方向，推荐不同的学习路径：\n\n### 路径 A：想深入理解 JTBD ​\n\n`入门：《与运气竞争》第 1-4 章\n↓\n进阶：Strategyn 网站的 JTBD 案例分析\n↓\n实践：用 JTBD 模板分析 3 个你日常使用的产品\n↓\n深入：Tony Ulwick 的 Outcome-Driven Innovation`\n### 路径 B：想学会快速验证想法 ​\n\n```\n入门：《精益创业》第 1-6 章\n↓\n进阶：The Mom Test（学习正确的用户访谈）\n↓\n实践：为你的一个想法设计 MVP 方案\n↓\n深入：Y Combinator Startup School 视频课程\n```\n\n### 路径 C：想提升产品设计能力 ​\n\n```\n入门：《启示录》或 Inspired\n↓\n进阶：Sprint（Google Ventures 设计冲刺）\n↓\n实践：用 5 天时间为一个问题设计解决方案\n↓\n深入：SVPG 博客的产品发现系列文章\n```\n\n## 五、学习建议 ​\n\n- 不要贪多：选一本书认真读完，比浏览十本书更有价值\n- 边学边做：每学一个框架，就用它分析你正在做的项目\n- 输出倒逼输入：尝试用自己的话解释这些概念，写下来或讲给别人听\n- 定期回顾：一个月后重读本章，你会有不同的理解\n## 引用说明 ​\n本章内容参考了以下来源：\n\n- Clayton Christensen 的 JTBD 理论\n- Gary Klein 的 Pre-mortem 技术\n- Eric Ries 的精益创业方法论\n所有案例（如 Dropbox、Airbnb）均来自公开资料，用于教学说明目的。",
      "word_count": 3696,
      "estimated_time": 7
    },
    {
      "id": "lesson-070",
      "chapter_id": "chapter-03",
      "lesson_number": 1,
      "title": "3.1.1 什么是提示词工程",
      "content": "# 3.1.1 什么是提示词工程 ​\n\n## 经过本节学习，你将掌握 ​\n\n- 提示词工程的真正含义：不是「提问的艺术」，而是「提供上下文的艺术」\n- 2025 年的最新趋势：从 Prompt Engineering 到 Context Engineering\n- 传统编程与提示词工程的核心差异\n## 先破除一个误解 ​\n\n你可能听过「提示词工程」这个词，觉得它听起来很高深。\n\n很多文章会告诉你：提示词工程是一门「提问的艺术」，需要学习各种「魔法词汇」和「技巧公式」，才能让 AI 给出好答案。\n\n这种说法把事情搞复杂了。\n\n提示词工程的本质很简单：告诉 AI 足够的背景信息，让它理解你想要什么。\n\n没有魔法，没有咒语。只有一个核心原则：你提供的信息越清晰完整，AI 的输出就越符合你的期望。\n\n## 一个帮你理解的比喻 ​\n\n想象你刚招了一个实习生。\n\n这个实习生非常聪明，学习能力极强，几乎什么任务都能完成。但有一个问题：他今天才入职，对你的项目一无所知。\n\n现在你需要让他帮你写一段代码。你会怎么做？\n\n方式 A：直接说「帮我写个登录功能」，然后等着看结果。\n\n方式 B：先花 5 分钟介绍项目背景，说明用的技术栈，解释这个登录功能要实现什么效果，有什么特殊要求，然后再让他动手。\n\n显然，方式 B 的结果会好得多。\n\nAI 就是这个实习生。它的能力很强，但需要你提供足够的「上下文」才能发挥出来。\n\n## 从 Prompt Engineering 到 Context Engineering ​\n\n2025 年，行业内出现了一个有趣的转变。\n\n根据 Gartner 的研究报告，越来越多的 AI 从业者开始用「Context Engineering」（上下文工程）来替代「Prompt Engineering」（提示词工程）这个说法。\n\n这不只是换个名字。它反映了一个认知升级：\n旧认知：Prompt Engineering新认知：Context Engineering关注「怎么问」关注「告诉 AI 什么」寻找「魔法词汇」构建「信息环境」一次性输入系统性设计依赖技巧依赖清晰度\nAnthropic（Claude 的开发公司）的工程师这样解释：\n\n\"与其花时间研究怎么措辞，不如花时间思考 AI 需要知道什么才能完成任务。\"\n\n这意味着什么？\n\n你不需要学习复杂的「提示词技巧」，你需要学习的是：如何把你脑子里的背景信息，清晰地传达给 AI。\n\n## 传统编程 vs 提示词工程 ​\n\n如果你完全没有编程背景，这里有一个对比帮助你理解：\n维度传统编程提示词工程语言编程语言（Python、JavaScript 等）自然语言（中文、英文）精确度必须精确到每个符号允许一定模糊性容错性一个字符错误就报错AI 会尝试理解你的意图核心能力语法和逻辑清晰表达和提供上下文学习曲线陡峭平缓\n传统编程要求你用机器的语言和机器对话；提示词工程允许你用人类的语言和 AI 对话。\n\n但这不意味着你可以随便说说。AI 虽然能理解自然语言，但它理解的质量取决于你表达的质量。\n\n从「精确指令」到「意图传达」，门槛降低了，但清晰表达的能力变得更重要了。\n\n## 你已经具备这项能力 ​\n\n好消息是：提示词工程需要的核心能力，你已经具备了。\n\n还记得第二章学的内容吗？\n\n- 灵魂三问：用户是谁？痛点在哪？为什么选你？\n- 用户画像：描述用户的表面属性、行为习惯、深层动机\n- 减法思维：明确什么要做、什么不做\n这些思考的成果，就是你要告诉 AI 的「上下文」。\n\n第二章教你「想清楚」，本章教你「说清楚」。你在第二章积累的思考，会在本章转化为高质量的 AI 对话。\n\n## 本节要点 ​\n\n✓ 提示词工程的本质是提供上下文，不是寻找魔法词汇。\n\n✓ 2025 年趋势：从「提示词工程」到「上下文工程」，关注点从「怎么问」转向「告诉 AI 什么」。\n\n✓ AI 就像聪明的实习生：能力很强，但需要你提供足够的背景信息。\n\n✓ 第二章的思考成果（灵魂三问、用户画像、减法思维）就是最好的上下文素材。\n\n接下来，我们深入探讨：到底应该告诉 AI 哪些信息？这就是「三层上下文模型」要解决的问题。",
      "word_count": 1739,
      "estimated_time": 3
    },
    {
      "id": "lesson-071",
      "chapter_id": "chapter-03",
      "lesson_number": 2,
      "title": "3.1.2 Context is King：上下文为王",
      "content": "# 3.1.2 Context is King：上下文为王 ​\n\n## 经过本节学习，你将掌握 ​\n\n- 什么是「上下文」：背景信息、约束条件、期望结果\n- 三层上下文模型：项目上下文、任务上下文、个人上下文\n- 上下文窗口的概念：AI 能「记住」多少内容\n- 同一需求，有无上下文的输出差异（真实案例对比）\n## 一个公式 ​\n\n先记住这个公式：\n\nAI 输出的质量 = 你提供的上下文质量 × AI 的能力\n\nAI 的能力是固定的（由模型决定），你能控制的只有上下文质量。\n\n这就是为什么同样一句话，不同人问 AI 会得到完全不同的结果——差异不在于「怎么问」，而在于「问之前告诉了 AI 什么」。\n\n## 什么是上下文 ​\n\n「上下文」听起来有点抽象，让我们拆解一下。\n\n上下文包含三类信息：\n类型说明例子背景信息AI 需要知道的前提条件我在做一个待办清单应用，用 React 开发约束条件AI 需要遵守的限制代码要简洁，不要用外部库期望结果你想要什么样的输出给我一个可以直接复制使用的代码片段\n缺少任何一类，AI 的输出都可能偏离你的期望。\n\n## 三层上下文模型 ​\n\n为了更系统地思考「该告诉 AI 什么」，我们把上下文分为三个层次：\n\n`┌─────────────────────────────────────┐\n│         项目上下文                   │\n│   你在做什么项目？用什么技术？        │\n├─────────────────────────────────────┤\n│         任务上下文                   │\n│   当前要解决什么具体问题？            │\n├─────────────────────────────────────┤\n│         个人上下文                   │\n│   你的技术水平？你的偏好风格？        │\n└─────────────────────────────────────┘`\n### 第一层：项目上下文 ​\n项目上下文回答的问题是：你在做什么？\n\n包含的信息：\n\n- 项目类型（网页应用、数据分析脚本、自动化工具等）\n- 技术栈（如果涉及代码）\n- 项目背景和目标\n- 目标用户是谁（第二章的用户画像派上用场了）\n- 已有的代码规范或风格偏好\n示例：\n\n`我正在开发一个个人待办清单网页应用。\n- 技术栈：React + TypeScript\n- 目标用户：像我一样容易忘事的职场新人\n- 风格要求：代码简洁，组件化设计`\n### 第二层：任务上下文 ​\n任务上下文回答的问题是：你现在要做什么？\n\n包含的信息：\n\n- 当前具体要完成的任务\n- 任务的输入和输出\n- 具体的约束条件\n- 期望的输出格式\n示例：\n\n`当前任务：实现「添加任务」功能\n- 输入：用户在输入框输入任务内容，点击添加按钮\n- 输出：新任务出现在任务列表中\n- 约束：添加后自动清空输入框，空内容不能添加\n- 格式：给我完整的 React 组件代码`\n### 第三层：个人上下文 ​\n个人上下文回答的问题是：你是谁？\n\n包含的信息：\n\n- 你的技术水平\n- 你的学习目标\n- 你的沟通偏好\n示例：\n\n`我是编程初学者，第一次用 React。\n请在关键代码处加上注释，解释为什么这样写。\n如果有更好的实现方式，请告诉我，但先给我一个能跑的版本。`\n## 案例对比：有无上下文的差异 ​\n让我们用小李的待办清单项目，看看上下文如何影响 AI 的输出。\n\n### ❌ 差提示词：缺少上下文 ​\n\n`帮我做一个待办清单`AI 可能的回应：\n\nAI 会开始猜测：\n\n- 用什么技术？HTML/CSS/JS？React？Vue？还是 Python？\n- 做到什么程度？简单的还是复杂的？\n- 要什么功能？只是列表还是要分类、提醒、统计？\n结果往往是：AI 给你一个「通用模板」，可能和你想要的相差甚远。\n\n### ✅ 好提示词：包含三层上下文 ​\n\n`【项目背景】\n我正在开发一个个人待办清单网页应用，帮助像我一样容易忘事的职场新人管理每日任务。\n技术栈：React + TypeScript + Tailwind CSS\n设计原则：极简风格，打开就是今日待办，添加任务要在 3 秒内完成\n\n【当前任务】\n请帮我实现「添加任务」组件：\n- 用户在输入框输入任务内容\n- 点击添加按钮或按回车键，任务添加到列表\n- 添加成功后自动清空输入框\n- 空内容不能添加（显示简单提示）\n\n【输出要求】\n- 给我完整的 React 组件代码\n- 使用 TypeScript，定义好类型\n- 样式用 Tailwind CSS\n- 在关键逻辑处加上注释\n\n【关于我】\n我是 React 初学者，如果有初学者容易踩的坑，请提醒我。`AI 的回应会精准得多：\n\n- 使用你指定的技术栈\n- 实现你要求的具体功能\n- 遵循你的设计原则\n- 代码风格符合你的水平\n## 上下文窗口：AI 能「记住」多少 ​\n\n你可能会问：我能告诉 AI 多少信息？\n\n这涉及到一个概念：上下文窗口。\n\n把 AI 的「记忆」想象成一张餐桌。餐桌有固定大小，你放上去的盘子（信息）不能超过桌面。\n模型上下文窗口大小相当于Claude Opus 4.5200K tokens约 15 万字Gemini 3 Pro1M tokens约 75 万字普通对话场景通常够用无需担心\n对于初学者来说：不用太担心这个限制。日常的项目描述和任务说明，远远不会超出上下文窗口。\n\n但有一个重要提醒：AI 不会跨对话记忆。\n\n如果你开启一个新对话，之前告诉 AI 的所有信息都会「清零」。这就是为什么很多 AI 工具提供了「项目规则」或「系统提示词」功能——让某些上下文持久化，不用每次重复输入。\n\n（这部分会在 3.5 节「迭代对话的艺术」中详细讲解）\n\n## 上下文检查清单 ​\n\n在向 AI 提问之前，用这个清单快速检查：\n\n### 项目上下文 ✓ ​\n\n- [ ] 说明了项目类型和目标\n- [ ] 说明了技术栈（如果涉及代码）\n- [ ] 说明了目标用户是谁\n- [ ] 说明了设计原则或风格偏好\n### 任务上下文 ✓ ​\n\n- [ ] 清晰描述了当前要完成的任务\n- [ ] 说明了输入和输出\n- [ ] 列出了约束条件和边界情况\n- [ ] 指定了期望的输出格式\n### 个人上下文 ✓ ​\n\n- [ ] 说明了自己的技术水平\n- [ ] 告诉 AI 你需要什么样的解释\n- [ ] 说明了特殊偏好（如果有）\n不需要每次都填满所有项。根据任务复杂度，选择必要的信息提供即可。\n\n## 第二章成果的应用 ​\n\n还记得第二章做的那些思考吗？现在它们派上用场了：\n第二章成果对应的上下文层如何使用灵魂三问项目上下文「用户是谁」「痛点在哪」直接写入项目背景用户画像项目上下文描述目标用户的特征和需求MVP 范围任务上下文明确当前阶段要实现什么、不实现什么不做清单任务上下文作为约束条件，防止 AI「加戏」\n小李在第二章完成的思考，可以直接转化为上下文：\n\n`【项目背景 - 来自灵魂三问】\n用户：像我一样容易忘事的职场新人\n痛点：经常遗漏重要任务，被领导批评，感到焦虑\n差异化：比便签纸好用（打开就看到），比复杂工具简单（3 秒添加）\n\n【范围约束 - 来自减法思维】\n第一版只做：添加任务、完成任务、查看今日任务\n不做：分类标签、截止日期、提醒通知、历史统计`\n## 本节要点 ​\n✓ 公式：AI 输出质量 = 上下文质量 × AI 能力。你能控制的是上下文。\n\n✓ 三层上下文模型：\n\n- 项目上下文：你在做什么项目\n- 任务上下文：当前要解决什么问题\n- 个人上下文：你是谁，需要什么\n✓ 上下文窗口：AI 的「记忆容量」有限，但日常使用通常够用。\n\n✓ 第二章的思考成果可以直接转化为高质量的上下文。\n\n下一节，我们来看看初学者最常犯的五个错误——以及如何避免它们。",
      "word_count": 3333,
      "estimated_time": 6
    },
    {
      "id": "lesson-072",
      "chapter_id": "chapter-03",
      "lesson_number": 3,
      "title": "3.1.3 初学者最常犯的五个错误",
      "content": "# 3.1.3 初学者最常犯的五个错误 ​\n\n## 经过本节学习，你将掌握 ​\n\n- 识别五种最常见的提示词错误\n- 理解每种错误「差在哪里」\n- 学会对应的修正方法\n- 获得一个可反复使用的自检清单\n## 为什么要学「错误示范」 ​\n\n与其告诉你「什么是好的提示词」，不如先看看「什么是差的提示词」。\n\n原因很简单：避免错误比追求完美更容易做到，效果也更立竿见影。\n\n下面是初学者最常犯的五个错误，每个错误都配有真实案例和修正方法。\n\n## 错误 1：一次说太多（信息过载） ​\n\n### 问题场景 ​\n\n你想让 AI 帮你做一个待办清单应用，于是一股脑把所有想法都倒出来：\n\n### ❌ 差提示词 ​\n\n`帮我做一个待办清单应用，要有添加任务、删除任务、编辑任务、\n标记完成、设置优先级、设置截止日期、分类标签、搜索功能、\n数据统计、导出功能，还要有暗黑模式，最好能同步到云端，\n支持多设备使用，界面要好看，用 React 写，要有动画效果。`\n### 问题分析 ​\n\n- AI 面对 15+ 个需求，无法判断优先级\n- 容易顾此失彼，每个功能都做得不完整\n- 你收到的代码会非常复杂，难以理解和修改\n- 违背了第二章学的「减法思维」\n### ✅ 修正方法：分步骤拆解 ​\n\n```\n【第一步：先做核心功能】\n帮我实现待办清单的添加任务功能。\n要求：\n- 输入框 + 添加按钮\n- 按回车也能添加\n- 添加后清空输入框\n- 空内容不能添加\n\n技术栈：React + TypeScript\n先只做这一个功能，其他功能后面再加。\n```\n\n### 📌 一句话法则 ​\n一次只让 AI 做一件事。复杂任务拆成多轮对话。\n\n## 错误 2：一次说太少（上下文缺失） ​\n\n### 问题场景 ​\n\n你想让 AI 写一段代码，但只说了最简单的需求：\n\n### ❌ 差提示词 ​\n\n`写一个登录页面`\n### 问题分析 ​\n\n- AI 不知道用什么技术（HTML？React？Vue？）\n- AI 不知道要什么样式（简约？炫酷？企业风？）\n- AI 不知道有什么功能（只有登录？还要注册？忘记密码？）\n- AI 不知道你的技术水平（给你复杂代码你看不懂）结果：AI 只能给你一个「通用模板」，大概率不是你想要的。\n\n### ✅ 修正方法：补充三层上下文 ​\n\n`【项目背景】\n我在做一个个人博客网站，需要一个简单的管理员登录页面。\n技术栈：Next.js + Tailwind CSS\n风格：简约干净，白色背景，居中卡片式布局\n\n【功能需求】\n- 只需要用户名和密码两个输入框\n- 一个登录按钮\n- 不需要注册、忘记密码等功能\n- 输入框要有基本的校验提示（不能为空）\n\n【关于我】\n我是前端初学者，请给我完整可运行的代码，关键部分加注释。`\n### 📌 一句话法则 ​\n把 AI 当作刚入职的实习生：你不说清楚，它就只能猜。\n\n## 错误 3：期待 AI 读心（不说清楚目标） ​\n\n### 问题场景 ​\n\n你让 AI 帮你优化代码，但没说「优化」是什么意思：\n\n### ❌ 差提示词 ​\n\n`帮我优化一下这段代码：\n[粘贴了一段代码]`\n### 问题分析 ​\n「优化」可以有很多种理解：\n\n- 让代码跑得更快（性能优化）？\n- 让代码更容易读（可读性优化）？\n- 让代码更短（精简代码）？\n- 让代码更安全（安全性优化）？\n- 让代码更易维护（架构优化）？\nAI 不知道你想要哪种「优化」，只能按自己的理解来。\n\n### ✅ 修正方法：明确目标和验收标准 ​\n\n`帮我优化这段代码的可读性：\n\n[粘贴代码]\n\n优化目标：\n1. 让其他开发者能快速看懂这段代码在做什么\n2. 变量命名更清晰\n3. 添加必要的注释\n4. 如果有重复逻辑，提取成函数\n\n请保持功能不变，只改善代码结构。`\n### 📌 一句话法则 ​\n说清楚「什么算完成」。给 AI 一个可以对照检查的验收标准。\n\n## 错误 4：忽视格式要求（让 AI 自由发挥） ​\n\n### 问题场景 ​\n\n你让 AI 整理一些信息，但没说想要什么格式：\n\n### ❌ 差提示词 ​\n\n`帮我整理一下 React 常用的 Hooks`\n### 问题分析 ​\nAI 可能给你：\n\n- 一大段文字描述\n- 或者一个简单列表\n- 或者过于详细的教程\n- 或者只有名字没有解释\n每次结果都不一样，可能都不是你想要的格式。\n\n### ✅ 修正方法：指定输出格式 ​\n\n`帮我整理 React 最常用的 5 个 Hooks。\n\n输出格式：\n| Hook 名称 | 一句话解释 | 使用场景 |\n|----------|-----------|---------|\n\n要求：\n- 只列最常用的 5 个，不要太多\n- 解释要通俗易懂，初学者能看懂\n- 使用场景给出具体例子`\n### 📌 一句话法则 ​\n想要什么格式，就先画出格式的「样子」给 AI 看。\n\n## 错误 5：不做约束（AI 容易「加戏」） ​\n\n### 问题场景 ​\n\n你只要一个简单功能，但 AI 给了你一堆额外的东西：\n\n### ❌ 差提示词 ​\n\n`帮我写一个显示当前时间的组件`\n### AI 可能的「加戏」 ​\n\n- 加上了时区选择功能\n- 加上了 12/24 小时切换\n- 加上了自定义格式功能\n- 加上了暗黑模式适配\n- 用了你没听说过的第三方库你只想要一个简单的时钟，却收到了一个「全功能时间管理器」。\n\n### ✅ 修正方法：用「不做清单」约束范围 ​\n\n`帮我写一个显示当前时间的 React 组件。\n\n需要：\n- 显示小时:分钟:秒（如 14:30:45）\n- 每秒自动更新\n\n不需要：\n- 不要时区选择\n- 不要格式切换\n- 不要用任何第三方库\n- 不要添加样式（我自己加）\n\n给我最简单的实现，越简单越好。`\n### 📌 一句话法则 ​\n明确告诉 AI「不要什么」，和「要什么」同样重要。\n\n## 五大错误速查表 ​\n错误症状修正法则一次说太多AI 输出很长但每个功能都不完整一次只让 AI 做一件事一次说太少AI 给的是「通用模板」不符合你的场景补充三层上下文期待读心AI 的理解和你想的不一样说清楚验收标准忽视格式输出格式每次都不一样先画出格式的「样子」不做约束AI「加戏」，做了很多你不需要的用「不做清单」限制范围\n## 提问前自检清单 ​\n\n在按下发送键之前，快速过一遍：\n\n- [ ] 范围是否聚焦：这次只让 AI 做一件事？\n- [ ] 上下文是否充足：AI 有足够的背景信息吗？\n- [ ] 目标是否明确：说清楚了「什么算完成」？\n- [ ] 格式是否指定：告诉 AI 想要什么样的输出格式？\n- [ ] 边界是否清晰：说明了「不要什么」？\n不需要每次都完美，但避开这五个常见错误，你的 AI 对话质量会提升一大截。\n\n## 本节要点 ​\n\n✓ 错误 1：一次说太多 → 分步骤拆解，一次只做一件事\n\n✓ 错误 2：一次说太少 → 补充三层上下文，把 AI 当实习生\n\n✓ 错误 3：期待读心 → 明确目标，给出验收标准\n\n✓ 错误 4：忽视格式 → 先画出格式的「样子」\n\n✓ 错误 5：不做约束 → 用「不做清单」限制 AI 的发挥空间\n\n## 下一步 ​\n\n你已经掌握了提示词工程的基础原理，知道了该告诉 AI 什么，也知道了要避开哪些坑。\n\n但你可能还在想：有没有更系统的方法，让我每次都能写出高质量的提示词？\n\n下一节，我们会学习结构化提示词框架——一套可以直接套用的「公式」，让你从「随便说说」升级到「有章可循」。",
      "word_count": 3130,
      "estimated_time": 6
    },
    {
      "id": "lesson-073",
      "chapter_id": "chapter-03",
      "lesson_number": 4,
      "title": "3.2.1 为什么需要框架",
      "content": "# 3.2.1 为什么需要框架 ​\n\n## 经过本节学习，你将掌握 ​\n\n- 理解框架的核心价值：减少思考负担，提高输出稳定性\n- 明确框架不是限制，而是起点\n- 知道什么时候用框架，什么时候灵活发挥\n- 理解故事化 Prompt 与结构化框架的适用场景差异\n## 一个真实的困扰 ​\n\n小李学完 3.1 节后，知道了要给 AI 提供上下文。但每次写提示词时，他还是会陷入这样的状态：\n\n\"我知道要告诉 AI 项目背景...等等，还有什么来着？技术栈、约束条件、输出格式...每次都要从头想一遍，好累。\"\n\n这不是小李的问题，而是认知负担的问题。\n\n人脑的工作记忆容量有限。当你同时要思考\"说什么\"和\"怎么说\"时，很容易顾此失彼——要么遗漏关键信息，要么表述混乱。\n\n框架的价值，就是把\"怎么说\"变成固定格式，让你专注于\"说什么\"。\n\n## 框架的三个核心价值 ​\n\n### 1. 减少思考负担 ​\n\n没有框架时，你需要每次从零思考：\n\n- 该说什么？\n- 先说什么后说什么？\n- 有没有遗漏？\n有了框架后，你只需要填空：\n\n- Situation（情境）→ 填入项目背景\n- Challenge（挑战）→ 填入当前问题\n- ...以此类推\n框架把\"开放式问题\"变成了\"填空题\"，认知负担大幅降低。\n\n### 2. 提高输出稳定性 ​\n\n斯坦福大学人机交互研究院的研究表明：使用结构化框架的提示词，任务完成准确率比随机提问高出 30% 以上。\n\n原因很简单：框架确保了关键信息不遗漏。就像飞行员起飞前的检查清单，不是因为他们记不住，而是因为清单能避免人为疏忽。\n\n### 3. 降低沟通成本 ​\n\n当你和 AI 建立了固定的\"沟通协议\"，AI 能更快理解你的意图。\n\n这就像和老同事合作：你们有默契的沟通方式，不需要每次都从头解释。框架就是你和 AI 之间的\"默契\"。\n\n## 框架不是限制，而是起点 ​\n\n你可能会担心：用框架会不会太死板？\n\n答案是：框架是起点，不是终点。\n阶段做法初学阶段严格按框架填写，确保不遗漏熟练阶段根据任务复杂度简化或扩展高手阶段框架内化成直觉，自然地组织信息\n就像学开车：一开始要死记\"打灯、看镜、转向\"的顺序，熟练后这些动作会变成本能。\n\n## 什么时候用框架，什么时候自由发挥 ​\n场景建议原因复杂的技术任务用完整框架防止遗漏关键约束简单的快速提问用精简框架或自由发挥节省时间第一次做某类任务用完整框架帮助你理清思路重复做过的任务可以简化你已经知道关键要素AI 输出不符合预期回到框架检查定位遗漏了什么信息\n一个实用建议：当你不确定时，用框架；当框架感觉多余时，简化它。\n\n## 故事化 Prompt vs 结构化框架 ​\n\n第二章介绍的故事化 Prompt 和本节的结构化框架，各有适用场景：\n对比维度故事化 Prompt结构化框架核心驱动情感和痛点逻辑和约束表达方式叙事性，像讲故事列表式，像填表格适合任务产品设计、用户需求沟通代码实现、技术任务AI 理解重点用户是谁、为什么需要怎么做、有什么限制典型场景\"帮我设计一个待办清单\"\"帮我实现添加任务功能\"\n实际使用中，两者可以组合：\n\n- 先用故事化 Prompt 描述整体需求（产品层面）\n- 再用结构化框架拆解具体任务（技术层面）\n例如：\n\n- 第一轮对话：用故事化 Prompt 描述\"我是谁、我的痛点、我想要什么\"\n- 第二轮对话：用 S.C.A.F.F. 框架描述\"当前要实现的具体功能\"\n## 本节要点 ​\n\n✓ 框架的价值：减少思考负担、提高输出稳定性、降低沟通成本\n\n✓ 框架不是限制：初学时严格遵循，熟练后灵活调整\n\n✓ 选择原则：复杂任务用完整框架，简单任务可以简化\n\n✓ 与故事化 Prompt 的关系：情感驱动 vs 逻辑驱动，可以组合使用\n\n下一节，我们来学习第一个结构化框架：S.C.A.F.F.——一个适合技术开发任务的完整框架。",
      "word_count": 1625,
      "estimated_time": 3
    },
    {
      "id": "lesson-074",
      "chapter_id": "chapter-03",
      "lesson_number": 5,
      "title": "3.2.2 S.C.A.F.F. 框架（推荐框架）",
      "content": "# 3.2.2 S.C.A.F.F. 框架（推荐框架） ​\n\n## 经过本节学习，你将掌握 ​\n\n- S.C.A.F.F. 框架的五个要素及其含义\n- 如何用这个框架描述一个技术开发任务\n- 框架的精简版，适合日常快速使用\n- 获得可直接复制的提示词模板\n## 框架结构 ​\n\nS.C.A.F.F. 是五个英文单词的首字母缩写：\n字母英文中文核心问题SSituation情境你在做什么项目？当前状态如何？CChallenge挑战当前要解决的具体问题是什么？AAudience受众代码/产出给谁用？谁来维护？FFormat格式期望 AI 输出什么格式？FFoundations基础必须遵守的约束和原则是什么？\n这个框架的设计逻辑是：先给背景，再说问题，然后明确对象，最后约束边界。\n\n## 五要素详解 ​\n\n### S - Situation（情境） ​\n\n回答：你在做什么？当前进展如何？\n\n填写内容：\n\n- 项目类型和目标\n- 使用的技术栈\n- 当前的开发阶段\n- 已有的代码结构或设计决策\n填写技巧：想象你在向一个刚加入项目的同事介绍情况。\n\n### C - Challenge（挑战） ​\n\n回答：当前具体要解决什么问题？\n\n填写内容：\n\n- 要实现的功能或要修复的问题\n- 输入是什么，输出是什么\n- 具体的业务逻辑\n填写技巧：一句话说清楚\"做完这件事，什么状态变成什么状态\"。\n\n### A - Audience（受众） ​\n\n回答：产出给谁用？\n\n填写内容：\n\n- 代码的使用者是谁（用户？其他开发者？）\n- 代码的维护者是谁（你自己？团队？）\n- 使用者/维护者的技术水平\n填写技巧：这决定了代码复杂度和注释详细程度。\n\n### F - Format（格式） ​\n\n回答：期望 AI 输出什么形式的结果？\n\n填写内容：\n\n- 完整代码还是代码片段\n- 需要什么文件格式\n- 是否需要注释\n- 是否需要使用说明\n填写技巧：越具体越好。\"给我代码\"不如\"给我一个完整的 React 组件文件，包含 TypeScript 类型定义\"。\n\n### F - Foundations（基础） ​\n\n回答：有什么必须遵守的约束？\n\n填写内容：\n\n- 技术约束（必须/不能用某个库）\n- 性能约束（响应时间、内存限制）\n- 风格约束（命名规范、代码风格）\n- 安全约束（敏感数据处理）\n填写技巧：用第二章的\"不做清单\"思维——明确告诉 AI 什么不能做。\n\n## 完整示例：登录页面 ​\n\n来看一个具体案例：你需要 AI 帮你实现一个登录页面。\n\n### ❌ 差提示词 ​\n\n`帮我做一个登录页面`问题：AI 不知道用什么技术、什么风格、要哪些功能、有什么限制。结果大概率是一个\"通用模板\"，和你的项目格格不入。\n\n### ✅ 用 S.C.A.F.F. 框架改写 ​\nmarkdown\n`【Situation - 情境】\n我正在开发一个个人博客系统的管理后台。\n技术栈：Next.js 16 + TypeScript + Tailwind CSS\n当前进度：首页和文章列表页已完成，现在需要添加登录功能。\n设计风格：极简风格，参考 Notion 的登录页面。\n\n【Challenge - 挑战】\n实现管理员登录页面：\n- 表单包含：邮箱输入框、密码输入框、登录按钮\n- 点击登录后，验证格式（邮箱格式、密码不为空）\n- 格式错误时，在对应输入框下方显示红色提示\n- 暂时不需要真正的后端验证，先做前端界面和交互\n\n【Audience - 受众】\n- 用户：只有我一个人（博客管理员）\n- 代码维护者：我自己，React 初学者\n- 请在关键逻辑处添加注释，帮助我理解\n\n【Format - 格式】\n请提供：\n1. 完整的登录页面组件代码（单文件）\n2. 包含 TypeScript 类型定义\n3. 样式使用 Tailwind CSS\n4. 文件命名：LoginPage.tsx\n\n【Foundations - 基础约束】\n- 不使用任何 UI 组件库（如 shadcn/ui、Ant Design）\n- 不使用第三方表单库（如 React Hook Form）\n- 状态管理用 React 原生的 useState\n- 响应式设计：移动端和桌面端都要适配`\n### 输出差异对比 ​\n方面差提示词的可能输出S.C.A.F.F. 的可能输出技术栈可能是纯 HTML 或 Vue确定是 Next.js + TS + Tailwind功能范围可能包含注册、忘记密码只有登录，符合当前需求代码复杂度可能用了你不熟悉的库用 useState，初学者友好注释可能没有关键逻辑有注释风格随机风格极简风格，参考 Notion\n## 待办清单案例：添加任务功能 ​\n延续第二章小李的项目，用 S.C.A.F.F. 框架描述\"添加任务\"功能：\nmarkdown\n`【Situation - 情境】\n我在做一个个人待办清单网页应用。\n技术栈：React + TypeScript + Tailwind CSS\n目标用户：像我一样容易忘事的职场新人\n设计原则：极简，打开就是今日待办，添加任务 3 秒内完成\n当前进度：项目刚初始化，还没有任何功能代码\n\n【Challenge - 挑战】\n实现\"添加任务\"功能：\n- 用户在输入框输入任务内容\n- 按回车键或点击添加按钮，任务添加到列表\n- 添加成功后自动清空输入框并聚焦\n- 空内容不能添加，输入框轻微抖动提示\n\n【Audience - 受众】\n- 用户：我自己，希望操作越简单越好\n- 维护者：我自己，React 初学者\n- 请解释为什么用这种实现方式\n\n【Format - 格式】\n请提供：\n1. AddTask 组件代码（处理输入和添加）\n2. TaskList 组件代码（展示任务列表）\n3. 简单的组件使用说明\n\n【Foundations - 基础约束】\n- 任务数据暂存在组件 state，不需要持久化\n- 不用任何状态管理库（Redux、Zustand 等）\n- 样式用 Tailwind，保持简洁\n- 每个任务只需要：内容文本 + 完成状态`\n## 精简版：S.C.F. 三要素 ​\n日常快速使用时，可以只保留三个核心要素：\n要素必填原因S - Situation没有背景，AI 只能猜C - Challenge这是你要解决的问题F - Foundations约束决定了输出边界\n精简版模板：\nmarkdown\n`【背景】\n[项目类型] + [技术栈] + [当前状态]\n\n【任务】\n[具体要做什么]\n\n【约束】\n- [必须遵守的限制1]\n- [必须遵守的限制2]`精简版示例：\nmarkdown\n`【背景】\nReact + TS 的待办清单项目，已完成基础结构\n\n【任务】\n实现删除任务功能：点击任务右侧的删除图标，该任务从列表中移除\n\n【约束】\n- 删除前显示确认提示\n- 用 Tailwind CSS\n- 删除动画：淡出效果`\n## 可复制的完整模板 ​\nmarkdown\n```\n【Situation - 情境】\n项目类型：\n技术栈：\n当前进度：\n设计风格/原则：\n\n【Challenge - 挑战】\n要实现的功能：\n- \n- \n- \n输入：\n输出：\n\n【Audience - 受众】\n用户是谁：\n维护者是谁：\n技术水平：\n\n【Format - 格式】\n期望输出：\n- [ ] 完整代码文件\n- [ ] 代码片段\n- [ ] 包含注释\n- [ ] 包含使用说明\n文件命名：\n\n【Foundations - 基础约束】\n必须：\n- \n- \n不能：\n- \n-\n```\n\n## 常见填写误区 ​\n误区问题正确做法Situation 写太长AI 会迷失在细节中只写与当前任务相关的背景Challenge 不具体\"优化代码\"太模糊说清楚优化什么方面忘记写 AudienceAI 不知道代码给谁看初学者要求注释，高手可以省略Format 只写\"给我代码\"输出格式随机指定文件类型、是否要注释Foundations 只写\"要做什么\"AI 可能\"加戏\"同时写清楚\"不要什么\"\n## 本节要点 ​\n✓ S.C.A.F.F. 五要素：Situation（情境）、Challenge（挑战）、Audience（受众）、Format（格式）、Foundations（基础）\n\n✓ 填写逻辑：先给背景 → 再说问题 → 明确对象 → 约束边界\n\n✓ 精简版 S.C.F.：日常快速使用，保留背景、任务、约束三要素\n\n✓ 关键技巧：\"不做清单\"和\"做清单\"同样重要\n\n下一节，我们学习一个更轻量的框架：R.G.C.——适合快速提问和简单任务。",
      "word_count": 3581,
      "estimated_time": 7
    },
    {
      "id": "lesson-075",
      "chapter_id": "chapter-03",
      "lesson_number": 6,
      "title": "3.2.3 Role → Goal → Constraints 框架（简化版）",
      "content": "# 3.2.3 Role → Goal → Constraints 框架（简化版） ​\n\n## 经过本节学习，你将掌握 ​\n\n- R.G.C. 框架的三个要素及其含义\n- 什么场景适合用这个精简框架\n- S.C.A.F.F. 和 R.G.C. 的选择标准\n- 知道何时从 R.G.C. 升级到 S.C.A.F.F.\n## 框架结构 ​\n\nR.G.C. 是三个英文单词的首字母缩写：\n字母英文中文核心问题RRole角色让 AI 扮演什么身份？GGoal目标要完成什么任务？CConstraints约束有哪些限制条件？\n这个框架的设计逻辑是：定身份 → 说目标 → 划边界。\n\n相比 S.C.A.F.F.，R.G.C. 更轻量，适合快速提问和相对简单的任务。\n\n## 三要素详解 ​\n\n### R - Role（角色） ​\n\n让 AI 进入特定的\"专家模式\"。\n\n为什么角色很重要：同样的问题，程序员视角和产品经理视角的回答会很不同。指定角色可以让 AI 的输出更符合你的期望。\n\n常用角色示例：\n\n- \"你是一个资深的 React 开发者\"\n- \"你是一个注重代码可读性的 Python 工程师\"\n- \"你是一个擅长数据可视化的分析师\"\n- \"你是一个对初学者友好的编程导师\"\n填写技巧：角色描述可以包含专长、风格偏好、经验水平。\n\n### G - Goal（目标） ​\n\n说清楚要完成什么任务。\n\n填写内容：\n\n- 具体的任务描述\n- 期望的输出结果\n- 成功的标准\n填写技巧：用\"动词 + 名词\"的结构，如\"实现一个函数\"、\"分析这段代码\"、\"解释这个概念\"。\n\n### C - Constraints（约束） ​\n\n划定任务的边界。\n\n填写内容：\n\n- 技术限制（语言、框架、库）\n- 格式要求（长度、风格）\n- 内容限制（不要什么）\n填写技巧：约束越明确，AI \"加戏\"的空间越小。\n\n## 完整示例：代码重构 ​\n\n### 任务场景 ​\n\n你有一段能用但很乱的代码，想让 AI 帮你重构。\n\n### ❌ 差提示词 ​\n\n`帮我优化这段代码：\n[粘贴代码]`问题：\"优化\"可以有很多种理解——性能优化？可读性优化？架构优化？AI 不知道你想要哪种。\n\n### ✅ 用 R.G.C. 框架改写 ​\nmarkdown\n`【Role - 角色】\n你是一个注重代码可读性和可维护性的 Python 工程师。\n\n【Goal - 目标】\n重构下面这段代码，提高可读性：\n- 让变量命名更清晰\n- 把重复逻辑提取成函数\n- 添加必要的注释\n\n```python\ndef f(l):\n    r=[]\n    for i in l:\n        if i>0:\n            r.append(i*2)\n    return r`【Constraints - 约束】\n\n- 保持功能完全不变\n- 不使用列表推导式（我还没学到那部分）\n- 不需要添加类型注解\n- 注释用中文\n`\n### AI 的可能输出\n\n```python\ndef double_positive_numbers(numbers):\n    \"\"\"\n    从列表中筛选正数，并将每个正数翻倍\n    \n    参数：numbers - 输入的数字列表\n    返回：包含翻倍后正数的新列表\n    \"\"\"\n    result = []\n    \n    for number in numbers:\n        # 只处理正数\n        if number > 0:\n            doubled = number * 2\n            result.append(doubled)\n    \n    return result`\n## 更多 R.G.C. 示例 ​\n\n### 示例一：解释概念 ​\nmarkdown\n```\n【Role】你是一个对编程初学者友好的导师\n\n【Goal】用通俗的语言解释什么是\"回调函数\"\n\n【Constraints】\n- 不要用其他技术术语\n- 举一个生活中的类比\n- 控制在 200 字以内\n```\n\n### 示例二：生成测试数据 ​\nmarkdown\n```\n【Role】你是一个熟悉电商业务的数据工程师\n\n【Goal】生成 10 条模拟的订单数据\n\n【Constraints】\n- 格式：JSON 数组\n- 每条包含：订单ID、用户名、商品名、金额、下单时间\n- 金额范围：50-500 元\n- 时间范围：2024 年 1 月\n```\n\n### 示例三：代码审查 ​\nmarkdown\n```\n【Role】你是一个严格但友善的代码审查员\n\n【Goal】审查这段代码，指出潜在问题：\n[粘贴代码]\n\n【Constraints】\n- 只关注安全性和性能问题\n- 不评价代码风格\n- 每个问题给出修复建议\n- 问题数量不超过 5 个\n```\n\n## S.C.A.F.F. vs R.G.C.：同一任务的两种写法 ​\n假设任务是：为待办清单添加\"完成任务\"功能。\n\n### R.G.C. 写法（快速版） ​\nmarkdown\n`【Role】你是一个 React 开发者\n\n【Goal】实现点击任务时将其标记为已完成的功能\n\n【Constraints】\n- 用 TypeScript\n- 完成的任务显示删除线\n- 用 Tailwind CSS`\n### S.C.A.F.F. 写法（完整版） ​\nmarkdown\n```\n【Situation】\n待办清单项目，React + TS + Tailwind，已有 AddTask 和 TaskList 组件\n\n【Challenge】\n实现\"完成任务\"功能：\n- 点击任务文本，切换完成/未完成状态\n- 完成的任务显示删除线和浅灰色\n- 可以重复点击切换状态\n\n【Audience】\n我是 React 初学者，请解释状态管理的逻辑\n\n【Format】\n更新 TaskList 组件代码，添加必要注释\n\n【Foundations】\n- 用 useState 管理状态\n- 不用任何动画库\n- 样式变化要有 0.2s 过渡效果\n```\n\n### 选择标准 ​\n场景推荐框架对项目背景熟悉，任务简单明确R.G.C.新项目或复杂任务，需要详细说明背景S.C.A.F.F.快速提问，只是想验证一个想法R.G.C.正式开发，代码要进入项目S.C.A.F.F.AI 输出不理想，需要增加约束从 R.G.C. 升级到 S.C.A.F.F.\n## 何时从 R.G.C. 升级到 S.C.A.F.F. ​\n当你用 R.G.C. 提问后，发现 AI 的输出不符合预期，这通常是信息不足的信号。\n\n常见信号：\n问题表现可能缺少的信息升级方向技术栈不对项目背景添加 Situation功能太简单/太复杂具体需求补充 Challenge代码风格不匹配维护者信息添加 Audience输出格式混乱格式要求添加 Format\n升级示例：\nmarkdown\n`# 原来的 R.G.C.\n【Role】React 开发者\n【Goal】实现表单验证\n【Constraints】不用第三方库\n\n# AI 输出了一个过于复杂的验证方案\n\n# 升级为 S.C.A.F.F.\n【Situation】个人博客项目，只有一个简单的登录表单\n【Challenge】验证邮箱格式和密码非空，错误时显示提示\n【Audience】我是初学者，请用最简单的方式实现\n【Format】完整组件代码 + 中文注释\n【Foundations】只用 useState，不用 useReducer 或其他复杂模式`\n## 可复制的 R.G.C. 模板 ​\nmarkdown\n```\n【Role - 角色】\n你是一个 [专长/风格描述] 的 [职业身份]\n\n【Goal - 目标】\n[动词] [具体任务描述]\n\n【Constraints - 约束】\n- [限制条件1]\n- [限制条件2]\n- [限制条件3]\n```\n\n## 本节要点 ​\n✓ R.G.C. 三要素：Role（角色）→ Goal（目标）→ Constraints（约束）\n\n✓ 适用场景：快速提问、简单任务、对项目已有清晰认知\n\n✓ 与 S.C.A.F.F. 的关系：R.G.C. 是精简版，输出不理想时可升级\n\n✓ 升级信号：当 AI 输出不符合预期，检查是否缺少背景、需求、受众或格式信息\n\n下一节，我们介绍一个\"万能模板\"——当你不确定用哪个框架时的保底选择。",
      "word_count": 3518,
      "estimated_time": 7
    },
    {
      "id": "lesson-076",
      "chapter_id": "chapter-03",
      "lesson_number": 7,
      "title": "3.2.4 万能提示词模板",
      "content": "# 3.2.4 万能提示词模板 ​\n\n## 经过本节学习，你将掌握 ​\n\n- 一个适用于大多数场景的通用模板\n- 完整版和精简版的使用场景\n- 三种不同场景的填写示例\n- 让模板更好用的实用技巧\n## 为什么需要\"万能模板\" ​\n\nS.C.A.F.F. 适合技术开发，R.G.C. 适合快速提问，但有些任务不那么容易归类：\n\n- 既不是纯技术，也不是简单提问\n- 不确定该用哪个框架\n- 想要一个\"怎么填都不会错\"的通用方案\n这就是万能模板存在的意义：覆盖面广，怎么填都不会太差。\n\n## 模板结构 ​\n\n万能模板包含七个要素，按重要性排序：\n序号要素必填程度作用1角色推荐让 AI 进入专家模式2背景必填提供上下文信息3任务必填说清楚要做什么4要求推荐明确成功标准5约束推荐划定边界，防止\"加戏\"6格式视情况指定输出形式7示例可选用例子教 AI 你想要什么\n## 完整版模板 ​\nmarkdown\n`你是一个 [角色描述]。\n\n## 背景\n[项目/任务的背景信息]\n\n## 任务\n[具体要做什么]\n\n## 要求\n- [要求1：具体的成功标准]\n- [要求2]\n- [要求3]\n\n## 约束\n- [不能做什么1]\n- [不能做什么2]\n\n## 输出格式\n[期望的输出形式]\n\n## 示例（可选）\n[一个理想输出的示例，帮助 AI 理解你的期望]`\n## 精简版模板 ​\n日常使用时，可以保留核心三要素：\nmarkdown\n`你是一个 [角色]。\n\n背景：[一句话说明情境]\n\n任务：[要做什么]\n\n要求：\n- [要求1]\n- [要求2]`选择标准：\n任务类型推荐版本重要的、会进入项目的代码完整版快速验证想法、临时查询精简版第一次做某类任务完整版（帮你理清思路）重复做过的任务精简版\n## 场景示例 ​\n\n### 场景一：产品开发（待办清单） ​\nmarkdown\n`你是一个擅长 React 和用户体验设计的前端开发者。\n\n## 背景\n我在做一个个人待办清单应用，目标用户是容易忘事的职场新人。\n技术栈：React + TypeScript + Tailwind CSS\n设计原则：极简，添加任务要在 3 秒内完成\n\n## 任务\n实现任务的\"拖拽排序\"功能，让用户可以通过拖拽调整任务顺序。\n\n## 要求\n- 拖拽时被拖动的任务半透明\n- 放置位置有明显的视觉指示线\n- 拖拽完成后顺序立即更新\n- 移动端也能用（长按触发拖拽）\n\n## 约束\n- 不使用第三方拖拽库（如 react-beautiful-dnd）\n- 用原生 HTML5 拖拽 API\n- 代码要有详细注释，我是拖拽 API 的初学者\n\n## 输出格式\n完整的 React 组件代码，包含：\n1. 组件文件（TypeScript）\n2. 关键逻辑的中文注释\n3. 简单的使用说明`\n### 场景二：数据分析 ​\nmarkdown\n```\n你是一个擅长数据可视化的分析师，特别关注如何让非技术人员也能看懂数据。\n\n## 背景\n我是电商公司的运营，手里有三个月的销售数据（Excel 格式）。\n老板每周一早上只有 15 分钟看报告，上次的报告太长被批评了。\n\n## 任务\n帮我设计一份 Q3 销售分析报告的结构。\n\n## 要求\n- 老板能在 5 分钟内抓住重点\n- 第一页就能看到最重要的结论\n- 有明确的行动建议，不只是展示数据\n- 图表要简洁，一图说明一件事\n\n## 约束\n- 报告不超过 5 页\n- 不使用复杂的统计术语\n- 颜色使用公司品牌色（蓝色系）\n\n## 输出格式\n1. 报告的页面结构（每页标题和内容要点）\n2. 推荐的图表类型及原因\n3. 建议的配色方案\n```\n\n### 场景三：自动化脚本 ​\nmarkdown\n```\n你是一个注重代码健壮性的 Python 工程师。\n\n## 背景\n我是公司财务，每周五要汇总 5 个部门的周报 Excel。\n当前流程：手动打开 5 个文件 → 复制数据 → 粘贴到汇总表 → 调整格式\n每周花 2 小时，经常出错要反复检查。\n\n## 任务\n写一个 Python 脚本，自动完成这个汇总工作。\n\n## 要求\n- 读取指定文件夹下所有 .xlsx 文件\n- 每个文件提取\"汇总\"工作表的 A1:E20 区域\n- 合并到一个新的 Excel，每个部门一个工作表\n- 运行结束后显示处理了多少个文件\n\n## 约束\n- 只用 openpyxl 库（公司电脑已安装）\n- 如果文件格式不对，跳过并记录错误，不要中断整个流程\n- 代码要有中文注释，我是 Python 初学者\n\n## 输出格式\n完整的 Python 脚本，可以直接运行\n\n## 示例\n文件夹结构：\n```\n/周报/ ├── 销售部_第1周.xlsx ├── 市场部_第1周.xlsx ├── ...\n\n`输出文件：汇总_2024年第1周.xlsx`\n## 让模板更好用的技巧 ​\n\n### 技巧一：先写\"任务\"，再补其他 ​\n很多人会卡在\"背景\"不知道怎么写。建议：\n\n- 先在\"任务\"里写你最想说的\n- 然后问自己：AI 理解这个任务需要知道什么背景？\n- 把答案填入\"背景\"\n### 技巧二：\"约束\"用\"不要\"开头 ​\n\n\"约束\"最容易写成\"要求\"的重复。记住：\n\n- 要求：告诉 AI \"要什么\"\n- 约束：告诉 AI \"不要什么\"\n约束的句子尽量用\"不要\"、\"不使用\"、\"不需要\"开头，这样更容易区分。\n\n### 技巧三：示例胜过千言万语 ​\n\n当你发现很难用语言描述期望的输出时，直接给一个示例：\nmarkdown\n`## 示例\n输入：\"2024-01-15\"\n期望输出：\"2024年1月15日 星期一\"`一个精准的示例，比三段描述更有效。\n\n## 本节要点 ​\n\n✓ 万能模板七要素：角色、背景、任务、要求、约束、格式、示例\n\n✓ 完整版 vs 精简版：重要任务用完整版，快速验证用精简版\n\n✓ 填写顺序建议：先写任务，再补背景，最后加约束\n\n✓ 关键区分：要求说\"要什么\"，约束说\"不要什么\"\n\n下一节是本章最后一部分：框架选择指南——帮你快速判断什么场景用什么框架。",
      "word_count": 2528,
      "estimated_time": 5
    },
    {
      "id": "lesson-077",
      "chapter_id": "chapter-03",
      "lesson_number": 8,
      "title": "3.2.5 框架选择指南",
      "content": "# 3.2.5 框架选择指南 ​\n\n## 经过本节学习，你将掌握 ​\n\n- 根据任务类型快速选择合适的框架\n- 理解各框架之间的关系\n- 获得一个提问前的快速检查清单\n- 知道何时该从一个框架切换到另一个\n## 框架速查表 ​\n场景推荐框架原因需要表达用户痛点和情感故事化 Prompt（第二章）情感共鸣更强，AI 能理解\"为什么\"复杂的技术开发任务S.C.A.F.F.结构完整，约束清晰快速简单提问R.G.C.简洁高效，减少输入不确定用哪个框架万能模板覆盖面广，不容易出错代码审查、重构R.G.C.代码本身提供了上下文需求描述、产品设计故事化 + S.C.A.F.F.先讲故事，再拆任务数据分析、报告生成万能模板任务类型多样，通用性强学习概念、寻求解释R.G.C.简单直接\n## 决策流程图 ​\n\n简化版决策：\n\n- 任务简单 → R.G.C.\n- 任务复杂 + 技术开发 → S.C.A.F.F.\n- 任务复杂 + 非技术 → 万能模板\n- 需要表达用户故事 → 故事化 Prompt\n- 不确定 → 万能模板\n## 框架关系图 ​\n\n四种框架不是互相替代，而是互相补充：\n\n`┌─────────────────────────────────────────────────────────┐\n│                     万能模板                              │\n│            （最通用，覆盖面广，什么都能用）                   │\n│  ┌─────────────────────┐  ┌─────────────────────┐      │\n│  │    S.C.A.F.F.       │  │    故事化 Prompt     │      │\n│  │  （技术开发专用）     │  │   （情感沟通专用）    │      │\n│  │                     │  │                     │      │\n│  │  ┌─────────────┐    │  │                     │      │\n│  │  │   R.G.C.    │    │  │                     │      │\n│  │  │ （快速简化版）│    │  │                     │      │\n│  │  └─────────────┘    │  │                     │      │\n│  └─────────────────────┘  └─────────────────────┘      │\n└─────────────────────────────────────────────────────────┘`\n- R.G.C. 是 S.C.A.F.F. 的精简版\n- S.C.A.F.F. 和 故事化 Prompt 是并列关系，各有侧重\n- 万能模板 是最大的集合，什么场景都能用\n## 提问前检查清单 ​\n在按下发送键之前，快速过一遍：\n\n### 基础检查（必须） ​\n\n- [ ] 任务是否清晰：AI 能明白你要它做什么吗？\n- [ ] 背景是否充足：AI 有足够信息做出正确判断吗？\n- [ ] 约束是否明确：AI 知道什么不该做吗？\n### 进阶检查（推荐） ​\n\n- [ ] 角色是否指定：AI 应该以什么身份回答？\n- [ ] 格式是否说明：你期望什么形式的输出？\n- [ ] 示例是否需要：给个例子会不会更清楚？\n### 反思检查（可选） ​\n\n- [ ] 有没有说太多：是不是一次要求太多了？\n- [ ] 有没有说太少：是不是遗漏了关键信息？\n- [ ] 边界是否清晰：AI 会不会\"加戏\"？\n## 框架切换信号 ​\n\n当你用某个框架提问后，AI 输出不理想，这可能是框架选择或填写的问题：\nAI 输出问题可能原因调整方向技术方案和项目不匹配缺少项目背景补充 Situation功能范围和预期不符任务描述不清重写 Challenge/Goal代码复杂度不合适没说明受众水平添加 Audience输出格式混乱没指定格式添加 FormatAI \"加戏\"太多约束不够补充 Constraints/Foundations回答太技术化角色设定问题调整 Role没有理解核心痛点缺少故事背景切换到故事化 Prompt\n## 实战建议 ​\n\n### 给初学者 ​\n\n刚开始时，建议严格按框架填写，哪怕感觉有些项目是\"多余的\"。\n\n原因：\n\n- 框架帮你检查是否遗漏关键信息\n- 建立结构化思维的习惯\n- 当输出不理想时，有框架可以对照排查\n### 给有经验的用户 ​\n\n熟练后，可以根据任务灵活简化：\n\n- 简单任务：R.G.C. 甚至直接提问\n- 复杂任务：完整框架\n- 重复任务：基于之前的提示词微调\n核心原则：框架是工具，不是规则。让它帮你，而不是束缚你。\n\n## 本章回顾 ​\n\n恭喜你完成了「结构化提示词框架」的学习。现在你掌握了：\n工具用途核心要素S.C.A.F.F.复杂技术任务情境、挑战、受众、格式、基础R.G.C.快速简单提问角色、目标、约束万能模板通用场景角色、背景、任务、要求、约束、格式、示例故事化 Prompt表达用户痛点身份、现状、痛点、期望\n## 下一步预告 ​\n\n结构化框架解决了\"怎么组织信息\"的问题。但有时候，光有结构还不够——你需要一些特殊技巧让 AI 的推理更深入、输出更准确。\n\n下一节「3.3 进阶提示技巧」，我们将学习：\n\n- Zero-shot：直接提问的艺术\n- Few-shot：用示例教会 AI\n- Chain of Thought：让 AI \"想一想\"再回答\n- Tree of Thoughts：探索多条推理路径\n- Self-Critique：让 AI 自我检查\n这些技巧可以和结构化框架组合使用，进一步提升 AI 输出的质量。\n\n准备好了吗？让我们进入下一节。",
      "word_count": 2539,
      "estimated_time": 5
    },
    {
      "id": "lesson-078",
      "chapter_id": "chapter-03",
      "lesson_number": 9,
      "title": "3.3.1 Zero-shot Prompting：直接提问的艺术",
      "content": "# 3.3.1 Zero-shot Prompting：直接提问的艺术 ​\n\n## 经过本节学习，你将掌握 ​\n\n- Zero-shot 的定义和工作原理\n- 适合使用 Zero-shot 的场景\n- 如何写出高质量的 Zero-shot 提示词\n- Zero-shot 的局限性及应对方法\n## 什么是 Zero-shot Prompting ​\n\nZero-shot（零样本）的意思是：不给任何示例，直接让 AI 执行任务。\n\n这是最直接的提问方式。你描述任务，AI 根据它在训练中学到的知识直接给出答案。\n\n`将以下 Python 2 代码转换为 Python 3 语法：\nprint \"Hello, World!\"`AI 不需要你演示「怎么转换」，它已经「知道」Python 2 和 Python 3 的区别。这就是 Zero-shot 的核心：利用 AI 已有的知识完成任务。\n\n## 为什么 Zero-shot 有效 ​\n\n现代 AI 模型在训练时已经「见过」海量数据：代码、文档、教程、问答。对于常见任务，它已经具备执行能力，只需要你清晰地描述任务即可。\n\n就像请一位经验丰富的同事帮忙——你不需要教他怎么写代码，只需要说清楚你要什么。\n\n## 适用场景 ​\n场景示例为什么适合代码转换Python 2 → Python 3AI 熟悉两种语法文本分类判断评论情感常见 NLP 任务格式转换JSON → YAML标准格式，规则明确内容生成写一段产品描述创意任务，无需示例代码解释解释这段代码做了什么AI 理解代码能力强\n一句话判断：如果这个任务「AI 应该会」，就用 Zero-shot。\n\n## 差提示词 vs 好提示词 ​\n\n### ❌ 差提示词 ​\n\n`帮我处理一下这个数据`问题：任务不明确。处理是什么意思？清洗？转换？分析？\n\n### ✅ 好提示词 ​\n\n`将以下 CSV 数据转换为 JSON 格式，每行作为一个对象：\n\nname,age,city\n张三,25,北京\n李四,30,上海`改进点：\n\n- 明确任务：CSV → JSON\n- 明确格式：每行一个对象\n- 提供输入数据\n### 输出对比 ​\n\n差提示词可能得到：「请提供具体数据和处理需求」（AI 无法执行）\n\n好提示词得到：\njson\n`[\n  {\"name\": \"张三\", \"age\": 25, \"city\": \"北京\"},\n  {\"name\": \"李四\", \"age\": 30, \"city\": \"上海\"}\n]`\n## 写好 Zero-shot 的四个要素 ​\n\n### 1. 明确的任务动词 ​\n模糊清晰处理这段代码重构这段代码，提取重复逻辑为函数看看这个数据分析这个数据的异常值弄一下格式转换为 Markdown 表格格式\n### 2. 具体的输出要求 ​\n\n```\n❌ \"给我一个函数\"\n✅ \"给我一个 JavaScript 函数，接收数组参数，返回去重后的数组\"\n```\n\n### 3. 必要的约束条件 ​\n\n```\n❌ \"写一个排序算法\"\n✅ \"写一个排序算法，要求：时间复杂度 O(n log n)，不使用内置排序方法\"\n```\n\n### 4. 清晰的输入数据 ​\n如果任务需要处理数据，直接在提示词中提供。\n\n## 进阶技巧：增强 Zero-shot 效果 ​\n\n### 角色设定（Role Prompting） ​\n\n给 AI 一个角色，可以让它从特定视角回答问题。\n\n`你是一位有 10 年经验的前端工程师。\n请审查以下 React 代码，指出潜在的性能问题：\n[代码]`\n### 输出格式指定 ​\n明确告诉 AI 你想要的格式。\n\n`分析以下用户反馈，提取关键问题。\n输出格式：\n- 问题1：[描述]\n- 问题2：[描述]\n...`\n## 实战示例：待办清单项目 ​\n小李想让 AI 帮他写一个日期格式化函数。\n\n### Zero-shot 提示词 ​\n\n`写一个 JavaScript 函数 formatDate，功能如下：\n- 输入：Date 对象\n- 输出：格式化的字符串，格式为 \"YYYY年MM月DD日\"\n- 示例：输入 new Date('2024-03-15')，输出 \"2024年03月15日\"\n- 要求：月份和日期不足两位时补零`\n### AI 输出 ​\njavascript\n```\nfunction formatDate(date) {\n  const year = date.getFullYear();\n  const month = String(date.getMonth() + 1).padStart(2, '0');\n  const day = String(date.getDate()).padStart(2, '0');\n  return `${year}年${month}月${day}日`;\n}\n```\n\n## Zero-shot 的局限性 ​\n局限表现解决方案格式不稳定每次输出格式不一致用 Few-shot 提供示例复杂推理出错多步骤逻辑容易跳步用 Chain of Thought不理解特定需求输出不符合项目规范在提示词中补充上下文判断标准：如果 Zero-shot 连续两次输出不满意，考虑换用其他技巧。\n\n## 可复制模板 ​\n\n### 代码转换模板 ​\nmarkdown\n`将以下 [源语言/版本] 代码转换为 [目标语言/版本]：\n\n[代码内容]\n\n要求：\n- 保持功能一致\n- 遵循 [目标语言] 的最佳实践`\n### 内容生成模板 ​\nmarkdown\n```\n你是 [角色定位]。\n\n任务：[具体任务描述]\n\n要求：\n- [要求1]\n- [要求2]\n\n输出格式：[格式说明]\n```\n\n### 代码审查模板 ​\nmarkdown\n```\n审查以下代码，从 [审查维度] 角度指出问题：\n\n[代码内容]\n\n输出格式：\n1. 问题：[描述] | 位置：[行号] | 建议：[修改方案]\n```\n\n## 本节要点 ​\n✓ Zero-shot 的本质：利用 AI 已有知识，直接执行任务\n\n✓ 适用场景：AI「应该会」的任务——转换、分类、生成\n\n✓ 写好 Zero-shot 的关键：明确动词 + 具体输出 + 必要约束\n\n✓ 局限性：格式不稳定、复杂推理容易出错\n\n✓ 增强技巧：角色设定、输出格式指定\n\n下一节，我们学习如何用示例「教会」AI——Few-shot Prompting。",
      "word_count": 2679,
      "estimated_time": 5
    },
    {
      "id": "lesson-079",
      "chapter_id": "chapter-03",
      "lesson_number": 10,
      "title": "3.3.2 Few-shot Prompting：用示例教会 AI",
      "content": "# 3.3.2 Few-shot Prompting：用示例教会 AI ​\n\n## 经过本节学习，你将掌握 ​\n\n- Few-shot 的定义和工作原理\n- 为什么示例比长篇解释更有效\n- 如何选择高质量的示例\n- 示例数量的最佳实践\n- Few-shot 的适用场景和局限性\n## 什么是 Few-shot Prompting ​\n\nFew-shot（少样本）的意思是：给 AI 几个示例，让它学习模式后处理新任务。\n\n`任务：将用户需求转换为技术任务\n\n示例1：\n需求：\"用户可以添加待办事项\"\n任务：\n- 创建输入框组件\n- 实现添加按钮点击事件\n- 更新任务列表状态\n\n示例2：\n需求：\"用户可以删除待办事项\"\n任务：\n- 为每个任务添加删除按钮\n- 实现删除确认逻辑\n- 从列表中移除对应任务\n\n现在请处理：\n需求：\"用户可以标记任务为已完成\"`AI 看到两个示例后，就「学会」了转换规则，能按相同格式处理新需求。\n\n## 核心洞见：为什么示例比解释更有效 ​\n\n\"展示一次，胜过解释一百遍。\"\n\n这不是夸张。人类学习新技能时，看示范比听讲解更有效。AI 也一样。\n方式效果原因长篇解释规则容易遗漏细节，格式不稳定AI 需要「理解」你的意图提供示例格式一致，细节完整AI 直接「模仿」模式\n实际测试表明：对于格式化输出任务，Few-shot 的准确率比 Zero-shot 高出 20-40%。\n\n## 示例数量：多少个最合适？ ​\n数量适用场景权衡1 个（One-shot）格式明确，规则简单最省 token，但模式可能不够清晰2-3 个大多数场景平衡效果和成本，推荐默认选择4-5 个复杂模式、边界情况多效果更好，但 token 消耗增加更多很少需要收益递减，考虑是否需要微调\n经验法则：从 2 个示例开始，如果输出不稳定，再增加到 3 个。\n\n## 如何选择高质量示例 ​\n\n### 原则一：代表性 ​\n\n示例要覆盖典型情况，不要全是特例。\n\n`❌ 差示例选择（全是边界情况）：\n- 空字符串处理\n- 超长文本处理\n- 特殊字符处理\n\n✅ 好示例选择（先典型，后边界）：\n- 普通长度的文本（典型）\n- 包含中英文混合的文本（常见变体）\n- 空字符串处理（边界情况）`\n### 原则二：多样性 ​\n示例要覆盖不同类型，避免 AI 过度拟合单一模式。\n\n`任务：分类用户反馈\n\n❌ 差示例（全是负面）：\n- \"太难用了\" → 负面\n- \"垃圾软件\" → 负面\n\n✅ 好示例（覆盖各类）：\n- \"太难用了\" → 负面\n- \"还不错，但希望能加个夜间模式\" → 中性\n- \"用了三个月，效率提升很多\" → 正面`\n### 原则三：格式一致 ​\n所有示例的输入输出格式必须统一。\n\n`❌ 格式不一致：\n示例1：输入 \"...\" → 输出：任务列表\n示例2：输入：\"...\" 输出 - 任务1 - 任务2\n\n✅ 格式一致：\n示例1：\n输入：\"...\"\n输出：\n- 任务1\n- 任务2\n\n示例2：\n输入：\"...\"\n输出：\n- 任务1\n- 任务2`\n## 差提示词 vs 好提示词 ​\n\n### ❌ 差提示词 ​\n\n```\n帮我把用户故事转成开发任务，格式要清晰，包含前端和后端的工作。\n\n用户故事：作为用户，我希望能够搜索任务\n```\n问题：没有示例，AI 不知道你期望的「清晰格式」是什么样。\n\n### ✅ 好提示词 ​\n\n`任务：将用户故事转换为开发任务清单\n\n示例：\n用户故事：作为用户，我希望能够按日期筛选任务\n开发任务：\n【前端】\n- 添加日期选择器组件\n- 实现筛选状态管理\n- 更新任务列表渲染逻辑\n【后端】\n- 添加日期筛选 API 参数\n- 实现数据库查询条件\n\n现在请处理：\n用户故事：作为用户，我希望能够搜索任务`\n### 输出对比 ​\n好提示词的输出会严格遵循示例格式：\n\n`开发任务：\n【前端】\n- 添加搜索输入框组件\n- 实现搜索关键词状态管理\n- 实现防抖搜索逻辑\n- 更新任务列表渲染，高亮匹配文字\n【后端】\n- 添加搜索关键词 API 参数\n- 实现模糊匹配数据库查询`\n## 实战示例：待办清单项目 ​\n小李需要 AI 帮他生成多个组件的 TypeScript 类型定义。他希望格式统一。\n\n### Few-shot 提示词 ​\n\n`任务：为 React 组件生成 TypeScript Props 类型定义\n\n示例1：\n组件描述：一个显示任务标题的组件，标题必填，可选显示完成状态\n输出：\ninterface TaskTitleProps {\n  title: string;           // 任务标题，必填\n  isCompleted?: boolean;   // 完成状态，可选\n}\n\n示例2：\n组件描述：一个按钮组件，显示文字必填，点击事件必填，可选禁用状态\n输出：\ninterface ButtonProps {\n  label: string;           // 按钮文字，必填\n  onClick: () => void;     // 点击事件，必填\n  disabled?: boolean;      // 禁用状态，可选\n}\n\n现在请处理：\n组件描述：一个任务卡片组件，包含标题必填、描述可选、截止日期可选、优先级必填（高/中/低）`\n### AI 输出 ​\ntypescript\n```\ninterface TaskCardProps {\n  title: string;                        // 任务标题，必填\n  description?: string;                 // 任务描述，可选\n  dueDate?: Date;                       // 截止日期，可选\n  priority: 'high' | 'medium' | 'low';  // 优先级，必填\n}\n```\n注意 AI 自动学会了：\n\n- 注释风格（`// 说明，必填/可选`）\n- 可选属性用 `?`\n- 枚举类型用联合类型\n## 适用场景 ​\n场景示例为什么需要 Few-shot格式化输出生成 API 文档确保格式一致分类任务情感分析、标签分类明确分类标准转换任务需求 → 任务、代码 → 文档学习转换规则风格模仿按特定风格写文案学习语言风格\n## Few-shot 的局限性 ​\n局限表现解决方案Token 消耗高示例占用大量上下文精简示例，只保留关键信息示例选择难选错示例导致效果差遵循代表性、多样性、一致性原则过度模仿AI 照搬示例细节用不同的示例内容，只保留格式相同\n## 可复制模板 ​\n\n### 通用 Few-shot 模板 ​\nmarkdown\n`任务：[任务描述]\n\n示例1：\n输入：[示例输入1]\n输出：\n[示例输出1]\n\n示例2：\n输入：[示例输入2]\n输出：\n[示例输出2]\n\n现在请处理：\n输入：[实际输入]`\n### 分类任务模板 ​\nmarkdown\n```\n任务：将用户反馈分类为 [类别列表]\n\n示例：\n反馈：\"[示例反馈1]\"\n分类：[类别]\n\n反馈：\"[示例反馈2]\"\n分类：[类别]\n\n反馈：\"[示例反馈3]\"\n分类：[类别]\n\n请分类：\n反馈：\"[待分类内容]\"\n```\n\n### 转换任务模板 ​\nmarkdown\n```\n任务：将 [源格式] 转换为 [目标格式]\n\n转换规则示例：\n\n源：[示例源内容]\n目标：\n[示例目标内容]\n\n源：[示例源内容]\n目标：\n[示例目标内容]\n\n请转换：\n源：[实际内容]\n```\n\n## 进阶预告：动态 Few-shot ​\n在进阶版中，你会学到「动态 Few-shot」——根据用户输入自动选择最相关的示例，进一步提升效果并节省 token。\n\n## 本节要点 ​\n\n✓ Few-shot 的本质：用示例教会 AI 模式，而非用文字解释规则\n\n✓ 示例数量：2-3 个是最佳平衡点\n\n✓ 示例选择三原则：代表性、多样性、格式一致性\n\n✓ 适用场景：格式化输出、分类、转换、风格模仿\n\n✓ 与 Zero-shot 的选择：如果 Zero-shot 格式不稳定，换用 Few-shot\n\n下一节，我们学习如何让 AI「想一想再回答」——Chain of Thought。",
      "word_count": 3446,
      "estimated_time": 6
    },
    {
      "id": "lesson-080",
      "chapter_id": "chapter-03",
      "lesson_number": 11,
      "title": "3.3.3 Chain of Thought：让 AI &quot;想一想&quot;再回答",
      "content": "# 3.3.3 Chain of Thought：让 AI \"想一想\"再回答 ​\n\n## 经过本节学习，你将掌握 ​\n\n- Chain of Thought（CoT）的定义和原理\n- 两种触发 CoT 的方式\n- CoT 真正有效的场景（基于最新研究）\n- 如何写出有效的 CoT 提示词\n- CoT 的局限性和注意事项\n## 什么是 Chain of Thought ​\n\nChain of Thought（思维链，简称 CoT）的核心思想是：让 AI 把推理过程写出来，而不是直接给答案。\n\n就像数学考试要求「写出解题步骤」一样，当 AI 被要求展示思考过程时，往往能得到更准确的答案。\n\n`❌ 直接问：\n这个函数的时间复杂度是多少？\n\n✅ 用 CoT：\n请分析这个函数的时间复杂度。\n首先，识别代码中的循环结构；\n然后，分析每个循环的执行次数；\n最后，计算总的时间复杂度。`\n## 核心洞见：CoT 并非万能 ​\n\"Chain of Thought 主要在数学和符号推理任务上有显著效果，对其他类型任务的收益有限。\" —— 2024 年论文《To CoT or not to CoT?》\n\n这个研究结论很重要。它告诉我们：\n任务类型CoT 效果原因数学计算✅ 显著提升需要多步推理，步骤分解有帮助逻辑推理✅ 明显提升复杂逻辑需要逐步梳理代码分析✅ 有帮助涉及多层嵌套和条件判断文本生成⚠️ 收益有限创意任务不需要严格推理简单分类❌ 可能更慢增加不必要的步骤\n实践建议：不要对所有任务都用 CoT，只在需要推理的场景使用。\n\n## 两种触发方式 ​\n\n### 方式一：魔法咒语 ​\n\n最简单的方式，只需在提示词末尾加一句话：\n\n`请分析这段代码的性能瓶颈。\nLet's think step by step.`或者中文版：\n\n`请分析这段代码的性能瓶颈。\n让我们一步一步来思考。`这种方式简单，但 AI 的推理步骤可能不够结构化。\n\n### 方式二：显式步骤分解 ​\n\n更可控的方式，直接告诉 AI 该怎么分步：\n\n`请分析这段代码的性能瓶颈。\n\n分析步骤：\n1. 首先，识别代码中的循环和递归结构\n2. 然后，找出可能的重复计算\n3. 接着，检查数据结构的选择是否合理\n4. 最后，给出优化建议及预期效果`这种方式的输出更结构化，适合需要特定分析角度的场景。\n\n## 差提示词 vs 好提示词 ​\n\n### 场景：分析表单验证逻辑 ​\n\n### ❌ 差提示词 ​\n\n`这个表单验证逻辑有问题吗？\n\nfunction validateForm(data) {\n  if (data.email && data.password && data.password.length >= 6) {\n    if (data.email.includes('@')) {\n      return true;\n    }\n  }\n  return false;\n}`问题：AI 可能只给一个笼统的结论，遗漏一些边界情况。\n\n### ✅ 好提示词（使用 CoT） ​\n\n`请审查这个表单验证函数，检查是否有遗漏的验证场景。\n\nfunction validateForm(data) {\n  if (data.email && data.password && data.password.length >= 6) {\n    if (data.email.includes('@')) {\n      return true;\n    }\n  }\n  return false;\n}\n\n分析步骤：\n1. 首先，列出这个函数当前检查了哪些条件\n2. 然后，思考常见的表单验证需要检查什么\n3. 接着，对比找出遗漏的验证项\n4. 最后，给出改进建议`\n### 好提示词的 AI 输出 ​\n\n```\n分析过程：\n\n1. 当前检查的条件：\n   - email 存在且非空\n   - password 存在且非空\n   - password 长度 >= 6\n   - email 包含 @ 符号\n\n2. 常见表单验证需要检查：\n   - email 格式完整性（@前后都要有内容，要有域名后缀）\n   - password 强度（大小写、数字、特殊字符）\n   - 防止 SQL 注入和 XSS\n   - 空白字符处理\n\n3. 遗漏的验证项：\n   - email 格式不完整：\"@\" 或 \"a@\" 或 \"@b\" 都能通过\n   - password 只检查长度，没检查强度\n   - 没有处理首尾空格\n   - 没有验证 email 的域名后缀（如 .com）\n\n4. 改进建议：\n   - 使用正则表达式验证 email 格式\n   - 添加密码强度检查\n   - 对输入做 trim() 处理\n```\n\n## 适用场景决策表 ​\n场景是否使用 CoT理由计算时间/空间复杂度✅ 使用需要分析循环嵌套审查代码逻辑✅ 使用需要考虑多个分支和边界设计数据库表结构✅ 使用需要分析实体关系调试错误原因✅ 使用需要逐步排查简单代码格式转换❌ 不用直接转换即可写一段文案❌ 不用创意任务不需要严格推理重命名变量❌ 不用任务过于简单\n## 实战示例：待办清单项目 ​\n小李想让 AI 帮他分析一个 Bug：任务删除后，有时候页面没有更新。\n\n### CoT 提示词 ​\n\n`我的待办清单应用有一个 Bug：删除任务后，页面有时候不更新。\n\n以下是相关代码：\n\n// 任务列表状态\nconst [tasks, setTasks] = useState([]);\n\n// 删除任务\nconst deleteTask = (id) => {\n  tasks.splice(tasks.findIndex(t => t.id === id), 1);\n  setTasks(tasks);\n}\n\n请帮我分析问题原因。\n\n分析步骤：\n1. 首先，理解 React 状态更新的机制\n2. 然后，检查这段代码的状态更新方式\n3. 接着，找出导致不更新的原因\n4. 最后，给出修复方案`\n### AI 输出 ​\n\n```\n分析过程：\n\n1. React 状态更新机制：\n   React 通过对比新旧状态的引用来决定是否重新渲染。\n   如果状态对象的引用没变，React 认为状态没有改变。\n\n2. 当前代码的问题：\n   - splice() 直接修改了原数组\n   - setTasks(tasks) 传入的还是同一个数组引用\n   - React 对比发现引用相同，不触发重新渲染\n\n3. 问题根因：\n   直接修改原数组（mutation）而非创建新数组（immutation）\n\n4. 修复方案：\n   使用 filter 创建新数组：\n   \n   const deleteTask = (id) => {\n     setTasks(tasks.filter(t => t.id !== id));\n   }\n\n   或者使用展开运算符：\n   \n   const deleteTask = (id) => {\n     const newTasks = [...tasks];\n     newTasks.splice(newTasks.findIndex(t => t.id === id), 1);\n     setTasks(newTasks);\n   }\n```\n\n## Concise CoT：简洁版 ​\n如果你希望节省 token，可以用简洁版 CoT：\n\n`请简要分析这个函数的时间复杂度，用 2-3 句话说明推理过程，然后给出结论。`研究表明，Concise CoT 可以减少约 50% 的输出长度，同时保持大部分推理准确性。\n\n## CoT 的局限性 ​\n局限表现应对方法增加输出长度Token 消耗增加 20-80%用 Concise CoT 或限制字数某些任务反而变差简单任务强行分步可能出错根据场景选择是否使用推理可能出错某一步错了，后续全错配合 Self-Critique 检查\n## 可复制模板 ​\n\n### 代码分析 CoT 模板 ​\nmarkdown\n`请分析以下代码的 [分析目标：性能/安全性/可维护性]：\n\n[代码]\n\n分析步骤：\n1. 首先，[第一步分析角度]\n2. 然后，[第二步分析角度]\n3. 接着，[第三步分析角度]\n4. 最后，给出结论和建议`\n### 问题排查 CoT 模板 ​\nmarkdown\n```\n问题描述：[问题现象]\n\n相关代码/配置：\n[代码或配置]\n\n请帮我分析问题原因。\n\n排查步骤：\n1. 首先，理解正常情况下应该如何工作\n2. 然后，检查当前代码的执行流程\n3. 接着，定位可能导致问题的环节\n4. 最后，给出修复方案\n```\n\n### 简洁 CoT 模板 ​\nmarkdown\n```\n请分析 [任务]。\n用 2-3 句话说明你的推理过程，然后给出结论。\n```\n\n## 本节要点 ​\n✓ CoT 的本质：让 AI 展示推理过程，而非直接给答案\n\n✓ 有效场景：数学计算、逻辑推理、代码分析、问题排查\n\n✓ 两种触发方式：魔法咒语（简单）vs 显式步骤分解（可控）\n\n✓ 不要滥用：简单任务不需要 CoT，反而会降低效率\n\n✓ Concise CoT：在需要节省 token 时使用简洁版\n\n下一节，我们学习如何让 AI 探索多条路径——Tree of Thoughts。",
      "word_count": 3914,
      "estimated_time": 7
    },
    {
      "id": "lesson-081",
      "chapter_id": "chapter-03",
      "lesson_number": 12,
      "title": "3.3.4 Tree of Thoughts：探索多条推理路径",
      "content": "# 3.3.4 Tree of Thoughts：探索多条推理路径 ​\n\n定位说明：这是一个可选的高级技巧。日常 Vibe Coding 中，大部分场景用 Zero-shot、Few-shot、CoT 已经足够。Tree of Thoughts 主要用于技术选型、架构决策等需要对比多个方案的场景，约占日常工作的 5%。如果你刚入门，可以先跳过本节，遇到需要时再回来查阅。\n\n## 经过本节学习，你将掌握 ​\n\n- Tree of Thoughts（ToT）的定义和适用场景\n- ToT 与 Chain of Thought 的区别\n- 完整版和简化版 ToT 的使用方法\n- 什么时候需要 ToT，什么时候不需要\n## 什么是 Tree of Thoughts ​\n\nTree of Thoughts（思维树，简称 ToT）的核心思想是：让 AI 探索多条可能的路径，对比后选择最优方案。\n\n如果把 Chain of Thought 比作「一条路走到底」，那 Tree of Thoughts 就是「先看看有哪几条路，比较一下再决定走哪条」。\n\n`Chain of Thought（线性）：\n问题 → 步骤1 → 步骤2 → 步骤3 → 答案\n\nTree of Thoughts（树状）：\n问题 → 方案A → 评估A\n     → 方案B → 评估B  → 对比 → 推荐最优\n     → 方案C → 评估C`\n## ToT 与 CoT 的区别 ​\n维度Chain of ThoughtTree of Thoughts推理路径单一路径多条并行路径适用场景有标准答案的问题需要权衡对比的决策输出形式分步推导到结论多方案对比后推荐Token 消耗中等较高日常使用频率高（约 30%）低（约 5%）选择建议：\n\n- 如果问题有「正确答案」→ 用 CoT\n- 如果需要「选择最优方案」→ 用 ToT\n## 核心适用场景 ​\n\nToT 最适合以下场景：\n\n### 1. 技术选型 ​\n\n选择数据库、框架、第三方服务等。\n\n### 2. 架构决策 ​\n\n设计系统架构、API 风格、数据模型等。\n\n### 3. 方案对比 ​\n\n多种实现方式的优劣分析。\n\n### 4. 复杂问题分解 ​\n\n需要从多个角度切入的问题。\n\n## 差提示词 vs 好提示词 ​\n\n### 场景：为待办清单选择数据存储方案 ​\n\n### ❌ 差提示词 ​\n\n`我的待办清单应用应该用什么方式存储数据？`问题：AI 可能只推荐一种方案，没有对比分析。\n\n### ✅ 好提示词（使用 ToT） ​\n\n`我正在做一个个人待办清单应用，需要选择数据存储方案。\n\n项目背景：\n- 用户量：仅自己使用\n- 数据量：预计几百条任务\n- 部署方式：静态网页托管（如 Vercel）\n- 技术栈：React + TypeScript\n\n请给出 3 种不同的存储方案，对每种方案分析：\n1. 实现复杂度（1-5分，5分最复杂）\n2. 数据持久性\n3. 是否需要后端\n4. 适合的场景\n\n最后，根据我的项目情况，推荐最适合的方案并说明理由。`\n### 好提示词的 AI 输出 ​\n\n```\n## 方案分析\n\n### 方案一：localStorage\n- 实现复杂度：1分\n- 数据持久性：仅本地浏览器，换设备丢失\n- 是否需要后端：不需要\n- 适合场景：个人工具、原型验证\n\n### 方案二：IndexedDB\n- 实现复杂度：3分\n- 数据持久性：本地浏览器，支持更大数据量\n- 是否需要后端：不需要\n- 适合场景：需要存储大量结构化数据的本地应用\n\n### 方案三：Supabase（云数据库）\n- 实现复杂度：3分\n- 数据持久性：云端存储，多设备同步\n- 是否需要后端：不需要（BaaS 服务）\n- 适合场景：需要多设备同步、有扩展计划\n\n## 推荐方案\n\n根据你的情况（仅自己使用、几百条数据、静态托管），推荐 **方案一：localStorage**。\n\n理由：\n1. 实现最简单，几行代码即可\n2. 数据量小，localStorage 完全够用\n3. 不需要额外服务，符合静态托管要求\n4. 作为 MVP 快速验证，之后有需要再升级\n\n如果后续需要多设备同步，可以再迁移到 Supabase。\n```\n\n## 实战示例：登录功能方案选型 ​\n小李的待办清单需要添加登录功能，他想对比几种实现方式。\n\n### ToT 提示词 ​\n\n`我的待办清单应用需要添加用户登录功能。\n\n项目背景：\n- 个人项目，用户量预计 < 100 人\n- 技术栈：Next.js + TypeScript\n- 部署在 Vercel\n- 希望实现尽量简单\n\n请分析以下三种登录方案：\n1. 传统用户名密码登录\n2. 手机验证码登录\n3. 第三方 OAuth 登录（如 GitHub、Google）\n\n对每种方案分析：\n- 实现复杂度\n- 用户体验\n- 安全性\n- 维护成本\n\n最后推荐一种，并说明理由。`\n### AI 输出要点 ​\nAI 会分析三种方案的优劣，并根据「个人项目、用户量小、希望简单」的背景，推荐最适合的方案（可能是第三方 OAuth，因为不用自己管理密码）。\n\n## 简化版 ToT：日常快速使用 ​\n\n如果不需要完整的多方案对比，可以用简化版：\n\n`请给出 2-3 种不同的实现思路，简要对比优缺点后推荐一种。`这种方式输出更简洁，适合日常快速决策。\n\n### 简化版示例 ​\n\n`我想实现任务的拖拽排序功能，请给出 2-3 种实现思路，简要对比后推荐一种。\n技术栈：React + TypeScript`\n### 简化版输出 ​\n\n```\n三种实现思路：\n\n1. react-beautiful-dnd\n   优点：功能完善，动画流畅\n   缺点：包体积大，已停止维护\n\n2. @dnd-kit\n   优点：现代化设计，体积小，维护活跃\n   缺点：学习曲线稍陡\n\n3. 原生 HTML5 Drag API\n   优点：无依赖\n   缺点：需要大量代码，动画效果需自己实现\n\n推荐：@dnd-kit\n理由：现代化、轻量、社区活跃，适合长期维护的项目。\n```\n\n## 什么时候不需要 ToT ​\n场景用 ToT？原因实现一个具体功能❌直接写代码即可修复一个 Bug❌用 CoT 逐步排查格式化输出❌用 Few-shot技术选型✅需要对比多个选项架构设计✅需要权衡多种方案判断标准：如果你心里已经有了大致方向，只是想确认，不需要 ToT。如果你需要 AI 帮你「做选择」，用 ToT。\n\n## 可复制模板 ​\n\n### 完整版 ToT 模板 ​\nmarkdown\n`我需要 [决策内容]。\n\n项目背景：\n- [背景信息1]\n- [背景信息2]\n- [关键约束]\n\n请给出 [数量] 种不同的方案，对每种方案分析：\n1. [评估维度1]\n2. [评估维度2]\n3. [评估维度3]\n4. [评估维度4]\n\n最后，根据我的项目情况，推荐最适合的方案并说明理由。`\n### 简化版 ToT 模板 ​\nmarkdown\n```\n我想 [实现目标]。\n背景：[简要背景]\n\n请给出 2-3 种不同的思路，简要对比优缺点后推荐一种。\n```\n\n### 技术选型专用模板 ​\nmarkdown\n```\n我需要选择 [选型类型：数据库/框架/第三方服务]。\n\n项目情况：\n- 规模：[用户量/数据量]\n- 技术栈：[现有技术]\n- 部署方式：[部署环境]\n- 团队情况：[技术水平/人数]\n\n评估维度：\n- 实现复杂度\n- 性能表现\n- 维护成本\n- 社区生态\n\n请对比 [候选方案列表]，推荐最适合的选择。\n```\n\n## 本节要点 ​\n✓ ToT 的本质：探索多条路径，对比后选择最优方案\n\n✓ 与 CoT 的区别：CoT 是单路径推理，ToT 是多方案对比\n\n✓ 适用场景：技术选型、架构决策、方案对比（约占 5%）\n\n✓ 简化版：日常快速使用「给出 2-3 种思路，对比后推荐」\n\n✓ 不要滥用：如果已有方向，直接执行即可\n\n下一节，我们学习如何让 AI 自我检查——Self-Critique。",
      "word_count": 3372,
      "estimated_time": 6
    },
    {
      "id": "lesson-082",
      "chapter_id": "chapter-03",
      "lesson_number": 13,
      "title": "3.3.5 Self-Critique：让 AI 自我检查",
      "content": "# 3.3.5 Self-Critique：让 AI 自我检查 ​\n\n## 经过本节学习，你将掌握 ​\n\n- Self-Critique（自我批评）的定义和原理\n- 为什么 AI 自查能提升输出质量\n- 自查的核心维度清单\n- 如何在提示词中引导 AI 自查\n- Self-Critique 的局限性\n## 什么是 Self-Critique ​\n\nSelf-Critique（自我批评）的核心思想是：让 AI 生成内容后，再自己检查一遍，发现并修正问题。\n\n这就像写完文章后自己校对一遍，往往能发现最初遗漏的错误。\n\n`生成 → 自查 → 修正`\n## 核心洞见：为什么自查有效 ​\n\"SELF-REFINE 方法可以在无需额外训练的情况下，将 AI 输出质量提升约 20%。\" —— 2023 年 CMU 研究论文\n\n这个数据告诉我们：同一个 AI，加一步自查，效果就能明显提升。\n\n原因在于：\n\n- 第一次生成往往有遗漏：AI 快速生成时可能忽略边界情况\n- 自查时换个视角：审查模式会关注不同方面\n- 迭代改进更精准：基于具体问题修改，比重新生成更准确\n## 自查的核心维度 ​\n\n不同类型的内容，需要检查的维度不同：\n\n### 代码自查维度 ​\n维度检查内容常见问题功能正确性是否实现了需求遗漏部分功能边界情况空值、极值、异常输入没处理 null/undefined安全性XSS、注入、敏感数据用户输入未过滤性能时间/空间复杂度不必要的循环嵌套可读性命名、注释、结构变量名不清晰可维护性重复代码、耦合度硬编码 magic number\n### 文案/文档自查维度 ​\n维度检查内容准确性信息是否正确完整性是否遗漏关键点清晰度是否容易理解一致性术语、风格是否统一\n## 差提示词 vs 好提示词 ​\n\n### 场景：生成表单验证函数 ​\n\n### ❌ 差提示词 ​\n\n`写一个验证用户注册表单的函数，检查邮箱和密码。`AI 可能生成一个基础版本，但遗漏边界情况。\n\n### ✅ 好提示词（带 Self-Critique） ​\n\n`写一个验证用户注册表单的函数，检查邮箱和密码。\n\n生成后，请自查：\n1. 是否覆盖了所有边界情况（空值、空字符串、只有空格）？\n2. 是否有安全隐患（XSS、注入风险）？\n3. 错误提示是否清晰，用户能知道具体问题？\n4. 是否有不必要的重复代码？\n\n如有问题，请修正后重新输出最终版本。`\n### 好提示词的 AI 输出 ​\nAI 会先生成代码，然后逐条检查，最后给出改进版：\njavascript\n`// 自查发现的问题：\n// 1. 原版没有处理 trim 后为空的情况\n// 2. 错误提示不够具体\n// 3. 邮箱正则可以更严格\n\n// 改进后的版本：\nfunction validateRegistration(email, password) {\n  const errors = [];\n  \n  // 处理空白字符\n  const trimmedEmail = email?.trim() || '';\n  const trimmedPassword = password || '';\n  \n  // 邮箱验证\n  if (!trimmedEmail) {\n    errors.push('邮箱不能为空');\n  } else if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(trimmedEmail)) {\n    errors.push('邮箱格式不正确，请检查是否包含 @ 和域名');\n  }\n  \n  // 密码验证\n  if (!trimmedPassword) {\n    errors.push('密码不能为空');\n  } else {\n    if (trimmedPassword.length < 8) {\n      errors.push('密码长度至少 8 位');\n    }\n    if (!/[A-Z]/.test(trimmedPassword)) {\n      errors.push('密码需要包含至少一个大写字母');\n    }\n    if (!/[0-9]/.test(trimmedPassword)) {\n      errors.push('密码需要包含至少一个数字');\n    }\n  }\n  \n  return {\n    isValid: errors.length === 0,\n    errors\n  };\n}`\n## 常用自查指令词库 ​\n\n### 通用自查 ​\n\n```\n生成后，请检查是否有遗漏或错误，如有请修正。\n```\n\n### 代码自查 ​\n\n```\n请自查：\n1. 边界情况是否都处理了？\n2. 有没有潜在的安全问题？\n3. 性能是否可以优化？\n如有问题，请修正后输出最终版本。\n```\n\n### 严格自查 ​\n\n```\n请扮演一个严格的代码审查者，审查你刚才生成的代码：\n- 找出至少 3 个可以改进的地方\n- 给出改进后的版本\n```\n\n### 特定维度自查 ​\n\n```\n请从 [安全性/性能/可读性] 角度审查这段代码，指出问题并修正。\n```\n\n## 实战示例：待办清单项目 ​\n小李让 AI 生成一个任务排序函数，并要求自查。\n\n### Self-Critique 提示词 ​\n\n`为我的待办清单应用写一个排序函数，支持按以下方式排序：\n- 按创建时间（新到旧）\n- 按截止日期（近到远，无截止日期的排最后）\n- 按优先级（高 > 中 > 低）\n\n任务数据结构：\n{\n  id: string,\n  title: string,\n  createdAt: Date,\n  dueDate: Date | null,\n  priority: 'high' | 'medium' | 'low'\n}\n\n生成后，请自查：\n1. 排序逻辑是否正确处理了 null/undefined？\n2. 优先级排序的顺序是否符合预期？\n3. 函数接口是否清晰易用？\n如有问题，请修正。`\n### AI 输出（含自查过程） ​\njavascript\n```\n// 初版实现...\n\n// 自查发现：\n// 1. dueDate 为 null 时直接比较会出问题 ✓ 已处理\n// 2. 优先级用字符串比较不可靠，需要映射为数字 → 需修正\n// 3. 函数可以更灵活，支持升序/降序 → 已优化\n\n// 最终版本：\nconst priorityMap = { high: 3, medium: 2, low: 1 };\n\nfunction sortTasks(tasks, sortBy, order = 'desc') {\n  const direction = order === 'desc' ? -1 : 1;\n  \n  return [...tasks].sort((a, b) => {\n    switch (sortBy) {\n      case 'createdAt':\n        return direction * (new Date(b.createdAt) - new Date(a.createdAt));\n      \n      case 'dueDate':\n        // null 排最后\n        if (!a.dueDate && !b.dueDate) return 0;\n        if (!a.dueDate) return 1;\n        if (!b.dueDate) return -1;\n        return direction * (new Date(a.dueDate) - new Date(b.dueDate));\n      \n      case 'priority':\n        return direction * (priorityMap[b.priority] - priorityMap[a.priority]);\n      \n      default:\n        return 0;\n    }\n  });\n}\n```\n\n## 迭代式 Self-Critique ​\n对于重要输出，可以进行多轮自查：\n\n`第一轮：功能正确性检查\n第二轮：安全性检查\n第三轮：性能和代码质量检查`每轮聚焦一个维度，逐步完善。\n\n## Self-Critique 的局限性 ​\n局限表现应对方法自我认可偏差AI 可能认为自己的输出没问题用「扮演严格审查者」指令检查不彻底可能遗漏某些维度明确列出要检查的维度越查越乱修正时引入新问题限制修改范围，一次只改一处增加 token输出变长对重要输出使用，简单任务跳过\n## 与人工审查的配合 ​\n\nSelf-Critique 不能替代人工审查，而是减轻人工审查负担。\n\n推荐流程：\n\n- AI 生成 + 自查 → 得到初版\n- 你快速浏览，发现明显问题 → 让 AI 修正\n- 最终人工确认关键逻辑\n## 可复制模板 ​\n\n### 代码生成 + 自查模板 ​\nmarkdown\n`[任务描述]\n\n生成后，请自查：\n1. 是否覆盖了所有边界情况？\n2. 是否有安全隐患？\n3. 代码是否清晰可维护？\n如有问题，请修正后输出最终版本。`\n### 严格审查模板 ​\nmarkdown\n```\n请扮演一个严格的 [角色：代码审查者/编辑/QA]，审查你刚才的输出：\n- 找出至少 [数量] 个可以改进的地方\n- 说明每个问题的影响\n- 给出改进后的版本\n```\n\n### 特定维度审查模板 ​\nmarkdown\n```\n请从以下维度审查你的输出：\n- [ ] [维度1]\n- [ ] [维度2]\n- [ ] [维度3]\n\n对每个维度，说明是否通过，如不通过请修正。\n```\n\n## 本节要点 ​\n✓ Self-Critique 的本质：让 AI 生成后自我检查，发现并修正问题\n\n✓ 为什么有效：自查时换视角，能发现第一次遗漏的问题\n\n✓ 核心维度：功能正确性、边界情况、安全性、性能、可读性\n\n✓ 常用指令：「请自查...如有问题请修正」「扮演严格审查者」\n\n✓ 局限性：可能自我认可、检查不彻底，需配合人工审查\n\n下一节，我们学习如何选择合适的技巧——技巧选择指南。",
      "word_count": 4294,
      "estimated_time": 8
    },
    {
      "id": "lesson-083",
      "chapter_id": "chapter-03",
      "lesson_number": 14,
      "title": "3.3.6 技巧选择指南：什么情况用什么技巧",
      "content": "# 3.3.6 技巧选择指南：什么情况用什么技巧 ​\n\n## 经过本节学习，你将掌握 ​\n\n- 快速判断任务应该用哪种技巧\n- 技巧组合使用的策略\n- 一张可以随时查阅的速查表\n## 核心决策流程 ​\n\n遇到一个任务，按以下流程选择技巧：\n\n`开始\n  ↓\n这个任务 AI 应该「直接会做」吗？\n  ├─ 是 → Zero-shot（直接问）\n  └─ 否 ↓\n      \n需要特定的输出格式吗？\n  ├─ 是 → Few-shot（给示例）\n  └─ 否 ↓\n      \n需要多步推理/分析吗？\n  ├─ 是 → Chain of Thought（分步思考）\n  └─ 否 ↓\n      \n需要对比多个方案吗？\n  ├─ 是 → Tree of Thoughts（多路径对比）\n  └─ 否 ↓\n      \n输出质量很重要吗？\n  ├─ 是 → 加上 Self-Critique（自查修正）\n  └─ 否 → Zero-shot 就够了`\n## 完整决策表格 ​\n任务类型推荐技巧原因示例任务代码格式转换Zero-shotAI 已掌握转换规则Python 2 → Python 3内容生成Zero-shot创意任务不需要示例写产品描述代码解释Zero-shotAI 理解代码能力强解释这段代码做什么格式化输出Few-shot用示例确保格式一致生成 API 文档分类任务Few-shot用示例明确分类标准用户反馈分类风格模仿Few-shot用示例学习风格按特定风格写文案复杂度分析Chain of Thought需要分步推理分析时间复杂度Bug 排查Chain of Thought需要逐步推理分析为什么页面不更新逻辑审查Chain of Thought需要考虑多个分支审查表单验证逻辑技术选型Tree of Thoughts需要对比多个方案选择数据库架构决策Tree of Thoughts需要权衡多种方案设计 API 风格重要代码+ Self-Critique需要保证质量核心业务逻辑公开输出+ Self-Critique需要减少错误对外 API 文档\n## 组合使用策略 ​\n单一技巧有时不够，可以组合使用：\n\n### 组合一：Few-shot + Self-Critique ​\n\n场景：需要格式化输出，且质量要求高\n\n`任务：生成 API 接口文档\n\n示例1：\n接口：GET /users\n文档：\n- 描述：获取用户列表\n- 参数：page（分页）, limit（每页数量）\n- 返回：用户数组\n\n示例2：\n接口：POST /users\n文档：\n- 描述：创建新用户\n- 参数：name（必填）, email（必填）\n- 返回：新创建的用户对象\n\n请为以下接口生成文档：\n接口：DELETE /users/:id\n\n生成后，请自查：\n- 是否遵循了示例格式？\n- 是否遗漏了必要信息？\n如有问题请修正。`\n### 组合二：Chain of Thought + Self-Critique ​\n场景：复杂分析任务，需要确保推理正确\n\n`请分析这个排序算法的时间复杂度。\n\n分析步骤：\n1. 识别循环结构\n2. 分析每层循环的执行次数\n3. 计算总的时间复杂度\n\n分析完成后，请自查：\n- 每一步的推理是否正确？\n- 最终结论是否合理？\n如有错误请修正。`\n### 组合三：Tree of Thoughts + Chain of Thought ​\n场景：复杂决策，每个方案都需要深入分析\n\n`请为我的应用选择状态管理方案。\n\n分析三种方案：\n1. React Context\n2. Redux Toolkit\n3. Zustand\n\n对每种方案，请分步分析：\n- 第一步：理解其核心原理\n- 第二步：分析在我的场景下的优势\n- 第三步：分析潜在的问题\n- 第四步：给出适用场景\n\n最后对比推荐。`\n## 日常使用频率参考 ​\n根据实际开发经验，各技巧的使用频率大致如下：\n技巧日常使用频率典型场景Zero-shot50%大部分简单任务Few-shot25%格式化输出Chain of Thought15%复杂逻辑分析Self-Critique8%重要输出质量保证Tree of Thoughts2%技术选型决策\n实践建议：\n\n- 从 Zero-shot 开始尝试\n- 如果输出不满意，再升级到其他技巧\n- 重要输出记得加 Self-Critique\n## 快速选择清单 ​\n\n### 我要做代码转换/格式转换 ​\n\n→ Zero-shot\n\n### 我需要统一的输出格式 ​\n\n→ Few-shot（给 2-3 个示例）\n\n### 我需要分析复杂逻辑/排查 Bug ​\n\n→ Chain of Thought（分步思考）\n\n### 我需要做技术选型/对比方案 ​\n\n→ Tree of Thoughts（多方案对比）\n\n### 这个输出很重要，不能出错 ​\n\n→ 加上 Self-Critique（自查修正）\n\n## 本节技巧速查卡 ​\n\n可以保存或打印，随时查阅：\n\n`┌─────────────────────────────────────────────────────┐\n│              提示技巧速查卡 v1.0                      │\n├─────────────────────────────────────────────────────┤\n│                                                     │\n│  Zero-shot   │ AI 会做的任务，直接问                  │\n│              │ 例：代码转换、内容生成                  │\n│                                                     │\n│  Few-shot    │ 需要特定格式，给示例                    │\n│              │ 例：API 文档、分类任务                  │\n│                                                     │\n│  CoT         │ 复杂推理，分步思考                      │\n│              │ 例：复杂度分析、Bug 排查                │\n│                                                     │\n│  ToT         │ 方案对比，多路径探索                    │\n│              │ 例：技术选型、架构决策                  │\n│                                                     │\n│  Self-Critique │ 重要输出，自查修正                   │\n│                │ 例：核心代码、公开文档                │\n│                                                     │\n├─────────────────────────────────────────────────────┤\n│  默认流程：Zero-shot → 不满意？→ 升级技巧             │\n│  重要输出：任何技巧 + Self-Critique                   │\n└─────────────────────────────────────────────────────┘`\n## 与下一节的衔接 ​\n恭喜你，完成了 3.3 进阶提示技巧的学习！\n\n你现在已经掌握了：\n\n- 3.1：该告诉 AI 什么信息（上下文）\n- 3.2：如何组织这些信息（结构化框架）\n- 3.3：用什么方式让 AI 处理（提示技巧）\n下一节 3.4 编写你的第一份 PRD，我们将把第二章的产品思考和第三章的提示技巧整合起来，形成一个完整的工作流。\n\n你会学到：\n\n- 如何把灵魂三问、用户画像、减法思维的成果转化为 PRD\n- 一个适合初学者的精简 PRD 模板\n- 如何用优先级引导 AI 分阶段开发\n## 本节要点 ​\n\n✓ 选择技巧的核心流程：直接会做 → 需要格式 → 需要推理 → 需要对比 → 需要质量\n\n✓ 最常用的组合：Few-shot + Self-Critique、CoT + Self-Critique\n\n✓ 日常使用频率：Zero-shot 50%、Few-shot 25%、CoT 15%、Self-Critique 8%、ToT 2%\n\n✓ 实践建议：从 Zero-shot 开始，不满意再升级；重要输出加 Self-Critique\n\n## 本章完成检查清单 ​\n\n在进入下一节之前，确认你已经：\n\n- [ ] 理解 Zero-shot：直接问 AI 会做的任务\n- [ ] 理解 Few-shot：用示例教会 AI 格式\n- [ ] 理解 Chain of Thought：复杂推理分步思考\n- [ ] 知道 Tree of Thoughts 的存在：方案对比时使用\n- [ ] 理解 Self-Critique：重要输出让 AI 自查\n- [ ] 能根据任务类型选择合适的技巧\n如果以上都打勾了，恭喜你，准备好进入 3.4 节了！",
      "word_count": 4023,
      "estimated_time": 8
    },
    {
      "id": "lesson-084",
      "chapter_id": "chapter-03",
      "lesson_number": 15,
      "title": "3.4.1 什么是 PRD，为什么 Vibe Coding 需要它",
      "content": "# 3.4.1 什么是 PRD，为什么 Vibe Coding 需要它 ​\n\n## 一个真实的困境 ​\n\n小李在第二章已经想清楚了：他要做一个极简待办清单，帮助职场人士管理每日任务。他打开 AI 工具，输入：\n\n\"帮我做一个待办清单应用\"\n\nAI 回复了一大段代码。小李兴奋地运行，结果发现：\n\n- AI 做了一个带登录注册的复杂系统（他只想给自己用）\n- 有日历视图、标签分类、团队协作（他只要最简单的添加和勾选）\n- 界面是英文的（他想要中文）\n- 用了他完全不懂的技术栈\n小李花了两个小时调试，最后放弃了。\n\n问题出在哪？\n\n不是 AI 不够聪明，而是小李没有把他想清楚的东西，用 AI 能理解的方式说出来。\n\n## 什么是 PRD ​\n\nPRD（Product Requirements Document），直译是\"产品需求文档\"。\n\n用大白话说：PRD 是一份任务说明书，告诉执行者（AI 或开发者）要做什么、为谁做、做成什么样。\n\n一个类比：你去餐厅点菜，\"随便来点吃的\"和\"一份少油少盐的西红柿炒蛋，不要葱\"，哪个更可能得到你想要的结果？\n\nPRD 就是那份详细的点菜单。\n\n## 传统 PRD vs Vibe Coding PRD ​\n\n在传统软件开发中，PRD 通常是一份几十页的正式文档，包含市场分析、竞品对比、技术架构等内容。\n\n但在 Vibe Coding 中，PRD 的目的完全不同：\n维度传统 PRDVibe Coding PRD阅读对象产品经理、开发团队、老板AI核心目的对齐团队认知、作为合同依据让 AI 准确理解你的意图篇幅几十页，详细全面20-50 行，精简清晰格式Word/PPT，图文并茂Markdown 纯文本，结构化更新频率立项时写一次每轮对话可能调整专业要求需要产品经理技能只需要说清楚你要什么\n核心洞见：Vibe Coding 的 PRD 不是给人看的\"报告\"，而是给 AI 的\"任务书\"。\n\n## PRD 解决的三个问题 ​\n\n### 问题一：AI 总是\"自由发挥\" ​\n\n没有 PRD 时，AI 会根据自己的\"理解\"填补你没说的部分。它可能：\n\n- 添加你不需要的功能\n- 用你不熟悉的技术\n- 做成和你想象完全不同的样子\n有了 PRD，你明确告诉 AI：\"只做这些，不做那些\"，大大减少返工。\n\n### 问题二：做着做着忘了初衷 ​\n\n开发过程中，你可能会被各种细节带偏，忘记最初要解决什么问题。\n\nPRD 是一个\"锚点\"。每次迷茫时，回头看 PRD：\"我当初要解决什么问题？现在做的事情是在解决这个问题吗？\"\n\n### 问题三：不知道什么时候算\"做完了\" ​\n\n没有 PRD 时，你可能会陷入无限的\"再加一个功能\"循环。\n\nPRD 里的\"核心功能\"和\"成功标准\"告诉你：做到这些就够了，可以停下来验证了。\n\n## 差提示词 vs 好提示词 ​\n\n让我们看看小李的问题如何用 PRD 解决：\n\n❌ 差提示词：\n\n`帮我做一个待办清单应用`问题：\n\n- AI 不知道用户是谁（个人用还是团队用？）\n- AI 不知道核心功能是什么（要日历吗？要提醒吗？）\n- AI 不知道技术约束（用什么语言？要不要数据库？）\n- AI 不知道什么算完成\n✅ 好提示词（PRD 形式）：\nmarkdown\n`# 极简待办清单\n\n## 一句话描述\n一个只有添加和勾选功能的待办清单网页，给自己用\n\n## 目标用户\n我自己（职场人士，每天处理 5-10 件事）\n\n## 要解决的问题\n怕遗漏重要事项，需要一个比便签纸更容易坚持使用的工具\n\n## 核心功能（只做这些）\n- 添加任务（输入框 + 按钮）\n- 查看任务列表\n- 点击勾选完成\n- 删除任务\n\n## 不做的功能\n- 不要登录注册\n- 不要日历视图\n- 不要分类标签\n- 不要团队协作\n- 不要云端同步（本地存储即可）\n\n## 技术约束\n- 纯前端，用 HTML + CSS + JavaScript\n- 数据存在浏览器 localStorage\n- 界面用中文\n\n## 成功标准\n打开网页能添加任务、勾选完成、删除任务，刷新后数据还在`这就是一份 Vibe Coding PRD。 不需要几十页，只需要把关键信息写清楚。\n\n## 为什么\"先写后做\"更高效 ​\n\n你可能会想：直接告诉 AI 不就行了，何必先写文档？\n\n三个原因：\n\n1. 写作是思考的过程\n\n当你把想法写成文字，会发现很多模糊的地方。\"做一个好用的待办清单\"——什么叫\"好用\"？写 PRD 的过程会逼你把模糊的想法变清晰。\n\n2. 减少来回修改\n\n根据 ChatPRD（一家专注 AI 辅助 PRD 的公司）的数据，使用结构化 PRD 的开发者，平均减少 60% 的返工次数。\n\n3. 可复用、可迭代\n\nPRD 写好后，可以多次使用：\n\n- 这次 AI 没做好？调整 PRD 再试\n- 换一个 AI 工具？直接复制 PRD\n- 下次做类似项目？在这份 PRD 基础上改\n## 本节核心要点 ​\n\n- ✅ PRD 是给 AI 的\"任务书\"，不是给老板看的\"报告\"\n- ✅ Vibe Coding 的 PRD 只需要 20-50 行，核心是结构清晰、信息完整\n- ✅ PRD 解决三个问题：防止 AI 自由发挥、保持初衷、定义完成标准\n- ✅ \"先写后做\"能减少返工，让开发过程更高效\n接下来，我们学习如何把第二章的思考成果填入 PRD。",
      "word_count": 2245,
      "estimated_time": 4
    },
    {
      "id": "lesson-085",
      "chapter_id": "chapter-03",
      "lesson_number": 16,
      "title": "3.4.2 从第二章成果到 PRD：整合你的思考",
      "content": "# 3.4.2 从第二章成果到 PRD：整合你的思考 ​\n\n如果你认真完成了第二章的练习，恭喜你——你已经拥有了写 PRD 所需的所有素材。\n\n本节的任务是：把这些思考成果\"搬\"到 PRD 的对应位置。\n\n## 第二章成果 → PRD 字段映射表 ​\n第二章工具你已完成的思考对应 PRD 字段灵魂三问 2.5.2用户是谁目标用户灵魂三问 2.5.3痛点在哪要解决的问题灵魂三问 2.5.4为什么选你一句话描述（差异化）减法思维 2.3P0 功能列表核心功能减法思维 2.3.5\"不做清单\"不做的功能用户旅程 2.4.4关键步骤用户流程故事思维 2.4用户画像融入目标用户描述\n核心洞见：PRD 不是从零开始写，而是把第二章的思考\"翻译\"成 AI 能执行的格式。\n\n## 小李的映射示例 ​\n\n让我们看看小李在第二章做了哪些思考，以及如何填入 PRD：\n\n### 第二章：灵魂三问的答案 ​\n\n`用户是谁？\n→ 我自己，28岁职场人士，每天处理5-10件事\n\n痛点在哪？\n→ 怕遗漏重要事项，便签纸容易丢，手机备忘录不够直观\n\n为什么选我的方案？\n→ 比便签纸更不容易丢，比复杂待办App更简单容易坚持`\n### 第二章：减法思维的成果 ​\n\n```\nP0（必须有）：添加任务、查看列表、标记完成\nP1（应该有）：删除任务、任务计数\nP2（可以有）：分类标签、优先级标记\n不做清单：登录注册、云同步、团队协作、日历视图\n```\n\n### 第二章：用户旅程的关键步骤 ​\n\n```\n1. 打开网页 → 看到任务列表\n2. 输入新任务 → 点击添加\n3. 完成任务 → 点击勾选\n4. 关闭网页 → 下次打开数据还在\n```\n\n### 填入 PRD 后 ​\nmarkdown\n```\n## 目标用户\n我自己（28岁职场人士，每天处理5-10件事）\n\n## 要解决的问题\n怕遗漏重要事项。便签纸容易丢，手机备忘录不够直观，\n需要一个\"打开就能用、关掉数据还在\"的极简工具。\n\n## 一句话描述\n一个比便签纸更持久、比复杂App更简单的待办清单网页\n\n## 核心功能（P0）\n- 添加任务\n- 查看任务列表\n- 标记任务完成\n\n## 不做的功能\n- 登录注册\n- 云端同步\n- 团队协作\n- 日历视图\n- 分类标签（P2，暂不做）\n\n## 用户流程\n1. 打开网页 → 看到任务列表\n2. 输入任务 → 点击添加按钮\n3. 完成任务 → 点击勾选\n4. 关闭网页 → 下次打开数据还在\n```\n看到了吗？PRD 的每一部分都有来源，不需要凭空编造。\n\n## 填写顺序建议 ​\n\n不是所有字段都同等重要。推荐的填写顺序：\n顺序字段原因1要解决的问题这是核心，决定其他所有内容2目标用户问题是谁的问题？3核心功能解决问题需要什么功能？4不做的功能同样重要，防止范围蔓延5用户流程用户怎么用这些功能？6技术约束有什么限制条件？7成功标准怎么算做完了？8一句话描述最后总结提炼\n为什么\"要解决的问题\"排第一？\n\n因为功能是为问题服务的。如果你先写功能，很容易陷入\"我想要这个、那个\"的功能堆砌。先写问题，每个功能都要回答：\"这个功能是在解决什么问题？\"\n\n## 常见错误 ​\n\n### 错误一：跳过问题，直接写功能 ​\n\n❌ 错误示范：\nmarkdown\n`## 核心功能\n- 添加任务\n- 删除任务\n- 分类标签\n- 日历视图\n- 提醒通知`问题：这些功能在解决什么问题？为什么需要日历视图？\n\n✅ 正确做法：\nmarkdown\n`## 要解决的问题\n怕遗漏重要事项\n\n## 核心功能\n- 添加任务（记录要做的事）\n- 查看列表（知道还有什么没做）\n- 标记完成（获得成就感）`\n### 错误二：把\"不做清单\"当摆设 ​\n很多人写 PRD 时，\"不做清单\"要么空着，要么随便填几个。\n\n但这恰恰是 AI 最需要知道的信息。没有明确的边界，AI 会\"贴心地\"帮你加上各种功能。\n\n✅ 好的\"不做清单\"：\nmarkdown\n`## 不做的功能\n- 不要登录注册（这是个人工具）\n- 不要云同步（本地存储够用）\n- 不要标签分类（保持极简）\n- 不要优先级标记（第一版不需要）\n- 不要移动端适配（先做桌面版）`\n### 错误三：用户画像太详细 ​\n第二章的三维用户画像是为了帮你深入理解用户。但 PRD 里不需要那么详细。\n\n❌ 过于详细：\nmarkdown\n`## 目标用户\n小李，28岁，在互联网公司做运营，每天通勤1.5小时，\n喜欢喝咖啡，周末会去健身房，有轻度焦虑症...`✅ 精简版：\nmarkdown\n`## 目标用户\n职场人士，每天处理5-10件事务，需要简单的任务追踪工具`PRD 里的用户描述只需要保留与产品相关的特征。\n\n## 没做第二章怎么办 ​\n\n如果你直接跳到这里，没有完成第二章的思考，也不用回头从头学。\n\n你可以用这个快速版自检清单：\n\n- [ ] 我能用一句话说清楚\"这是给谁用的\"吗？\n- [ ] 我能说出用户遇到的具体问题吗？\n- [ ] 我能列出 3 个必须有的核心功能吗？\n- [ ] 我能列出 3 个明确不做的功能吗？\n如果这四个问题你都能回答，就可以继续。如果有任何一个答不上来，建议花 10 分钟快速浏览第二章的 2.3（减法思维）和 2.5（灵魂三问）。\n\n## 本节核心要点 ​\n\n- ✅ PRD 的内容来自第二章的思考成果，不是凭空编写\n- ✅ 先写\"要解决的问题\"，再写功能\n- ✅ \"不做清单\"和\"核心功能\"同样重要\n- ✅ 用户描述只保留与产品相关的特征，不需要完整画像\n接下来，我们学习具体的 PRD 模板和填写指南。",
      "word_count": 2330,
      "estimated_time": 4
    },
    {
      "id": "lesson-086",
      "chapter_id": "chapter-03",
      "lesson_number": 17,
      "title": "3.4.3 适合初学者的 PRD 模板（精简版）",
      "content": "# 3.4.3 适合初学者的 PRD 模板（精简版） ​\n\n本节给你一份可以直接复制使用的 PRD 模板，以及每个字段的填写指南。\n\n## 核心模板（可直接复制） ​\nmarkdown\n`# [项目名称]\n\n## 一句话描述\n[用一句话说清楚这是什么、给谁用、解决什么问题]\n\n## 目标用户\n[谁会用这个？保留与产品相关的特征]\n\n## 要解决的问题\n[用户遇到了什么困扰？现有方案有什么不足？]\n\n## 核心功能（P0，必须有）\n- [ ] 功能1：[简要描述]\n- [ ] 功能2：[简要描述]\n- [ ] 功能3：[简要描述]\n\n## 不做的功能\n- 不要 [功能A]（原因）\n- 不要 [功能B]（原因）\n- 不要 [功能C]（原因）\n\n## 用户流程\n1. 用户 [动作] → 看到 [结果]\n2. 用户 [动作] → 看到 [结果]\n3. 用户 [动作] → 看到 [结果]\n\n## 技术约束\n- 技术栈：[使用什么技术]\n- 数据存储：[存在哪里]\n- 界面语言：[中文/英文]\n- 其他限制：[如有]\n\n## 成功标准\n[完成这些就算做完了：]\n- [ ] 标准1\n- [ ] 标准2\n- [ ] 标准3`\n## 逐字段填写指南 ​\n\n### 字段1：项目名称 ​\n目的：给你的项目起一个简短、有辨识度的名字。\n\n填写技巧：\n\n- 2-6个字为佳\n- 能体现核心功能或特点\n- 避免太抽象的名字\n示例：\n\n- ✅ 极简待办、每日打卡、销售周报分析器\n- ❌ 我的项目、系统、工具\n### 字段2：一句话描述 ​\n\n目的：让 AI 在 3 秒内理解你要做什么。\n\n填写公式：\n\n`一个 [给谁用的] + [核心功能] + [产品形态]`示例：\n\n- \"一个给自己用的极简待办清单网页\"\n- \"一个帮销售团队分析渠道ROI的数据看板\"\n- \"一个自动汇总每周 Excel 报表的脚本\"\n### 字段3：目标用户 ​\n\n目的：告诉 AI 要为谁设计。\n\n填写技巧：只保留与产品相关的特征。\n场景填写示例给自己用\"我自己（职场人士，每天处理5-10件事）\"给特定人群\"销售团队成员（需要每周提交业绩数据）\"给家人用\"我60岁的父母（智能手机操作不熟练）\"\n### 字段4：要解决的问题 ​\n\n目的：让 AI 理解你为什么要做这个。\n\n填写技巧：描述痛点，而不是解决方案。\n\n❌ 错误：\n\n`需要一个待办清单`✅ 正确：\n\n`怕遗漏重要事项。\n便签纸容易丢，手机备忘录打开太麻烦，\n需要一个\"打开就能用\"的工具。`\n### 字段5：核心功能（P0） ​\n目的：明确告诉 AI 必须实现什么。\n\n填写技巧：\n\n- 只列必须有的功能（P0）\n- 每个功能用一行，简明扼要\n- 建议 3-5 个，不超过 7 个\n示例：\nmarkdown\n`## 核心功能（P0）\n- [ ] 添加任务：输入框 + 添加按钮\n- [ ] 查看任务：以列表形式显示所有任务\n- [ ] 完成任务：点击勾选，显示删除线\n- [ ] 删除任务：点击删除按钮移除任务`\n### 字段6：不做的功能 ​\n目的：防止 AI \"自作主张\"添加功能。\n\n填写技巧：\n\n- 明确写出不要什么\n- 最好说明原因（帮 AI 理解边界）\n- 把 P2 功能也放这里（暂不做）\n示例：\nmarkdown\n`## 不做的功能\n- 不要登录注册（这是个人工具，不需要账号系统）\n- 不要云同步（本地存储够用，避免复杂度）\n- 不要分类标签（保持极简，第一版不需要）\n- 不要定时提醒（这是 P2 功能，以后再加）`\n### 字段7：用户流程 ​\n目的：让 AI 理解用户怎么使用这个产品。\n\n填写技巧：\n\n- 描述关键步骤，不需要太细\n- 格式：\"用户 [动作] → 看到 [结果]\"\n- 3-5 步为佳\n示例：\nmarkdown\n`## 用户流程\n1. 用户打开网页 → 看到任务列表（如果有历史任务）\n2. 用户在输入框输入任务 → 点击添加按钮 → 任务出现在列表中\n3. 用户完成任务 → 点击勾选 → 任务显示删除线\n4. 用户关闭网页 → 下次打开 → 数据还在`\n### 字段8：技术约束 ​\n目的：告诉 AI 技术层面的限制条件。\n\n常见约束类型：\n约束类型示例技术栈\"纯前端，用 HTML + CSS + JavaScript\"数据存储\"存在浏览器 localStorage，不需要后端\"界面语言\"界面用中文\"兼容性\"需要在手机浏览器上能用\"依赖限制\"不要用任何框架，保持原生\"\n如果你不懂技术，可以这样写：\nmarkdown\n`## 技术约束\n- 我是零基础，请用最简单的技术\n- 不需要数据库，数据存在本地即可\n- 界面用中文`\n### 字段9：成功标准 ​\n目的：定义什么时候算\"做完了\"。\n\n填写技巧：用可验证的行为描述。\n\n❌ 模糊：\n\n`能正常使用`✅ 具体：\nmarkdown\n`## 成功标准\n- [ ] 打开网页能看到输入框和添加按钮\n- [ ] 输入任务后点击添加，任务出现在列表\n- [ ] 点击任务可以勾选完成\n- [ ] 刷新页面后，之前添加的任务还在`\n## 完整填写示例：小李的待办清单 ​\nmarkdown\n```\n# 极简待办\n\n## 一句话描述\n一个给自己用的极简待办清单网页，只有添加和勾选功能\n\n## 目标用户\n我自己（职场人士，每天处理5-10件事务）\n\n## 要解决的问题\n怕遗漏重要事项。便签纸容易丢，手机备忘录打开太麻烦，\n需要一个\"打开浏览器就能用\"的极简工具。\n\n## 核心功能（P0）\n- [ ] 添加任务：输入框 + 添加按钮\n- [ ] 查看任务：列表显示所有待办\n- [ ] 完成任务：点击勾选，显示删除线\n- [ ] 删除任务：移除不需要的任务\n\n## 不做的功能\n- 不要登录注册（个人工具不需要）\n- 不要云同步（本地存储够用）\n- 不要分类标签（保持极简）\n- 不要日历视图（不是日程管理工具）\n- 不要定时提醒（以后再加）\n\n## 用户流程\n1. 打开网页 → 看到任务列表\n2. 输入任务 → 点击添加 → 任务出现\n3. 完成任务 → 点击勾选 → 显示删除线\n4. 关闭网页 → 下次打开 → 数据还在\n\n## 技术约束\n- 纯前端：HTML + CSS + JavaScript\n- 数据存储：浏览器 localStorage\n- 界面语言：中文\n- 样式：简洁美观，白底黑字\n\n## 成功标准\n- [ ] 能添加任务并显示在列表\n- [ ] 能勾选任务标记完成\n- [ ] 能删除任务\n- [ ] 刷新页面数据不丢失\n```\n\n## 不同场景的模板变体 ​\n\n### 变体A：数据分析场景 ​\nmarkdown\n```\n# [分析项目名称]\n\n## 一句话描述\n[分析什么数据、给谁看、回答什么问题]\n\n## 目标用户\n[谁会看这个分析结果]\n\n## 要回答的问题\n[这个分析要解决什么业务问题]\n\n## 数据来源\n[数据从哪里来，什么格式]\n\n## 分析维度\n- 维度1：[说明]\n- 维度2：[说明]\n- 维度3：[说明]\n\n## 输出形式\n[表格/图表/报告，具体格式要求]\n\n## 技术约束\n[用 Python/Excel/其他工具]\n\n## 成功标准\n[老板/同事看完后能做出什么决策]\n```\n\n### 变体B：自动化脚本场景 ​\nmarkdown\n```\n# [脚本名称]\n\n## 一句话描述\n[自动完成什么任务]\n\n## 使用者\n[谁会运行这个脚本]\n\n## 要解决的问题\n[现在手动做这件事有什么痛点]\n\n## 输入\n[脚本需要什么输入，格式是什么]\n\n## 输出\n[脚本产出什么结果，保存在哪里]\n\n## 处理逻辑\n1. 第一步：[做什么]\n2. 第二步：[做什么]\n3. 第三步：[做什么]\n\n## 技术约束\n[用什么语言，运行环境是什么]\n\n## 成功标准\n[跑完脚本后，应该看到什么结果]\n```\n\n## 让 AI 更容易理解的技巧 ​\n\n### 技巧1：使用 Markdown 格式 ​\nAI 对 Markdown 格式有很好的理解。用 `#` 标题、`-` 列表、`**` 加粗，比纯文本更清晰。\n\n### 技巧2：列表优于段落 ​\n\n❌ 段落式：\n\n`核心功能包括添加任务、查看任务列表、勾选完成和删除任务。`✅ 列表式：\nmarkdown\n`## 核心功能\n- 添加任务\n- 查看任务列表\n- 勾选完成\n- 删除任务`\n### 技巧3：避免歧义表述 ​\n❌ 歧义：\n\n`界面要好看`✅ 具体：\n\n`界面风格：简洁现代，白色背景，主色调蓝色，无边框圆角按钮`\n### 技巧4：用\"不要\"明确边界 ​\nAI 倾向于做得多而不是少。用\"不要\"明确告诉它边界。\nmarkdown\n`## 不做的功能\n- 不要添加任何我没要求的功能\n- 不要使用任何第三方库\n- 不要创建多个页面，只需要一个单页应用`\n## 本节核心要点 ​\n\n- ✅ PRD 模板有 8 个核心字段，每个都有明确用途\n- ✅ \"一句话描述\"用公式：给谁用 + 核心功能 + 产品形态\n- ✅ \"不做的功能\"和\"核心功能\"同样重要\n- ✅ \"成功标准\"要用可验证的行为描述\n- ✅ 使用 Markdown 格式、列表、明确的\"不要\"让 AI 更容易理解接下来，我们学习如何用 P0/P1/P2 优先级引导 AI 分阶段开发。",
      "word_count": 3884,
      "estimated_time": 7
    },
    {
      "id": "lesson-087",
      "chapter_id": "chapter-03",
      "lesson_number": 18,
      "title": "3.4.4 用优先级引导 AI 分阶段开发",
      "content": "# 3.4.4 用优先级引导 AI 分阶段开发 ​\n\n你在第二章用减法思维划分了 P0/P1/P2 功能优先级。现在的问题是：如何让 AI 按这个顺序分阶段工作？\n\n## 为什么要分阶段开发 ​\n\n### 问题场景 ​\n\n小李把完整的 PRD 一次性发给 AI：\n\n`请帮我实现这些功能：\n- 添加任务\n- 查看列表\n- 勾选完成\n- 删除任务\n- 分类标签\n- 优先级标记\n- 定时提醒\n- 数据统计`AI 返回了一大堆代码。小李运行后发现：\n\n- \"添加任务\"有 bug（输入为空也能添加）\n- \"分类标签\"功能做得很完整\n- \"定时提醒\"用了他看不懂的技术\n小李花了两小时调试，发现核心功能有问题，但锦上添花的功能却很完善。\n\n这就是\"一次性给太多\"的典型后果。\n\n### 分阶段的三大好处 ​\n好处说明减少遗漏AI 一次处理 3-5 个功能比处理 10 个更不容易出错及时验证每轮结束后可以测试，发现问题及时修正灵活调整P0 做完后可能发现 P1 不需要了，省去无用功\n## 三轮对话模式 ​\n\n分阶段开发的核心是：每轮只做一个优先级的功能，验证通过后再进入下一轮。\n\n`┌─────────────┐     ┌─────────────┐     ┌─────────────┐\n│   第一轮    │────▶│   第二轮    │────▶│   第三轮    │\n│  实现 P0    │     │  添加 P1    │     │  添加 P2    │\n│             │     │             │     │  (可选)     │\n└─────────────┘     └─────────────┘     └─────────────┘\n      │                   │                   │\n      ▼                   ▼                   ▼\n   验证测试            验证测试            验证测试`\n## 第一轮：实现 P0 功能 ​\n\n### Prompt 模板 ​\nmarkdown\n```\n请根据以下 PRD 实现第一版，**只做 P0 功能，不要做任何额外的事情**。\n\n[粘贴你的 PRD]\n\n特别强调：\n- 只实现\"核心功能\"部分列出的功能\n- 不要添加任何 PRD 中没有提到的功能\n- 代码要简洁，能跑起来就行\n```\n\n### 小李的实际 Prompt ​\nmarkdown\n```\n请根据以下 PRD 实现第一版，只做 P0 功能。\n\n# 极简待办\n\n## 一句话描述\n一个给自己用的极简待办清单网页\n\n## 目标用户\n我自己（职场人士，每天处理5-10件事务）\n\n## 要解决的问题\n怕遗漏重要事项，需要一个打开就能用的极简工具\n\n## 核心功能（P0，只做这些）\n- 添加任务：输入框 + 添加按钮\n- 查看任务：列表显示所有待办\n- 完成任务：点击勾选，显示删除线\n\n## 不做的功能\n- 不要登录注册\n- 不要删除功能（P1，下一轮做）\n- 不要分类标签\n- 不要云同步\n\n## 技术约束\n- 纯前端：HTML + CSS + JavaScript\n- 数据存储：浏览器 localStorage\n- 界面语言：中文\n\n特别强调：只做上面列出的 P0 功能，不要添加任何额外功能。\n```\n\n### 第一轮验证清单 ​\nAI 返回代码后，按这个清单验证：\n\n- [ ] 能添加任务吗？\n- [ ] 任务能显示在列表吗？\n- [ ] 能勾选完成吗？\n- [ ] 刷新后数据还在吗？\n- [ ] 有没有多做了什么功能？\n全部通过后，才进入第二轮。\n\n## 第二轮：添加 P1 功能 ​\n\n### Prompt 模板 ​\nmarkdown\n`P0 功能已完成并验证通过。现在请添加 P1 功能。\n\n## 当前已有功能\n- 添加任务 ✓\n- 查看列表 ✓\n- 勾选完成 ✓\n\n## 本轮要添加的 P1 功能\n- [P1 功能1]\n- [P1 功能2]\n\n## 注意事项\n- 不要修改已有的 P0 功能代码（除非是 bug 修复）\n- 不要添加任何 P1 以外的功能\n- 保持代码风格一致`\n### 小李的实际 Prompt ​\nmarkdown\n```\nP0 功能已完成并验证通过。现在请添加 P1 功能。\n\n## 当前已有功能\n- 添加任务 ✓\n- 查看列表 ✓\n- 勾选完成 ✓\n\n## 本轮要添加的 P1 功能\n- 删除任务：每个任务右边有个删除按钮，点击后移除\n- 任务计数：显示\"待办 X 项，已完成 Y 项\"\n\n## 注意事项\n- 不要修改已有的 P0 功能\n- 不要添加分类、标签等其他功能\n- 删除按钮样式要和整体风格一致\n```\n\n### 第二轮验证清单 ​\n\n- [ ] P0 功能还能正常工作吗？\n- [ ] 删除功能正常吗？\n- [ ] 计数显示正确吗？\n- [ ] 删除后计数会更新吗？\n## 第三轮：添加 P2 功能（可选） ​\n第三轮是可选的。如果 P0 + P1 已经满足需求，可以到此为止。\n\n### Prompt 模板 ​\nmarkdown\n`P1 功能已完成。如果时间允许，现在可以添加 P2 功能。\n\n## 当前已有功能\n- [P0 功能列表] ✓\n- [P1 功能列表] ✓\n\n## 可选的 P2 功能（按优先级选择 1-2 个）\n- [P2 功能1]\n- [P2 功能2]\n- [P2 功能3]\n\n请先问我想优先做哪个，然后再实现。`\n## 阶段切换的关键句式 ​\n以下是一些在阶段切换时很有用的句式：\n\n### 开始新阶段 ​\n\n`\"P0 验证通过，请继续添加 P1 功能...\"\n\"上一轮功能已确认无误，现在进入下一阶段...\"\n\"第一版完成，现在迭代第二版...\"`\n### 发现问题时 ​\n\n```\n\"在测试 P0 时发现一个问题：[描述问题]。请先修复这个，然后再继续 P1。\"\n\"添加任务时输入为空也能添加，这是个 bug。请加上非空校验。\"\n```\n\n### 想调整计划时 ​\n\n```\n\"P0 做完后我发现其实不需要 P1 的删除功能了，请直接跳到 P2 的分类标签。\"\n\"这个功能比想象中复杂，我们先暂停，我重新想想需求。\"\n```\n\n## 完整案例：小李的三轮开发 ​\n\n### 第一轮对话 ​\n小李：\n\n`请根据以下 PRD 实现第一版...（P0 功能）`AI：返回 HTML + CSS + JS 代码\n\n小李测试：\n\n- 添加任务 ✓\n- 查看列表 ✓\n- 勾选完成 ✓\n- 刷新数据保留 ✓\n### 第二轮对话 ​\n\n小李：\n\n`P0 验证通过。请添加 P1 功能：\n- 删除任务\n- 任务计数`AI：返回更新后的代码\n\n小李测试：\n\n- P0 功能正常 ✓\n- 删除功能正常 ✓\n- 计数显示正确 ✓\n### 第三轮对话 ​\n\n小李：\n\n`P1 完成。P2 功能里我只想做\"任务优先级标记\"，其他不要。`AI：返回带优先级功能的代码\n\n小李测试：全部通过，项目完成。\n\n## 常见问题 ​\n\n### Q：P0 还没做完，能不能先做个 P1 功能？ ​\n\nA：不建议。P0 是核心功能，如果核心有问题，后面做的都可能白做。老老实实按顺序来。\n\n### Q：AI 自作主张加了功能怎么办？ ​\n\nA：告诉它删掉，或者重新生成。\n\n`\"我看到你添加了排序功能，但这不在 PRD 里。请删掉这个功能，只保留我要求的。\"`\n### Q：每轮都要把 PRD 全发一遍吗？ ​\nA：第一轮发完整 PRD，后面只发变化的部分就行。AI 通常能记住上下文。\n\n### Q：分阶段会不会太慢？ ​\n\nA：表面上多对话了几轮，但减少了大量返工时间。一次性做完往往要花更多时间调试。\n\n## 验证检查点模板 ​\n\n每轮结束后，用这个模板做检查：\nmarkdown\n`## 第 [N] 轮验证检查\n\n### 功能验证\n- [ ] [功能1] 正常工作\n- [ ] [功能2] 正常工作\n- [ ] [功能3] 正常工作\n\n### 回归测试（确保之前的功能没坏）\n- [ ] P0 功能仍然正常\n- [ ] P1 功能仍然正常（如果已实现）\n\n### 边界情况\n- [ ] 空输入处理正确\n- [ ] 刷新后数据保留\n- [ ] 多次操作不会出错\n\n### 决策\n- [ ] 全部通过 → 进入下一轮\n- [ ] 有问题 → 先修复，再继续`\n## 本节核心要点 ​\n\n- ✅ 分阶段开发能减少遗漏、及时验证、灵活调整\n- ✅ 三轮模式：P0 → 验证 → P1 → 验证 → P2（可选）\n- ✅ 每轮开始时明确\"只做这些，不做其他\"\n- ✅ 每轮结束时用检查清单验证\n- ✅ 发现问题先修复，确认无误再进入下一轮接下来，我们通过一个完整案例，体验从想法到 PRD 的全过程。",
      "word_count": 3713,
      "estimated_time": 7
    },
    {
      "id": "lesson-088",
      "chapter_id": "chapter-03",
      "lesson_number": 19,
      "title": "3.4.5 PRD 实战：从想法到文档",
      "content": "# 3.4.5 PRD 实战：从想法到文档 ​\n\n本节通过一个完整案例，展示从\"我想做一个...\"到\"PRD 写完，可以开始开发\"的全过程。\n\n## 实战流程概览 ​\n\n`1. 从模糊想法开始\n      ↓\n2. 快速回答灵魂三问\n      ↓\n3. 划分功能优先级\n      ↓\n4. 填写 PRD 模板\n      ↓\n5. 让 AI 检查 PRD\n      ↓\n6. 验证 AI 的理解\n      ↓\n7. 开始第一轮开发`\n## 完整案例：小李的待办清单 ​\n\n### 第一步：从模糊想法开始 ​\n小李的想法很简单：\n\n\"我每天有很多事要做，经常忘记。想做一个待办清单。\"\n\n这个想法太模糊了。如果直接告诉 AI，会得到各种各样的版本。\n\n### 第二步：快速回答灵魂三问（3分钟） ​\n\n小李用第二章学的灵魂三问快速梳理：\n问题小李的回答用户是谁？我自己，职场人士，每天 5-10 件事痛点在哪？怕遗漏重要事项。便签纸丢，手机备忘录麻烦为什么选你？比便签纸持久，比复杂App简单\n### 第三步：划分功能优先级（2分钟） ​\n\n小李用第二章的减法思维，把想到的功能分三类：\n\nP0（必须有，没有就不能用）\n\n- 添加任务\n- 查看任务列表\n- 标记完成\nP1（应该有，能让产品更好用）\n\n- 删除任务\n- 任务计数\nP2（可以有，锦上添花）\n\n- 分类标签\n- 优先级标记\n- 定时提醒\n不做清单\n\n- 登录注册\n- 云同步\n- 团队协作\n- 日历视图\n### 第四步：填写 PRD 模板（5分钟） ​\n\n小李打开 3.4.3 的模板，开始填写：\nmarkdown\n`# 极简待办\n\n## 一句话描述\n一个给自己用的极简待办清单网页，只有添加和勾选功能\n\n## 目标用户\n我自己（职场人士，每天处理5-10件事务）\n\n## 要解决的问题\n怕遗漏重要事项。\n便签纸容易丢，手机备忘录打开太麻烦，\n需要一个\"打开浏览器就能用\"的极简工具。\n\n## 核心功能（P0）\n- [ ] 添加任务：输入框 + 添加按钮\n- [ ] 查看任务：列表显示所有待办\n- [ ] 完成任务：点击勾选，显示删除线\n\n## 不做的功能\n- 不要登录注册（个人工具不需要）\n- 不要云同步（本地存储够用）\n- 不要分类标签（保持极简）\n- 不要日历视图（不是日程管理工具）\n- 不要定时提醒（以后再加）\n- 不要删除功能（P1，下一轮做）\n\n## 用户流程\n1. 打开网页 → 看到任务列表（或空状态提示）\n2. 输入任务 → 点击添加 → 任务出现在列表\n3. 完成任务 → 点击勾选 → 显示删除线\n4. 关闭网页 → 下次打开 → 数据还在\n\n## 技术约束\n- 纯前端：HTML + CSS + JavaScript\n- 数据存储：浏览器 localStorage\n- 界面语言：中文\n- 样式：简洁美观，白底黑字\n\n## 成功标准\n- [ ] 能添加任务并显示在列表\n- [ ] 能勾选任务标记完成\n- [ ] 刷新页面数据不丢失`\n### 第五步：让 AI 检查 PRD ​\nPRD 写完后，小李请 AI 帮忙检查：\nmarkdown\n`请帮我检查这份 PRD 是否有遗漏或歧义。\n\n[粘贴上面的 PRD]\n\n请回答：\n1. 这份 PRD 是否足够清晰，你能准确理解我要什么？\n2. 有没有哪些地方你不确定该怎么做？\n3. 有没有我可能遗漏的边界情况？`AI 的反馈：\n\n- 整体清晰，我能理解你要做一个极简待办清单。\n- 有几个不确定的地方： 任务为空时，添加按钮是否禁用？\n- 已完成的任务放在列表什么位置（底部/原位置）？\n- 空状态提示具体显示什么文字？\n- 可能遗漏的边界情况： 任务文字过长如何处理？\n- 任务数量上限？\n小李看了 AI 的反馈，补充了几点：\nmarkdown\n`## 补充说明\n- 任务为空时，添加按钮可点击但不添加（不报错）\n- 已完成任务保持原位置，只是显示删除线\n- 空状态显示\"暂无任务，添加一个试试\"\n- 任务文字过长自动换行\n- 第一版不设数量上限`\n### 第六步：验证 AI 的理解 ​\n小李让 AI 复述理解，确保双方对齐：\nmarkdown\n`请用你自己的话描述一下，你理解我要做什么产品？\n包括：用户是谁、解决什么问题、有哪些功能、没有哪些功能。`AI 的复述：\n\n你要做一个极简待办清单网页，给自己（职场人士）用。\n\n解决的问题：怕遗漏重要事项，需要一个比便签纸更持久、比手机备忘录更方便的工具。\n\n核心功能（P0）：\n\n- 添加任务（输入框+按钮）\n- 查看任务列表\n- 勾选完成（显示删除线）\n明确不做：\n\n- 登录注册、云同步、分类标签、日历、提醒、删除功能\n技术方案：纯前端（HTML+CSS+JS），数据存localStorage，中文界面。\n\n小李确认理解正确，可以开始开发了。\n\n### 第七步：开始第一轮开发 ​\n\n小李按 3.4.4 的方法，发起第一轮对话：\nmarkdown\n`请根据这份 PRD 实现第一版，只做 P0 功能。\n\n[粘贴完整 PRD]\n\n特别强调：只做核心功能部分列出的 3 个功能，不要添加任何额外功能。`AI 返回代码后，小李按验证清单测试，确认无误后进入 P1 开发。\n\n## 你的练习：三种场景任选其一 ​\n\n现在轮到你了。请从以下三个场景中选一个，完成你的第一份 PRD：\n\n### 场景 A：个人工具 ​\n\n\"我想做一个每日打卡工具，记录自己每天喝了多少杯水。\"\n\n提示：\n\n- 用户是谁？（你自己）\n- 核心功能是什么？（记录、查看）\n- 不需要什么？（统计图表？社交分享？）\n### 场景 B：数据分析 ​\n\n\"我想分析公司上个月的销售数据，看看哪个渠道效果最好。\"\n\n提示：\n\n- 分析给谁看？（老板？自己？）\n- 要回答什么问题？（哪个渠道ROI最高？）\n- 数据从哪来？（Excel？）\n- 输出什么形式？（图表？表格？）\n### 场景 C：自动化脚本 ​\n\n\"我每周都要把10个Excel文件合并成一个，想让这个过程自动化。\"\n\n提示：\n\n- 输入是什么？（10个Excel，放在某个文件夹）\n- 输出是什么？（一个合并后的Excel）\n- 处理逻辑是什么？（按什么顺序合并？）\n## PRD 自检清单 ​\n\n写完 PRD 后，用这个清单检查：\n\n### 内容完整性 ​\n\n- [ ] 一句话描述清楚了\"给谁用\"和\"做什么\"\n- [ ] 目标用户描述了与产品相关的特征\n- [ ] 要解决的问题描述了痛点，而不是解决方案\n- [ ] 核心功能（P0）不超过 5 个\n- [ ] \"不做清单\"明确列出了边界\n- [ ] 用户流程覆盖了关键步骤\n- [ ] 技术约束说明了技术限制\n- [ ] 成功标准是可验证的\n### AI 可读性 ​\n\n- [ ] 使用了 Markdown 格式\n- [ ] 用列表而不是段落\n- [ ] 没有模糊表述（如\"好看\"、\"方便\"）\n- [ ] \"不要\"的边界足够明确\n### 与第二章的衔接 ​\n\n- [ ] 灵魂三问的答案融入了\"用户\"和\"问题\"部分\n- [ ] P0/P1/P2 划分来自减法思维\n- [ ] 用户流程简化自用户旅程地图\n## 本节核心要点 ​\n\n- ✅ 从模糊想法到 PRD，只需要 10 分钟\n- ✅ 灵魂三问 + 减法思维 = PRD 的核心内容\n- ✅ 写完后让 AI 检查，补充遗漏的边界情况\n- ✅ 让 AI 复述理解，确保双方对齐\n- ✅ PRD 确认无误后，再开始第一轮开发\n## 本章总结 ​\n\n恭喜你完成了 3.4 节的学习。现在你已经掌握了：\n\n- PRD 是什么：给 AI 的任务书，不是给老板的报告\n- 内容从哪来：整合第二章的灵魂三问、减法思维、用户旅程\n- 怎么写：用精简版模板，8个核心字段\n- 怎么用：P0→P1→P2 分阶段开发\n- 怎么验证：让 AI 检查、复述、确认\n你已经拥有了从\"想法\"到\"AI开始执行\"的完整方法论。\n\n下一节，我们将学习迭代对话的艺术——当 AI 的第一版不完美时，如何通过多轮对话逐步逼近理想结果。",
      "word_count": 3367,
      "estimated_time": 6
    },
    {
      "id": "lesson-089",
      "chapter_id": "chapter-03",
      "lesson_number": 20,
      "title": "3.5.1 为什么一次提问往往不够",
      "content": "# 3.5.1 为什么一次提问往往不够 ​\n\n## 经过本节学习，你将掌握 ​\n\n- 理解「一次搞定」为什么是不现实的预期\n- 认识导致首次输出不完美的三个原因\n- 建立正确的迭代心态：AI 是对话伙伴，不是读心术\n## 你可能有过这样的经历 ​\n\n你花了十分钟写了一个详细的提示词，满怀期待地按下回车。结果 AI 给你的东西——虽然看起来很专业——却完全不是你想要的。\n\n你开始怀疑：是不是我的提示词写得不够好？是不是我不够聪明？是不是 AI 根本没用？\n\n都不是。\n\n这只是说明：你和 AI 之间需要更多对话。就像你和一个新同事合作，第一次交接任务时，对方很难完全理解你的意图。这不是谁的错，而是沟通的本质。\n\n## 首次输出不完美的三个原因 ​\n\n### 原因一：信息不对称 ​\n\n你脑子里有完整的画面，但 AI 只能看到你写下来的文字。\n\n`你心里想的：\n\"我要一个简洁的输入框，放在页面顶部，按回车就能添加任务，\n 输入框要有圆角，placeholder 写'添加新任务...'，\n 添加成功后自动清空输入框\"\n\n你实际写的：\n\"帮我做一个添加任务的功能\"`你以为自己说清楚了，但 AI 只收到了 10% 的信息。\n\n### 原因二：需求本身模糊 ​\n\n很多时候，你自己也不完全清楚想要什么——直到看到第一版输出。\n\n这很正常。产品设计领域有句话：「用户不知道自己要什么，直到你展示给他看。」你和 AI 的关系也类似。第一轮输出的价值，往往不是「直接能用」，而是「帮你想清楚」。\n\n### 原因三：AI 的理解偏差 ​\n\n即使你写得很详细，AI 也可能理解错。因为自然语言是模糊的。\n\n`你说：\"做一个简单的表单\"\n\nAI 可能理解为：\n- 只有一个输入框的表单？\n- 没有验证逻辑的表单？\n- 样式朴素的表单？\n- 功能精简的表单？`「简单」对不同人意味着不同的事情。AI 只能猜测你的意图。\n\n## 一个类比：装修房子 ​\n\n假设你请了一个装修师傅，你说：「我要一个舒适的客厅。」\n\n师傅不可能一次就装修出你心中完美的样子。你们需要：\n\n- 第一轮：师傅给你看设计方案草图（方向对不对？）\n- 第二轮：你提出修改意见，师傅调整（沙发换个位置，窗帘换个颜色）\n- 第三轮：细节打磨（灯光亮度、抱枕摆放）\nAI 编程也是一样的过程。期望一次到位，是不合理的预期。\n\n## 迭代思维：每次对话都在逼近目标 ​\n\n换一个角度看问题：\n传统思维迭代思维第一次没做对 = 失败第一次输出 = 有价值的起点需要多次修改 = AI 不行多轮对话 = 协作的正常过程追求一次完美追求持续改进\n核心转变：把 AI 当作一个聪明的实习生，而不是全知全能的神。你需要和它「聊」，而不是「命令」。\n\n## 差提示词 vs 好提示词 ​\n\n理解了迭代思维后，你会发现：好的提示词不是追求一次完美，而是为迭代留下空间。\n\n### ❌ 差提示词：试图一次说完所有事 ​\n\n`帮我用 React + TypeScript + Tailwind CSS 实现一个待办清单的添加任务功能，\n要有输入框和按钮，输入框要有 placeholder，按钮要有 hover 效果，\n点击按钮或按回车都能添加任务，要验证空输入，空输入时显示错误提示，\n添加成功后清空输入框，任务数据存到 state 里，用 useState hook，\n组件命名为 AddTaskForm，导出为默认导出...`问题：信息量太大，AI 容易遗漏细节。而且你可能还没想清楚所有需求。\n\n### ✅ 好提示词：先建立方向，再逐步细化 ​\n\n第一轮提示词：\n\n`我正在开发一个待办清单应用，使用 React + TypeScript + Tailwind CSS。\n\n请帮我实现「添加任务」功能：\n- 一个输入框 + 一个添加按钮\n- 点击按钮可以添加任务到列表\n\n先给我一个基础实现，我们后面再逐步完善。`看到第一轮输出后，第二轮提示词：\n\n`基础功能可以了。请加上以下改进：\n1. 支持按回车键添加任务\n2. 添加空输入验证，空输入时按钮禁用\n3. 添加成功后自动清空输入框`第三轮提示词：\n\n`功能完整了。最后优化一下代码结构：\n- 把验证逻辑抽成一个独立的 validateTaskInput 函数\n- 把样式类名用变量统一管理`优势：每一轮都有明确焦点，AI 不容易遗漏。而且你可以根据上一轮的输出调整下一轮的需求。\n\n## 实战心态调整 ​\n场景错误反应正确反应AI 第一次输出不完美\"AI 太笨了\"\"这是正常的起点\"需要多次修改\"太麻烦了\"\"这是协作的过程\"发现自己需求变了\"我怎么没想清楚\"\"第一轮输出帮我想清楚了\"\n## 本节要点 ​\n\n✓ 一次搞定是幻觉：首次输出不完美是常态，不是失败\n\n✓ 三个原因：信息不对称、需求模糊、AI 理解偏差\n\n✓ 装修类比：AI 编程就像装修房子，需要「看效果 → 提意见 → 再调整」\n\n✓ 迭代心态：把 AI 当作对话伙伴，而不是命令执行者\n\n✓ 分阶段提问：先建立方向，再逐步细化，比一次说完更有效\n\n下一节，我们来看迭代对话的具体操作模式：三阶段迭代模型。",
      "word_count": 2131,
      "estimated_time": 4
    },
    {
      "id": "lesson-090",
      "chapter_id": "chapter-03",
      "lesson_number": 21,
      "title": "3.5.2 迭代对话的基本模式",
      "content": "# 3.5.2 迭代对话的基本模式 ​\n\n## 经过本节学习，你将掌握 ​\n\n- 三阶段迭代模型：看方向 → 改问题 → 磨细节\n- 每一轮对话的关键动作和检查点\n- 一个完整的迭代对话示例（小李的待办清单）\n- 可直接复制使用的迭代对话模板\n## 三阶段迭代模型 ​\n\n迭代对话不是漫无目的地来回修改。高效的迭代遵循一个清晰的模式：\n\n`第一轮：看方向\n    ↓\n  方向对吗？整体思路对吗？\n    ↓\n第二轮：改问题\n    ↓\n  功能完整吗？有没有明显缺陷？\n    ↓\n第三轮：磨细节\n    ↓\n  代码结构好吗？有没有边界情况？\n    ↓\n  完成`\n### 第一轮：看方向 ​\n目标：确认 AI 理解了你的意图，整体方向正确。\n\n关键动作：\n\n- 提出核心需求，不要纠结细节\n- 明确告诉 AI「先给我一个基础实现」\n- 重点看：AI 的理解对不对？大方向对不对？\n检查点：\n\n- [ ] AI 做的是你想要的功能吗？\n- [ ] 技术方案和你预期一致吗？\n- [ ] 如果方向错了，现在就要纠正\n常见问题：方向错误。比如你想要一个弹窗，AI 给你做了一个新页面。\n\n### 第二轮：改问题 ​\n\n目标：修正第一轮的明显问题，补充遗漏的功能。\n\n关键动作：\n\n- 指出具体问题，不要说「不太对」\n- 列出需要添加的功能点\n- 可以一次提多个修改，但不要超过 3-5 个\n检查点：\n\n- [ ] 核心功能都实现了吗？\n- [ ] 交互逻辑正确吗？\n- [ ] 有没有明显的 bug？\n常见问题：功能缺失或逻辑错误。比如缺少输入验证，或者按钮点击没反应。\n\n### 第三轮：磨细节 ​\n\n目标：优化代码结构，处理边界情况，提升质量。\n\n关键动作：\n\n- 关注代码的可维护性\n- 检查边界情况（空输入、超长输入、特殊字符）\n- 优化命名、注释、结构\n检查点：\n\n- [ ] 代码结构清晰吗？\n- [ ] 边界情况处理了吗？\n- [ ] 代码可以直接用于生产吗？\n常见问题：代码能用但不够好。比如逻辑全写在一个函数里，或者没有错误处理。\n\n## 完整案例：小李的「添加任务」功能 ​\n\n让我们看小李如何用三阶段模型，迭代出一个满意的添加任务功能。\n\n### 第一轮对话：看方向 ​\n\n小李的提示词：\n\n`我正在开发一个待办清单应用，使用 React + TypeScript + Tailwind CSS。\n\n请帮我实现「添加任务」功能：\n- 一个输入框 + 一个添加按钮\n- 点击按钮可以添加任务到列表\n\n先给我一个基础实现，后续再完善。`AI 的输出：\ntsx\n`import { useState } from 'react';\n\ninterface Task {\n  id: number;\n  title: string;\n}\n\nexport default function AddTaskForm() {\n  const [tasks, setTasks] = useState<Task[]>([]);\n  const [inputValue, setInputValue] = useState('');\n\n  const handleAdd = () => {\n    const newTask: Task = {\n      id: Date.now(),\n      title: inputValue,\n    };\n    setTasks([...tasks, newTask]);\n    setInputValue('');\n  };\n\n  return (\n    <div>\n      <input\n        type=\"text\"\n        value={inputValue}\n        onChange={(e) => setInputValue(e.target.value)}\n        className=\"border p-2\"\n      />\n      <button onClick={handleAdd} className=\"bg-blue-500 text-white p-2 ml-2\">\n        添加\n      </button>\n      <ul>\n        {tasks.map((task) => (\n          <li key={task.id}>{task.title}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}`小李的检查：\n\n- ✅ 方向对：输入框 + 按钮 + 任务列表\n- ✅ 技术栈对：React + TypeScript + Tailwind\n- ⚠️ 但有问题：没有输入验证，可以添加空任务\n判断：方向正确，进入第二轮。\n\n### 第二轮对话：改问题 ​\n\n小李的提示词：\n\n`基础功能可以了，请加上以下改进：\n\n1. 支持按回车键添加任务（不只是点击按钮）\n2. 添加空输入验证：\n   - 输入为空时，按钮显示为禁用状态\n   - 尝试添加空任务时，不执行任何操作\n3. 输入框添加 placeholder：\"输入新任务...\"`AI 的输出：\ntsx\n`import { useState } from 'react';\n\ninterface Task {\n  id: number;\n  title: string;\n}\n\nexport default function AddTaskForm() {\n  const [tasks, setTasks] = useState<Task[]>([]);\n  const [inputValue, setInputValue] = useState('');\n\n  const isInputEmpty = inputValue.trim() === '';\n\n  const handleAdd = () => {\n    if (isInputEmpty) return;\n    \n    const newTask: Task = {\n      id: Date.now(),\n      title: inputValue.trim(),\n    };\n    setTasks([...tasks, newTask]);\n    setInputValue('');\n  };\n\n  const handleKeyDown = (e: React.KeyboardEvent) => {\n    if (e.key === 'Enter') {\n      handleAdd();\n    }\n  };\n\n  return (\n    <div>\n      <input\n        type=\"text\"\n        value={inputValue}\n        onChange={(e) => setInputValue(e.target.value)}\n        onKeyDown={handleKeyDown}\n        placeholder=\"输入新任务...\"\n        className=\"border p-2 rounded\"\n      />\n      <button\n        onClick={handleAdd}\n        disabled={isInputEmpty}\n        className={`p-2 ml-2 rounded ${\n          isInputEmpty\n            ? 'bg-gray-300 cursor-not-allowed'\n            : 'bg-blue-500 text-white hover:bg-blue-600'\n        }`}\n      >\n        添加\n      </button>\n      <ul className=\"mt-4\">\n        {tasks.map((task) => (\n          <li key={task.id} className=\"py-1\">{task.title}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}`小李的检查：\n\n- ✅ 回车添加：已实现\n- ✅ 空输入验证：已实现\n- ✅ placeholder：已添加\n- ⚠️ 代码结构问题：验证逻辑和 UI 逻辑混在一起\n判断：功能完整，进入第三轮优化结构。\n\n### 第三轮对话：磨细节 ​\n\n小李的提示词：\n\n`功能完整了，请优化代码结构：\n\n1. 把输入验证逻辑抽成独立函数 validateTaskInput\n2. 把样式类名用常量统一管理（方便后续修改）\n3. 添加必要的注释说明组件用途`AI 的最终输出：\ntsx\n`import { useState } from 'react';\n\n// 任务数据类型\ninterface Task {\n  id: number;\n  title: string;\n}\n\n// 样式常量\nconst STYLES = {\n  input: 'border p-2 rounded focus:outline-none focus:ring-2 focus:ring-blue-300',\n  buttonBase: 'p-2 ml-2 rounded transition-colors',\n  buttonEnabled: 'bg-blue-500 text-white hover:bg-blue-600',\n  buttonDisabled: 'bg-gray-300 cursor-not-allowed text-gray-500',\n  taskItem: 'py-1 border-b border-gray-100',\n};\n\n// 验证任务输入\nfunction validateTaskInput(input: string): boolean {\n  return input.trim().length > 0;\n}\n\n/**\n * 添加任务表单组件\n * 功能：输入框 + 添加按钮，支持回车添加，包含空输入验证\n */\nexport default function AddTaskForm() {\n  const [tasks, setTasks] = useState<Task[]>([]);\n  const [inputValue, setInputValue] = useState('');\n\n  const isValid = validateTaskInput(inputValue);\n\n  const handleAdd = () => {\n    if (!isValid) return;\n    \n    const newTask: Task = {\n      id: Date.now(),\n      title: inputValue.trim(),\n    };\n    setTasks([...tasks, newTask]);\n    setInputValue('');\n  };\n\n  const handleKeyDown = (e: React.KeyboardEvent) => {\n    if (e.key === 'Enter') {\n      handleAdd();\n    }\n  };\n\n  return (\n    <div className=\"p-4\">\n      <div className=\"flex\">\n        <input\n          type=\"text\"\n          value={inputValue}\n          onChange={(e) => setInputValue(e.target.value)}\n          onKeyDown={handleKeyDown}\n          placeholder=\"输入新任务...\"\n          className={STYLES.input}\n        />\n        <button\n          onClick={handleAdd}\n          disabled={!isValid}\n          className={`${STYLES.buttonBase} ${\n            isValid ? STYLES.buttonEnabled : STYLES.buttonDisabled\n          }`}\n        >\n          添加\n        </button>\n      </div>\n      <ul className=\"mt-4\">\n        {tasks.map((task) => (\n          <li key={task.id} className={STYLES.taskItem}>\n            {task.title}\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}`小李的检查：\n\n- ✅ 验证逻辑独立：`validateTaskInput` 函数\n- ✅ 样式统一管理：`STYLES` 常量\n- ✅ 注释清晰：组件用途说明\n- ✅ 代码可维护：结构清晰，易于扩展\n结果：三轮对话，从「能用」到「好用」。\n\n## 每轮对话的行动清单 ​\n阶段你的重点提示词关键词检查什么第一轮看方向\"基础实现\"、\"先给我一个...\"方向对不对？理解对不对？第二轮改问题\"请加上...\"、\"修正...\"功能完整吗？逻辑对吗？第三轮磨细节\"优化结构\"、\"抽成函数\"代码好维护吗？边界情况？\n## 可复制模板：迭代对话脚本 ​\n\n### 第一轮模板：建立方向 ​\nmarkdown\n`我正在开发 [项目名称]，使用 [技术栈]。\n\n请帮我实现 [功能名称]：\n- [核心需求1]\n- [核心需求2]\n\n先给我一个基础实现，我们后续再逐步完善。`\n### 第二轮模板：修正问题 ​\nmarkdown\n```\n基础功能可以了，请加上以下改进：\n\n1. [需要添加的功能/修正的问题]\n2. [需要添加的功能/修正的问题]\n3. [需要添加的功能/修正的问题]\n```\n\n### 第三轮模板：优化细节 ​\nmarkdown\n```\n功能完整了，请优化代码：\n\n1. [结构优化要求]\n2. [边界情况处理]\n3. [其他质量要求]\n```\n\n## 什么时候可以跳过某个阶段？ ​\n情况可以跳过原因任务非常简单第三轮代码量小，不需要结构优化第一轮输出已经很好第二轮直接进入细节打磨只是快速原型验证第三轮后续会重写，不需要完美\n## 迭代次数的经验值 ​\n任务复杂度典型迭代次数示例简单（单一功能）1-2 轮一个按钮、一个输入框中等（多个功能）2-3 轮一个表单、一个列表组件复杂（完整模块）3-5 轮一个完整页面、一个复杂交互如果超过 5 轮还没达到满意效果，考虑是不是需求本身不够清晰，或者应该开始新对话。\n\n## 本节要点 ​\n\n✓ 三阶段模型：看方向 → 改问题 → 磨细节\n\n✓ 每轮有焦点：第一轮不纠结细节，第二轮不纠结结构，第三轮专注质量\n\n✓ 明确检查点：每轮结束都有清晰的检查标准\n\n✓ 灵活调整：简单任务可以跳过阶段，复杂任务可能需要更多轮次\n\n下一节，我们来学习如何给 AI 有效的反馈——这是迭代成功的关键。",
      "word_count": 6567,
      "estimated_time": 13
    },
    {
      "id": "lesson-091",
      "chapter_id": "chapter-03",
      "lesson_number": 22,
      "title": "3.5.3 有效反馈的艺术",
      "content": "# 3.5.3 有效反馈的艺术 ​\n\n## 经过本节学习，你将掌握 ​\n\n- 区分有效反馈和无效反馈\n- 使用 SBI 框架（情境-行为-影响）组织反馈\n- 根据问题类型选择合适的反馈粒度\n- 获得一个可直接使用的反馈句式库\n## 反馈决定迭代质量 ​\n\n迭代对话的核心是「反馈-修正」循环。你给的反馈质量，直接决定 AI 的修正质量。\n\n同样是对一段代码不满意：\n\n`❌ 无效反馈：\"这不对，重新做\"\n✅ 有效反馈：\"handleSubmit 函数缺少错误处理，当 API 请求失败时会导致白屏\"`第一种反馈，AI 只能猜你不满意什么。第二种反馈，AI 能精准定位问题并修复。\n\n## 无效反馈 vs 有效反馈对比 ​\n无效反馈问题有效反馈\"这不对\"不知道哪里不对\"第 15 行的条件判断逻辑有误，应该用 `&&` 而不是 `\"太复杂了\"不知道怎么简化\"请移除 X 和 Y 功能，只保留核心的 Z 功能\"\"不够好\"不知道好的标准\"请把函数拆分成更小的单元，每个函数不超过 20 行\"\"样式不对\"不知道期望什么样式\"按钮颜色改成 #3B82F6，圆角改成 8px\"\"有 bug\"不知道 bug 是什么\"当输入超过 100 个字符时，页面会卡死\"\n规律：有效反馈 = 具体位置 + 具体问题 + （可选）期望结果\n\n## SBI 反馈框架 ​\n\nSBI 是一个来自管理学的反馈框架，用于给 AI 反馈同样有效。\n\n### 框架结构 ​\n\n`S - Situation（情境）：问题出现在哪里\nB - Behavior（行为）：具体是什么问题\nI - Impact（影响）：这个问题会导致什么后果`\n### 示例对比 ​\n场景：AI 生成的表单没有验证逻辑\n\n`❌ 无 SBI：\n\"表单验证有问题\"\n\n✅ 使用 SBI：\n\"在 handleSubmit 函数中（S），\n 没有检查邮箱格式是否正确（B），\n 这会导致用户输入无效邮箱也能提交成功（I）。\n 请添加邮箱格式验证。\"`场景：AI 生成的代码性能差\n\n`❌ 无 SBI：\n\"代码太慢了\"\n\n✅ 使用 SBI：\n\"在 renderList 函数中（S），\n 每次渲染都会重新创建整个数组（B），\n 这会导致列表有 100 项时页面明显卡顿（I）。\n 请使用 useMemo 优化。\"`\n### 简化版 SBI ​\n对于简单问题，可以省略 Impact：\n\n`\"在 handleAdd 函数中（S），缺少空输入检查（B）。请添加验证。\"`\n## 反馈粒度金字塔 ​\n不同类型的问题，需要不同粒度的反馈。\n\n`        ▲\n       ╱ ╲\n      ╱   ╲     方向级反馈\n     ╱ 方向 ╲    \"整体思路需要调整\"\n    ╱───────╲\n   ╱  功能   ╲   功能级反馈\n  ╱───────────╲  \"这个功能缺少 XX\"\n ╱    代码     ╲  代码级反馈\n╱───────────────╲ \"第 15 行应该改成 XX\"`\n### 方向级反馈 ​\n使用场景：AI 的整体思路偏离了你的预期\n\n特点：\n\n- 不纠结细节\n- 重新描述期望的大方向\n- 可能需要推翻重来\n示例：\n\n`我需要的不是一个新页面，而是一个弹窗组件。\n请重新实现：用户点击按钮后，弹出一个模态框让用户输入任务。`\n### 功能级反馈 ​\n使用场景：方向对，但具体功能有缺失或错误\n\n特点：\n\n- 针对具体功能点\n- 保留已有正确的部分\n- 增量修改\n示例：\n\n`整体功能可以，请补充以下内容：\n1. 添加取消按钮，点击后关闭弹窗\n2. 点击弹窗外部区域也能关闭\n3. 按 ESC 键也能关闭`\n### 代码级反馈 ​\n使用场景：功能正确，但代码细节需要调整\n\n特点：\n\n- 精确到行号或函数名\n- 给出明确的修改指令\n- 最小范围改动\n示例：\n\n`请修改以下细节：\n1. 第 23 行：把 `var` 改成 `const`\n2. handleClose 函数：添加 event.stopPropagation() 防止事件冒泡\n3. Modal 组件：添加 aria-label=\"任务输入弹窗\" 提升可访问性`\n### 选择合适的粒度 ​\n问题类型使用粒度判断标准AI 理解错了需求方向级需要推翻重做功能缺失/逻辑错误功能级保留大部分，增量修改代码风格/细节问题代码级只需微调\n## 常见场景的反馈句式库 ​\n\n### 功能缺失 ​\nmarkdown\n```\n请补充以下功能：\n1. [功能描述]\n2. [功能描述]\n```\nmarkdown\n```\n这个实现缺少 [功能名称]。\n具体需求：[详细描述]\n```\n\n### 逻辑错误 ​\nmarkdown\n```\n[函数名/位置] 的逻辑有误：\n- 当前行为：[描述当前错误行为]\n- 期望行为：[描述正确行为]\n- 请修正。\n```\nmarkdown\n```\n在 [场景] 下，[具体问题]。\n正确的逻辑应该是：[描述正确逻辑]\n```\n\n### 代码结构优化 ​\nmarkdown\n```\n请优化以下代码结构：\n1. 把 [逻辑描述] 抽成独立函数\n2. 把 [内容] 移到 [位置]\n3. [其他结构调整]\n```\nmarkdown\n```\n这个函数太长了（当前 [X] 行），请拆分成：\n- [函数1]：负责 [职责]\n- [函数2]：负责 [职责]\n```\n\n### 样式调整 ​\nmarkdown\n```\n请修改以下样式：\n- [元素]：[属性] 改成 [值]\n- [元素]：[属性] 改成 [值]\n```\nmarkdown\n```\n[组件] 的样式需要调整：\n1. [具体样式问题]\n2. [具体样式问题]\n参考设计：[描述或图片链接]\n```\n\n### 边界情况 ​\nmarkdown\n```\n请处理以下边界情况：\n1. 当 [条件] 时，应该 [行为]\n2. 当 [条件] 时，应该 [行为]\n```\nmarkdown\n```\n当前实现没有考虑 [边界情况]。\n当 [具体场景] 发生时，会 [问题描述]。\n请添加相应的处理逻辑。\n```\n\n## 实战示例：修正一段有问题的代码 ​\nAI 第一轮输出的代码：\ntsx\n`function TaskList({ tasks }) {\n  return (\n    <ul>\n      {tasks.map(task => (\n        <li onClick={() => deleteTask(task.id)}>\n          {task.title}\n        </li>\n      ))}\n    </ul>\n  );\n}`问题分析：\n\n- 缺少 TypeScript 类型\n- map 中缺少 key\n- deleteTask 未定义\n- 点击整个 li 就删除，交互不合理\n有效反馈：\nmarkdown\n`请修正以下问题：\n\n1. 类型定义：\n   - 添加 Task 接口定义（id: string, title: string）\n   - 给 tasks 参数添加类型\n\n2. React 警告：\n   - map 中的 li 需要添加 key={task.id}\n\n3. 功能问题：\n   - deleteTask 函数未定义，请通过 props 传入\n   - 不要让整个 li 可点击删除，改成：在每个任务后面添加一个删除按钮\n\n4. 交互安全：\n   - 删除前添加确认提示`\n## 反馈的注意事项 ​\n\n### 一次不要反馈太多 ​\n\n```\n❌ 一次提出 10 个修改点\n✅ 一次提出 3-5 个相关的修改点\n```\n如果问题很多，优先反馈最重要的，分批进行。\n\n### 反馈要具体，但不要过度指定 ​\n\n`❌ 过度指定：\"在第 15 行和第 16 行之间插入 const x = 1;\"\n✅ 适度具体：\"在 handleSubmit 中添加空值检查\"`告诉 AI「做什么」，而不是「怎么写每一行代码」。\n\n### 说明「为什么」有时很有帮助 ​\n\n`请把 validateInput 函数抽出去。\n原因：这个验证逻辑在其他表单中也会用到，抽成独立函数便于复用。`AI 理解你的意图后，可能会给出更好的实现。\n\n## 可复制模板：通用反馈模板 ​\nmarkdown\n`请修改以下内容：\n\n**问题1**：[位置/上下文]\n- 当前情况：[描述问题]\n- 期望结果：[描述期望]\n\n**问题2**：[位置/上下文]\n- 当前情况：[描述问题]\n- 期望结果：[描述期望]\n\n**问题3**：[位置/上下文]\n- 当前情况：[描述问题]\n- 期望结果：[描述期望]`\n## 本节要点 ​\n✓ 有效反馈三要素：具体位置 + 具体问题 + 期望结果\n\n✓ SBI 框架：情境（哪里）→ 行为（什么问题）→ 影响（导致什么）\n\n✓ 粒度金字塔：方向级 → 功能级 → 代码级，根据问题类型选择\n\n✓ 句式库：积累常用的反馈句式，提高沟通效率\n\n✓ 节制原则：一次 3-5 个修改点，说「做什么」而非「怎么写」\n\n下一节，我们来学习如何管理长对话的上下文，避免 AI「失忆」。",
      "word_count": 3809,
      "estimated_time": 7
    },
    {
      "id": "lesson-092",
      "chapter_id": "chapter-03",
      "lesson_number": 23,
      "title": "3.5.4 上下文管理：让 AI 记住你说过的话",
      "content": "# 3.5.4 上下文管理：让 AI 记住你说过的话 ​\n\n## 经过本节学习，你将掌握 ​\n\n- 理解 AI 的「记忆」是如何工作的\n- 识别上下文「溢出」的信号\n- 四个实用的上下文管理技巧\n- 使用工具级配置让 AI「自动记住」项目规范\n## AI 的「记忆」是如何工作的 ​\n\n先来理解一个关键概念：AI 并没有真正的「记忆」。\n\n每次你和 AI 对话时，AI 看到的是整个对话历史。就像你把一叠纸递给一个人，让他读完后回答问题。纸越多，他需要处理的信息就越多。\n\n这叠「纸」有个名字：上下文窗口。\n\n### 用「工作台」来理解 ​\n\n想象 AI 的上下文窗口是一张工作台：\n\n`┌────────────────────────────────────────────┐\n│                 AI 的工作台                 │\n│  ┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐      │\n│  │ 第1轮 │ │ 第2轮 │ │ 第3轮 │ │ 第4轮 │ ... │\n│  │ 对话  │ │ 对话  │ │ 对话  │ │ 对话  │      │\n│  └──────┘ └──────┘ └──────┘ └──────┘      │\n│                                            │\n│  工作台大小有限（如 128K tokens）           │\n└────────────────────────────────────────────┘`工作台的特点：\n\n- 大小有限（不同模型不同，通常 8K-200K tokens）\n- 放不下时，最早的内容会被「挤出去」\n- 被挤出去的内容，AI 就「忘记」了\n### 不同模型的上下文窗口大小 ​\n模型上下文窗口大约相当于GPT-4o128K tokens约 300 页文档Claude 3.5 Sonnet200K tokens约 500 页文档DeepSeek64K tokens约 150 页文档较老的模型4K-8K tokens约 10-20 页文档\n看起来很大？但在长对话中，消耗速度比你想象的快。\n\n## 上下文「溢出」的信号 ​\n\n当对话太长，早期内容被挤出上下文窗口时，就会出现「溢出」。\n\n### 常见症状 ​\n症状表现原因AI 突然「失忆」忘记之前约定的技术栈或命名规范早期对话被挤出开始「自相矛盾」前后回答不一致只看到部分历史重复问你问过的问题\"请问你用的是什么框架？\"（之前说过了）那部分对话已不在窗口内代码风格突变之前用 TypeScript，突然开始写 JavaScript忘记了技术栈约定\n### 一个真实场景 ​\n\n`第 1 轮：你说\"请用 TypeScript 和 Tailwind\"\n第 2 轮：AI 用 TypeScript 写代码\n第 3 轮：继续用 TypeScript\n...\n第 15 轮：你让 AI 写一个新组件\n第 16 轮：AI 突然给你 JavaScript 代码 ← 问题出现`这就是上下文溢出。第 1 轮的约定已经被挤出工作台了。\n\n## 四个上下文管理技巧 ​\n\n### 技巧一：关键信息置顶 ​\n\n在每轮对话开始时，重申关键约定。\nmarkdown\n`继续我们的待办清单项目。\n\n提醒：\n- 技术栈：React + TypeScript + Tailwind\n- 命名规范：组件用 PascalCase，函数用 camelCase\n- 所有函数需要类型声明\n\n现在请帮我实现 [新功能]...`效果：关键信息始终在 AI 的「视野」中。\n\n### 技巧二：定期总结 ​\n\n当对话进行到 10 轮以上时，主动让 AI 总结已完成的工作。\nmarkdown\n`我们已经聊了很多轮。请总结一下目前的项目状态：\n1. 已完成的功能\n2. 使用的技术栈和约定\n3. 待完成的功能\n\n然后我们继续开发。`效果：\n\n- 把散落在各处的信息「压缩」成一段总结\n- 总结在最新位置，不会被挤出\n- 你也可以确认 AI 的理解是否正确\n### 技巧三：分块传递 ​\n\n不要一次性发送大量信息。分成多个小块，每块确认 AI 理解后再继续。\n\n`❌ 错误做法：\n一次性发送 3000 字的需求文档\n\n✅ 正确做法：\n第一条消息：\"我要做一个待办清单应用，先来定义核心数据结构...\"\n等 AI 回复确认后\n第二条消息：\"数据结构定好了，接下来是主要功能列表...\"`效果：\n\n- 每块信息都得到充分处理\n- 减少 AI 遗漏信息的概率\n- 便于及时发现理解偏差\n### 技巧四：约定重申 ​\n\n在关键节点重申重要约定，尤其是：\n\n- 开始新功能时\n- 发现 AI 偏离约定时\n- 对话超过 10 轮时markdown\n`开始新功能之前，确认一下我们的约定：\n1. 使用 TypeScript，不使用 any 类型\n2. 组件放在 src/components 目录\n3. 状态管理使用 useState，复杂状态用 useReducer\n4. 错误处理使用 try-catch\n\n确认后，请开始实现 [功能]。`\n## 上下文管理实用模板 ​\n\n### 对话开始时的上下文设定 ​\nmarkdown\n```\n项目背景：\n- 项目名称：[名称]\n- 技术栈：[技术栈列表]\n- 当前进度：[简要描述]\n\n本次任务：\n[具体任务描述]\n\n请注意以下约定：\n1. [约定1]\n2. [约定2]\n3. [约定3]\n```\n\n### 长对话中途的「检查点」 ​\nmarkdown\n```\n暂停一下，让我确认当前状态：\n\n已完成：\n1. [功能1]\n2. [功能2]\n\n使用的技术/约定：\n- [约定1]\n- [约定2]\n\n接下来要做：\n[下一个任务]\n\n以上理解正确吗？确认后继续。\n```\n\n### 约定违反时的纠正 ​\nmarkdown\n```\n注意：刚才的代码使用了 JavaScript，但我们项目约定使用 TypeScript。\n\n请重新生成，并确保：\n1. 所有变量和函数都有类型声明\n2. 不使用 any 类型\n3. 导出类型定义供其他组件使用\n```\n\n## 工具级上下文管理 ​\n除了在对话中管理上下文，主流 AI IDE 还提供了持久化配置功能。这些配置会在每次对话开始时自动加载，让 AI「天生」就知道你的项目规范。\n\n### 主流工具的配置文件对照表 ​\n工具配置文件位置功能定位Cursor`.cursor/rules/*.mdc`项目规范、编码风格、技术栈偏好Windsurf`.windsurf/rules/*.md` 或 `.windsurfrules`项目级 AI 行为规则Trae`.trae/project_rules.md`、`user_rules.md`用户规则 + 项目规则Claude Code`CLAUDE.md` + `SKILL.md`项目上下文 + 可复用技能GitHub Copilot`.github/copilot-instructions.md`仓库级指令OpenAI Codex`AGENTS.md`代理指令文件Factory Droid`.factory/droids/*.md`自定义 Droid 配置Aider`CONVENTIONS.md`编码规范文件Cline`.clinerules`项目规则\n### 配置文件应该写什么？ ​\n\n无论使用哪个工具，配置文件通常包含：\n\n- 项目概述：这是什么项目，解决什么问题\n- 技术栈：使用的语言、框架、库\n- 编码规范：命名约定、代码风格、目录结构\n- 禁止事项：不要使用的库、不要采用的模式\n- 常用命令：构建、测试、部署的命令\n### 通用项目配置模板 ​\nmarkdown\n`# 项目配置\n\n## 项目概述\n这是一个待办清单应用，帮助用户管理日常任务。\n\n## 技术栈\n- 前端：React 18 + TypeScript 5\n- 样式：Tailwind CSS 3\n- 状态管理：Zustand\n- 测试：Vitest\n\n## 目录结构\n- src/components：React 组件\n- src/hooks：自定义 Hooks\n- src/utils：工具函数\n- src/types：TypeScript 类型定义\n\n## 编码规范\n- 使用函数式组件，不用 class 组件\n- 所有函数必须有 TypeScript 类型声明\n- 组件文件使用 PascalCase 命名\n- 工具函数使用 camelCase 命名\n- 使用中文注释\n\n## 禁止事项\n- 不要使用 `any` 类型\n- 不要使用 jQuery\n- 不要在组件中直接写内联样式（使用 Tailwind）\n- 不要使用 `var`，使用 `const` 或 `let`\n\n## 常用命令\n- 开发：npm run dev\n- 构建：npm run build\n- 测试：npm test`\n### 为什么配置文件很重要？ ​\n没有配置文件有配置文件每次对话都要重复说技术栈AI 自动知道技术栈AI 可能用错误的规范规范始终一致团队成员各自配置不同团队共享同一份配置约定容易被遗忘约定被版本控制提示：具体工具的详细配置方法，请参考各工具的官方文档。基础版只需了解这些功能存在即可，进阶版会有更详细的工具配置教程。\n\n## 本节要点 ​\n\n✓ AI 无真正记忆：它看到的是对话历史，历史太长会「溢出」\n\n✓ 溢出信号：AI 失忆、自相矛盾、代码风格突变\n\n✓ 四个管理技巧：关键信息置顶、定期总结、分块传递、约定重申\n\n✓ 工具级配置：用配置文件让 AI 自动加载项目规范\n\n✓ 团队协作：配置文件可纳入版本控制，团队共享\n\n下一节，我们来学习什么时候应该放弃旧对话，开始一个全新的对话。",
      "word_count": 4100,
      "estimated_time": 8
    },
    {
      "id": "lesson-093",
      "chapter_id": "chapter-03",
      "lesson_number": 24,
      "title": "3.5.5 知道何时开始新对话",
      "content": "# 3.5.5 知道何时开始新对话 ​\n\n## 经过本节学习，你将掌握 ​\n\n- 识别「该开新对话」的三个信号\n- 理解为什么「清新开始」有时比「继续修补」更高效\n- 学会「搬家」：把关键信息从旧对话带到新对话\n- 获得一个可复制的新对话启动模板\n## 旧对话太长会怎样？ ​\n\n在 3.5.4 中，我们讲了上下文窗口的概念。当对话太长时，早期内容会被挤出窗口，导致 AI「失忆」。\n\n但问题不止于此。即使内容没被挤出，太长的对话也会降低 AI 的表现：\n问题原因回复变慢需要处理更多历史信息容易遗漏指令关键信息淹没在大量对话中更容易出错历史中的矛盾信息会干扰判断难以调试你也很难回溯问题出在哪一轮\n有时候，开一个新对话比在旧对话里继续挣扎更有效。\n\n## 三个「该开新对话」的信号 ​\n\n### 信号一：对话超过 20 轮 ​\n\n这是一个经验值。当对话轮次超过 20 轮（你发一条、AI 回一条算一轮），就应该考虑开新对话了。\n\n`为什么是 20 轮？\n- 每轮对话平均 500-1000 tokens\n- 20 轮 ≈ 10K-20K tokens\n- 已经占用了相当比例的上下文窗口`例外情况：如果你用的是大上下文窗口模型（如 Claude 200K），可以适当放宽到 30-40 轮。\n\n### 信号二：AI 开始「忘记」早期约定 ​\n\n当你发现以下情况时，说明上下文管理已经失效：\n\n`❌ 你第 1 轮说用 TypeScript，AI 第 18 轮给你 JavaScript\n❌ 你第 3 轮说不要用 any，AI 第 15 轮代码里全是 any\n❌ 你问\"按照之前的格式\"，AI 问你\"什么格式？\"`判断方法：如果你发现自己需要反复重申同一个约定（超过 3 次），就该开新对话了。\n\n### 信号三：话题发生根本转变 ​\n\n当你从一个任务转向另一个完全不同的任务时，旧对话的历史反而会干扰。\n\n`旧话题：实现用户登录功能\n新话题：设计数据库表结构\n\n两个话题关系不大，旧对话中的登录代码会占用上下文空间，\n却对设计数据库没有帮助。`经验法则：如果新任务和之前的对话内容没有直接关联，开新对话。\n\n## 三个信号的速查表 ​\n信号判断标准行动轮次过多超过 20 轮考虑开新对话AI 失忆反复重申约定超过 3 次立即开新对话话题转变新任务与历史无关开新对话\n## 如何「搬家」：把关键信息带到新对话 ​\n\n开新对话不意味着从零开始。你需要把关键信息「搬」到新对话中。\n\n### 第一步：从旧对话中提取关键信息 ​\n\n在旧对话结束前，让 AI 帮你总结：\nmarkdown\n`请总结我们这次对话的关键信息，包括：\n1. 项目的技术栈和约定\n2. 已完成的功能列表\n3. 当前的代码结构\n4. 遗留的问题或待办事项\n\n请用简洁的 Markdown 格式输出，方便我复制到新对话中。`\n### 第二步：保存总结 ​\n把 AI 的总结保存下来。可以：\n\n- 复制到一个文本文件\n- 保存到项目的 README 或 NOTES.md\n- 直接记在脑子里（如果内容不多）\n### 第三步：在新对话中重建上下文 ​\n\n用提取的信息开始新对话：\nmarkdown\n`我要继续开发一个待办清单项目。以下是项目背景：\n\n**技术栈**：\n- React 18 + TypeScript\n- Tailwind CSS\n- Zustand 状态管理\n\n**已完成功能**：\n1. 添加任务（带空输入验证）\n2. 删除任务（带确认提示）\n3. 任务列表展示\n\n**代码结构**：\n- src/components/AddTaskForm.tsx\n- src/components/TaskList.tsx\n- src/components/TaskItem.tsx\n- src/store/taskStore.ts\n\n**当前任务**：\n实现任务编辑功能——点击任务可以修改标题\n\n请基于以上背景，帮我实现任务编辑功能。`\n## 可复制模板：新对话启动 Prompt ​\n\n### 通用模板 ​\nmarkdown\n```\n我要继续开发 [项目名称]。以下是项目背景：\n\n## 技术栈\n- [技术1]\n- [技术2]\n- [技术3]\n\n## 编码约定\n- [约定1]\n- [约定2]\n- [约定3]\n\n## 已完成功能\n1. [功能1]\n2. [功能2]\n3. [功能3]\n\n## 代码结构\n- [目录/文件1]：[用途]\n- [目录/文件2]：[用途]\n\n## 本次任务\n[详细描述你要做的事情]\n\n请基于以上背景开始。\n```\n\n### 简化模板（适用于简单项目） ​\nmarkdown\n```\n继续开发 [项目名称]，技术栈：[技术栈]。\n\n已完成：[简要列举]\n现在要做：[本次任务]\n\n注意事项：\n1. [约定1]\n2. [约定2]\n```\n\n### 带代码上下文的模板 ​\nmarkdown\n```\n我要继续开发一个功能。以下是相关的现有代码：\n\n**现有组件**（TaskList.tsx）：\n```tsx\n// 这里粘贴相关代码片段\n```\n现在需要： [描述你需要 AI 做的事情]\n\n请注意：\n\n- 保持和现有代码风格一致\n- [其他约定]\n`\n## 什么时候不需要开新对话？\n\n有时候旧对话还是更好的选择：\n\n| 情况 | 建议 | 原因 |\n|-----|------|------|\n| 对话还在 10 轮以内 | 继续旧对话 | 历史信息仍然有价值 |\n| 正在调试一个 bug | 继续旧对话 | 错误上下文很重要 |\n| 功能实现到一半 | 继续旧对话 | 避免重新解释 |\n| 需要引用之前的代码 | 继续旧对话 | 代码在历史中可直接引用 |\n\n**核心原则**：如果旧对话的历史对当前任务仍然有帮助，继续用；如果已经变成负担，果断开新的。\n\n## 「清新开始」的心理优势\n\n除了技术原因，开新对话还有心理上的好处：`旧对话： \"之前改了这么多轮还没改好，是不是我的问题...\"\n\n新对话： \"这是一个全新的开始，这次一定可以\"\n\n`\n有时候，一个干净的起点能帮助你更清晰地思考问题。\n\n## 实战技巧：对话命名\n\n很多 AI 工具支持给对话命名。善用这个功能：`❌ 默认命名：\"New Chat\"、\"Untitled\" ✅ 有意义的命名：\"待办清单-添加功能\"、\"待办清单-删除功能\"\n\n```\n\n好的命名能帮你：\n- 快速找到历史对话\n- 知道每个对话在做什么\n- 决定是继续旧对话还是开新对话\n\n## 本节要点\n\n✓ **三个信号**：超过 20 轮、AI 反复失忆、话题根本转变\n\n✓ **清新开始的价值**：有时比继续修补更高效\n\n✓ **搬家流程**：让 AI 总结 → 保存 → 新对话中重建上下文\n\n✓ **启动模板**：用结构化的 Prompt 开始新对话，快速重建上下文\n\n✓ **对话命名**：给对话起有意义的名字，便于管理\n\n## 本章总结\n\n恭喜你完成了 3.5 节「迭代对话的艺术」的学习。\n\n回顾一下你学到了什么：\n\n| 小节 | 核心收获 |\n|-----|---------|\n| 3.5.1 | 一次搞定是幻觉，迭代是常态 |\n| 3.5.2 | 三阶段模型：看方向 → 改问题 → 磨细节 |\n| 3.5.3 | SBI 反馈框架，让 AI 精准理解你的修改需求 |\n| 3.5.4 | 四个上下文管理技巧 + 工具级配置 |\n| 3.5.5 | 知道何时「搬家」，如何「搬家」 |\n\n**一句话总结**：迭代不是失败，而是通往成功的必经之路。\n\n下一节（3.6），我们将学习当 AI「不听话」时——输出错误、产生幻觉、代码有 bug——如何诊断问题并修正。\n```",
      "word_count": 3210,
      "estimated_time": 6
    },
    {
      "id": "lesson-094",
      "chapter_id": "chapter-03",
      "lesson_number": 25,
      "title": "3.6.1 AI 常见的&quot;不听话&quot;表现",
      "content": "# 3.6.1 AI 常见的「不听话」表现 ​\n\n## 经过本节学习，你将掌握 ​\n\n- 识别 AI 输出问题的六种常见类型\n- 理解 AI 幻觉的四种形态及其危害\n- 了解 2024-2025 年新兴的「Slopsquatting」安全威胁\n- 获得一份实用的验证技巧速查表\n## 六种常见问题类型 ​\n\nAI 的「不听话」表现看似五花八门，但归纳起来主要有六种类型：\n类型症状典型案例答非所问AI 理解错了你的意图你要登录页，它给了注册页过度发挥做了你没要求的事情你要简单时钟，它给了带时区切换的全功能版偷工减料少做了关键部分没有错误处理，缺少边界检查自相矛盾前后逻辑不一致注释说「返回数组」，代码实际返回对象幻觉编造不存在的内容推荐不存在的库，调用不存在的 API死循环反复犯同一个错误你指出问题，它改了，下次又改回去\n### 类型一：答非所问 ​\n\n场景：你让 AI 做一个「用户登录功能」，它却给了你完整的「用户注册 + 登录 + 找回密码」三件套。\n\n为什么会这样：AI 基于大量训练数据进行模式匹配，当它看到「登录」这个词时，会联想到常见的用户认证系统，然后「好心」地给你全套方案。\n\n识别信号：\n\n- 输出的内容比你要的多很多\n- 包含了你没提到的功能模块\n- AI 在解释时说「我假设你还需要...」\n### 类型二：过度发挥 ​\n\n场景：你只想要一个显示当前时间的简单组件，AI 却加上了时区选择、12/24 小时切换、自定义格式等功能。\n\n为什么会这样：AI 见过太多「完整」的解决方案，倾向于给出「全面」的实现，即使你只需要最简单的版本。\n\n识别信号：\n\n- 代码量远超预期\n- 引入了你不认识的第三方库\n- 包含大量你不需要的配置选项\n### 类型三：偷工减料 ​\n\n场景：AI 给的代码能跑，但没有处理「用户输入为空」「网络请求失败」等异常情况。\n\n为什么会这样：为了让代码看起来简洁，或者因为你没有明确要求，AI 省略了防御性代码。\n\n识别信号：\n\n- 代码中没有 try-catch 或错误处理\n- 没有输入验证\n- 「Happy Path」（理想路径）能跑，边界情况会崩\n### 类型四：自相矛盾 ​\n\n场景：AI 说「这个函数返回用户列表」，但实际代码返回的是单个用户对象。\n\n为什么会这样：AI 生成注释和生成代码是相对独立的过程，有时会出现不同步。\n\n识别信号：\n\n- 注释与代码行为不符\n- 函数名暗示的功能与实际实现不一致\n- 前面说的方案和后面的代码不匹配\n### 类型五：幻觉（重点） ​\n\n这是最危险的问题类型，下面会详细展开。\n\n### 类型六：死循环 ​\n\n场景：你指出代码有问题，AI 修改后，下一轮又改回了原来的写法。\n\n为什么会这样：\n\n- 对话上下文太长，AI「忘记」了前面的修正\n- 你的修正指令不够明确\n- 任务本身超出了 AI 的能力范围\n识别信号：\n\n- 同样的错误反复出现\n- AI 的修改越来越「绕」\n- 修一个问题引入两个新问题\n## 重点：AI 幻觉的识别与应对 ​\n\nAI 幻觉（Hallucination）是指 AI 生成看起来正确但实际错误的内容。在编程场景中，这可能导致代码无法运行，甚至引入安全漏洞。\n\n### 代码幻觉的四种类型 ​\n类型表现危害程度示例包幻觉推荐不存在的 npm/pip 包🔴 高（安全风险）`npm install super-easy-utils`（包不存在）API 幻觉编造不存在的函数或方法🟡 中调用 `array.findLast()` 在旧版 JS 中不存在逻辑幻觉代码逻辑与描述不符🟡 中说「返回去重后的数组」，实际没有去重版本幻觉使用已废弃的语法或 API🟡 中使用 React 旧版类组件生命周期\n### 包幻觉：最危险的幻觉类型 ​\n\n为什么包幻觉的危害程度最高？因为它涉及到软件供应链安全。\n\n真实案例：2024-2025 年的安全研究发现了一种名为「Slopsquatting」的攻击方式：\n\n- 研究人员测试了 16 种主流 AI 模型，发现它们推荐的包中约 20% 是不存在的\n- 更令人担忧的是，43% 的幻觉包名会在多次询问中重复出现\n- 攻击者可以注册这些 AI 经常「幻觉」出的包名，植入恶意代码\n- 当开发者按 AI 建议安装这些包时，就会中招\n攻击链条：\n\n`AI 幻觉出包名 → 攻击者注册该包名 → 植入恶意代码 → 开发者按 AI 建议安装 → 系统被入侵`真实威胁：2025 年 10 月，安全公司发现了名为「PhantomRaven」的恶意活动，利用这种技术感染了 126 个 npm 包，窃取了开发者的 npm tokens、GitHub 凭证等敏感信息。\n\n### API 幻觉：看起来对但跑不起来 ​\n\n典型场景：\njavascript\n`// AI 生成的代码\nconst lastItem = myArray.findLast(item => item.active);`问题：`findLast()` 是 ES2023 引入的方法，在旧版浏览器或 Node.js 中不可用。AI 可能混淆了不同版本的 API。\n\n常见的 API 幻觉模式：\n\n- 混淆不同库的 API（把 Lodash 的方法当成原生方法）\n- 使用已废弃的 API\n- 编造不存在的配置选项\n### 逻辑幻觉：代码能跑但结果不对 ​\n\n典型场景：\n\n你让 AI 写一个「去重函数」，它给了你：\njavascript\n`function removeDuplicates(arr) {\n  // 去除数组中的重复元素\n  return arr.filter((item, index) => arr.indexOf(item) === index);\n}`代码看起来没问题，注释也对。但如果数组中包含对象，这个方法就失效了，因为对象比较的是引用而不是值。\n\n### 版本幻觉：用的是「过时」的写法 ​\n\n典型场景：\n\n你让 AI 用 React 写一个组件，它给了你类组件写法：\njavascript\n`class MyComponent extends React.Component {\n  componentWillMount() {\n    // ...\n  }\n}`问题：`componentWillMount` 在 React 16.3 后已被废弃，React 18 中会产生警告。\n\n## 验证技巧速查表 ​\n\n面对 AI 生成的代码，用这份清单快速验证：\n\n### 验证包是否存在 ​\nbash\n`# npm 包\nnpm search <包名>\n# 或直接访问 https://www.npmjs.com/package/<包名>\n\n# Python 包\npip index versions <包名>\n# 或直接访问 https://pypi.org/project/<包名>`\n### 验证 API 是否正确 ​\n\n- 查阅官方文档：不要只相信 AI 的解释\n- 检查兼容性：使用 caniuse.com（前端）或查看库的版本说明\n- 小范围测试：先在独立环境跑一下，确认能用\n### 要求 AI 提供来源 ​\n当 AI 推荐了你不熟悉的库或 API 时，追问：\n\n`请给出这个库的官方文档链接。`\n```\n这个 API 是在哪个版本引入的？请给出参考来源。\n```\n如果 AI 无法给出有效链接，或者链接打开是 404，那很可能是幻觉。\n\n### 验证逻辑正确性 ​\n\n- 用边界情况测试：空数组、空字符串、null、超大数值\n- 用反例测试：故意输入「应该失败」的数据，看是否正确处理\n- 让 AI 自己检查：\n`请检查上面的代码，列出可能的边界情况和异常情况，以及当前代码是否正确处理了它们。`\n## 本节要点 ​\n✓ 六种问题类型：答非所问、过度发挥、偷工减料、自相矛盾、幻觉、死循环\n\n✓ 四种代码幻觉：包幻觉（最危险）、API 幻觉、逻辑幻觉、版本幻觉\n\n✓ Slopsquatting 威胁：攻击者利用 AI 幻觉的包名进行供应链攻击，20% 的 AI 推荐包可能不存在\n\n✓ 验证习惯：对 AI 推荐的包和 API，先验证再使用；对代码逻辑，用边界情况测试\n\n识别问题只是第一步。下一节，我们来学习如何快速定位问题的根源。",
      "word_count": 3448,
      "estimated_time": 6
    },
    {
      "id": "lesson-095",
      "chapter_id": "chapter-03",
      "lesson_number": 26,
      "title": "3.6.2 诊断问题：AI 错在哪里",
      "content": "# 3.6.2 诊断问题：AI 错在哪里 ​\n\n## 经过本节学习，你将掌握 ​\n\n- 使用「三分钟快速诊断法」定位问题\n- 区分「我没说清楚」和「AI 能力不足」\n- 根据问题类型选择正确的应对策略\n- 获得一个诊断决策树\n## 诊断的核心问题 ​\n\n当 AI 输出不符合预期时，你首先要回答一个问题：\n\n是我没说清楚，还是 AI 没做对？\n\n这个问题的答案，决定了你下一步应该做什么：\n\n- 如果是你没说清楚 → 补充上下文，重新描述\n- 如果是 AI 没做对 → 换种问法，或者换个策略\n## 三分钟快速诊断法 ​\n\n在深入分析之前，先用这三步快速排查，能捕获约 60% 的常见问题：\n\n### 第一步：运行代码检查（30 秒） ​\nbash\n`# 如果是 JavaScript/TypeScript 项目\nnpx eslint <文件名>   # 检查语法和格式问题\nnpx tsc --noEmit      # 检查类型错误（如果用 TypeScript）`能发现的问题：\n\n- 语法错误（少了括号、拼错关键字）\n- 类型不匹配\n- 未定义的变量\n### 第二步：检查依赖和 API（60 秒） ​\n\n对照代码中的 import 语句，检查：\n\n- [ ] 引入的包是否存在？（用 3.6.1 中的验证方法）\n- [ ] 调用的方法是否真的存在于该包中？\n- [ ] 版本是否匹配？\n能发现的问题：\n\n- 包幻觉\n- API 幻觉\n- 版本兼容问题\n### 第三步：运行现有测试（90 秒） ​\n\n如果项目有测试用例：\nbash\n`npm test           # 或你项目的测试命令`能发现的问题：\n\n- 行为变更（原来能跑的功能被改坏了）\n- 逻辑错误\n- 边界情况处理不当\n## 根因分析四象限 ​\n\n如果三分钟诊断没有定位到问题，用这个四象限来分析根本原因：\n\n`                    我说得清楚\n                        ↑\n          ┌─────────────┼─────────────┐\n          │             │             │\n          │   AI 出错   │  补充上下文 │\n 简单任务 │  → 换问法   │  → 重新描述 │  复杂任务\n          │             │             │\n          ├─────────────┼─────────────┤\n          │             │             │\n          │  拆分任务   │ 重描述+拆分 │\n          │  → 分步做   │  → 降低复杂度│\n          │             │             │\n          └─────────────┴─────────────┘\n                        ↓\n                    我没说清楚`\n### 象限一：简单任务 + 我说得清楚 → AI 出错 ​\n特征：\n\n- 任务很明确，不应该有歧义\n- 你给的信息足够完整\n- 但 AI 的输出明显不对\n应对策略：\n\n- 换一种问法重新描述\n- 给出正确示例让 AI 参考\n- 尝试不同的 AI 工具\n示例：\n\n`原提示词：写一个判断闰年的函数\n\n问题：AI 给的逻辑不对\n\n换种问法：\n\"请写一个判断闰年的 JavaScript 函数。\n闰年规则：\n1. 能被 4 整除且不能被 100 整除，是闰年\n2. 能被 400 整除，也是闰年\n请严格按照这个规则实现。\"`\n### 象限二：简单任务 + 我没说清楚 → 补充上下文 ​\n特征：\n\n- 任务本身不复杂\n- 但你假设了 AI 知道某些背景\n- AI 按自己的理解做了，和你想的不一样\n应对策略：\n\n- 补充项目背景\n- 明确技术栈和约束\n- 说明你期望的输出格式\n示例：\n\n`原提示词：写一个表单验证\n\n问题：AI 用了你项目没有的验证库\n\n补充上下文：\n\"我的项目使用 React + Zod 做表单验证。\n请用 Zod 写一个用户注册表单的验证 schema，包括：\n- 邮箱格式验证\n- 密码至少 8 位\n- 确认密码要一致\"`\n### 象限三：复杂任务 + 我说得清楚 → 拆分任务 ​\n特征：\n\n- 任务涉及多个步骤或模块\n- 你描述得很清楚\n- 但 AI 的输出质量不稳定，有些对有些错\n应对策略：\n\n- 把大任务拆成小任务\n- 一次只让 AI 做一件事\n- 分步骤完成后再整合\n示例：\n\n`原提示词（太大）：\n\"实现一个完整的用户认证系统，包括注册、登录、找回密码、JWT 令牌管理\"\n\n拆分后：\n第一轮：\"先实现用户注册功能，只需要邮箱和密码\"\n第二轮：\"现在加上登录功能，返回 JWT 令牌\"\n第三轮：\"加上令牌验证中间件\"\n第四轮：\"最后加上找回密码功能\"`\n### 象限四：复杂任务 + 我没说清楚 → 重新描述 + 拆分 ​\n特征：\n\n- 任务复杂\n- 你自己可能也没完全想清楚\n- AI 的输出和你想的差很远\n应对策略：\n\n- 先退一步，理清自己的需求\n- 用 3.4 节学的 PRD 方法整理思路\n- 然后拆分成小任务逐个完成\n示例：\n\n`原提示词（模糊又复杂）：\n\"帮我做一个类似 Notion 的笔记应用\"\n\n理清需求后：\n\"我想做一个个人笔记应用，MVP 版本只需要：\n1. 创建/编辑/删除笔记\n2. 笔记列表页\n3. 本地存储\n\n先帮我实现第一个功能：创建和显示笔记列表。\n技术栈：React + localStorage\"`\n## 诊断 Prompt：让 AI 复述理解 ​\n在开始任务之前，或者发现问题之后，可以用这个 Prompt 让 AI 复述它的理解：\nmarkdown\n`在继续之前，请先回答以下问题：\n\n1. **你理解的任务目标是什么？**\n   （用一句话描述）\n\n2. **你计划使用什么技术方案？**\n   （列出关键技术点）\n\n3. **有哪些地方你不确定，需要我澄清？**\n   （如果没有就说\"无\"）\n\n请先回答这些问题，确认理解一致后再开始写代码。`为什么这招有效：\n\n- 提前暴露 AI 的误解\n- 让你在写代码前就发现问题\n- 比事后修改成本低得多\n## 常见问题的快速定位 ​\n症状最可能的原因下一步代码无法运行，报语法错误AI 生成了不完整的代码让 AI 给出完整代码运行时报 \"undefined\"缺少变量定义或异步问题检查数据流，补充初始化功能和描述不符AI 误解了需求用更具体的语言重新描述引入了不认识的库AI 过度发挥明确约束，指定只用某些库代码能跑但结果不对逻辑幻觉用边界测试验证，让 AI 自查编译报类型错误API 幻觉或版本问题查官方文档确认 API改了这里坏了那里任务太大，上下文丢失拆分任务，分步进行\n## 本节要点 ​\n\n✓ 核心问题：先判断是「我没说清楚」还是「AI 没做对」\n\n✓ 三分钟诊断：运行检查 → 依赖验证 → 测试运行，捕获 60% 问题\n\n✓ 四象限分析：根据任务复杂度 × 描述清晰度，选择不同策略\n\n✓ 复述技巧：让 AI 在动手前先说明理解，提前发现偏差\n\n定位了问题之后，下一节我们来学习具体的修正策略——怎么让 AI 把代码改对。",
      "word_count": 3095,
      "estimated_time": 6
    },
    {
      "id": "lesson-096",
      "chapter_id": "chapter-03",
      "lesson_number": 27,
      "title": "3.6.3 修正策略：怎么让 AI 改对",
      "content": "# 3.6.3 修正策略：怎么让 AI 改对 ​\n\n## 经过本节学习，你将掌握 ​\n\n- 四种修正策略及其适用场景\n- 「错误驱动开发」的工作流程\n- 识别「死亡螺旋」的信号并及时止损\n- 获得一套可直接使用的修正 Prompt 模板\n## 四种修正策略 ​\n\n在 3.5.3 中，我们学了如何给 AI 有效的反馈。本节聚焦于问题已经发生后的修正策略——当 AI 给的代码有问题时，如何引导它改对。\n策略适用场景核心思路精确指出问题你知道具体哪里错了给出位置 + 问题 + 期望给出正确示例格式或结构不对展示正确的「样子」分步重做任务太复杂导致出错拆解后逐个完成换种问法同一问法反复失败改变描述角度或方式\n### 策略一：精确指出问题 ​\n\n适用场景：你能定位到具体是哪行代码、哪个函数有问题。\n\nPrompt 模板：\nmarkdown\n`你在 [位置] 的代码有问题：\n\n**问题**：[描述具体问题]\n\n**当前行为**：[代码现在做了什么]\n\n**期望行为**：[代码应该做什么]\n\n请修正这个问题，其他部分保持不变。`示例：\nmarkdown\n`你在 handleSubmit 函数第 15 行的代码有问题：\n\n**问题**：使用了 localStorage，但这是服务端渲染项目\n\n**当前行为**：直接调用 localStorage.setItem()，在服务端会报错\n\n**期望行为**：先检查是否在浏览器环境，或者使用 cookies\n\n请修正这个问题，其他部分保持不变。`\n### 策略二：给出正确示例 ​\n适用场景：AI 理解了任务，但输出的格式、结构不符合你的要求。\n\nPrompt 模板：\nmarkdown\n`输出格式不对。\n\n**当前格式**：\n[展示 AI 给的格式]\n\n**期望格式**：\n[展示你想要的格式]\n\n请按期望格式重新输出。`示例：\nmarkdown\n`函数返回格式不对。\n\n**当前格式**：\n直接返回数据，如 `return userData`\n\n**期望格式**：\n统一返回格式 `{ success: boolean, data: any, error?: string }`\n成功时：`{ success: true, data: userData }`\n失败时：`{ success: false, data: null, error: \"错误信息\" }`\n\n请按期望格式修改所有 API 函数的返回值。`\n### 策略三：分步重做 ​\n适用场景：任务太复杂，AI 一次性输出的代码问题较多，修补不如重来。\n\nPrompt 模板：\nmarkdown\n`这个功能我们分步骤来做。\n\n**第一步（当前）**：[最小核心功能]\n只需要实现这一个功能，其他的后面再加。\n\n完成后我会确认，然后我们再做第二步。`示例：\nmarkdown\n`用户认证功能我们分步骤来做。\n\n**第一步（当前）**：只实现用户注册\n- 邮箱 + 密码表单\n- 基本的格式验证\n- 存储到数据库\n\n不需要：登录、找回密码、邮箱验证、JWT\n\n完成后我会确认，然后我们再做登录功能。`\n### 策略四：换种问法 ​\n适用场景：同一个问题，用同样的方式问了两三次，AI 还是给出类似的错误答案。\n\n可以尝试的角度转换：\n原问法换种问法直接要结果先问原理，再让 AI 基于原理实现用技术术语用生活化语言描述需求描述「要什么」描述「解决什么问题」从功能角度问从用户角度描述场景\n示例：\nmarkdown\n`原问法（反复失败）：\n\"写一个防抖函数\"\n\n换种问法：\n\"用户在搜索框输入时，我不想每敲一个字就触发搜索请求，\n而是希望用户停止输入 300 毫秒后再发起请求。\n请帮我实现这个延迟触发的逻辑。\"`\n## 错误驱动开发：把 AI 变成调试助手 ​\n当你遇到错误时，不必自己分析——可以直接把错误信息扔给 AI，让它帮你定位和修复。\n\n### 工作流程 ​\n\n`发现错误 → 复制完整错误信息 → 给 AI 分析 → 应用修复 → 验证 → 如有新错误则重复`\n### 操作模板 ​\nmarkdown\n```\n运行代码时遇到以下错误：\n```\n[粘贴完整的错误信息]\n\n`\n相关代码：\n```[语言]\n[粘贴相关代码片段]`请分析错误原因，并给出修复方案。\n\n`\n### 示例\n\n```markdown\n运行代码时遇到以下错误：`TypeError: Cannot read properties of undefined (reading 'map') at UserList (UserList.jsx:12:23)\n\n`\n相关代码：\n```jsx\nfunction UserList({ users }) {\n  return (\n    <ul>\n      {users.map(user => <li key={user.id}>{user.name}</li>)}\n    </ul>\n  );\n}`请分析错误原因，并给出修复方案。\n\n`\n**AI 通常会告诉你**：\n- 错误原因：`users` 可能是 `undefined`\n- 修复方案：添加空值检查或默认值\n\n## 警惕「死亡螺旋」\n\n「死亡螺旋」是指：你让 AI 修问题，它修了一个又引入两个新问题；你再让它修，问题越来越多，代码越来越乱。\n\n### 识别信号\n\n- 🚨 修改轮次超过 3 次，问题还没解决\n- 🚨 AI 的代码量越改越多、越改越复杂\n- 🚨 修了 A 问题，B 功能又坏了\n- 🚨 AI 开始「绕圈」，给出的方案和之前类似\n\n### 止损策略\n\n一旦识别到死亡螺旋，果断止损：\n\n**选项 1：回退重来**\n```markdown\n这个方向走不通。请忘掉之前的修改，我们从头开始。\n\n[重新清晰地描述需求，可能需要拆分成更小的任务]`选项 2：保留能用的，手动修复剩余部分\nmarkdown\n`请把目前能正常工作的代码整理一下给我，\n有问题的部分用注释标注出来，我自己来修。`选项 3：换一个 AI 工具试试\n\n不同的 AI 模型在不同任务上表现不同。如果一个工具反复卡住，换一个试试可能会有惊喜。\n\n## 修正 Prompt 模板库 ​\n\n### 修复运行时错误 ​\nmarkdown\n`这段代码报错了：\n\n错误信息：`[错误信息]\n\n`\n代码：\n```[语言]\n[代码]`请修复这个错误。如果需要更多上下文，请告诉我需要什么信息。\n\n`\n### 修复逻辑错误\n\n```markdown\n这段代码可以运行，但结果不对：\n\n**输入**：[描述输入]\n**期望输出**：[描述期望结果]\n**实际输出**：[描述实际结果]\n\n代码：\n```[语言]\n[代码]`请找出逻辑问题并修复。\n\n`\n### 修复样式问题\n\n```markdown\n样式和预期不符：\n\n**期望效果**：[描述或截图链接]\n**实际效果**：[描述当前问题]\n\n当前代码：\n```css\n[样式代码]`请修改样式使其符合期望效果。\n\n`\n### 要求 AI 自查\n\n```markdown\n请检查上面的代码：\n\n1. 有哪些潜在的边界情况没有处理？\n2. 有哪些可能导致运行时错误的地方？\n3. 有哪些可以优化的地方？\n\n列出问题后，请给出修复后的完整代码。`\n## 本节要点 ​\n✓ 四种修正策略：精确指出 → 给出示例 → 分步重做 → 换种问法\n\n✓ 错误驱动开发：把错误信息直接扔给 AI，让它帮你定位和修复\n\n✓ 警惕死亡螺旋：修改超过 3 轮还没解决，果断止损重来\n\n✓ 模板库：积累常用的修正 Prompt，提高修复效率\n\n但有时候，问题不在于怎么修正，而是 AI 真的做不到。下一节我们来看兜底策略——当 AI 真的搞不定时该怎么办。",
      "word_count": 3217,
      "estimated_time": 6
    },
    {
      "id": "lesson-097",
      "chapter_id": "chapter-03",
      "lesson_number": 28,
      "title": "3.6.4 兜底策略：当 AI 真的搞不定",
      "content": "# 3.6.4 兜底策略：当 AI 真的搞不定 ​\n\n## 经过本节学习，你将掌握 ​\n\n- 识别 AI 的能力边界\n- 三种兜底方案及其适用场景\n- 「混合开发」模式的操作方法\n- 知道何时该寻求外部帮助\n## 认识 AI 的能力边界 ​\n\nAI 很强大，但并非无所不能。了解它的边界，能帮你在关键时刻做出正确判断，避免在死胡同里浪费时间。\n\n### AI 擅长的事 ​\n领域具体任务标准化代码实现常见功能、转换数据格式、生成模板代码文档和解释解释代码逻辑、生成注释、编写文档模式识别识别代码问题、找到类似方案、重构建议快速原型生成 UI 组件、搭建项目骨架、实现 MVP\n### AI 不擅长的事 ​\n领域原因示例复杂环境配置涉及本地路径、系统权限、网络配置等 AI 无法访问的信息Docker 网络配置、环境变量设置需要实时验证的任务AI 无法真正运行代码验证结果调试性能问题、排查内存泄漏高度项目特定的逻辑依赖大量项目上下文，超出对话窗口容量复杂业务规则、遗留系统集成安全敏感操作涉及密钥、凭证等不应该暴露的信息配置 API 密钥、处理用户密码实时数据操作无法访问真实数据库、外部 API数据库迁移、线上问题排查\n### 识别「AI 做不到」的信号 ​\n\n- 🚨 你已经提供了所有能想到的上下文，AI 还是给不出正确答案\n- 🚨 AI 反复给出「看起来对但实际不能用」的方案\n- 🚨 问题涉及你无法通过文字描述的内容（如视觉效果、本地环境）\n- 🚨 修改了 5 轮以上，问题还没解决\n## 三种兜底方案 ​\n\n### 方案一：换一个 AI 工具 ​\n\n不同的 AI 模型有不同的训练数据和擅长领域。如果一个工具反复卡住，换一个试试往往有效。\n\n选择建议：\n任务类型可尝试的替代方案前端/React 相关不同的 AI 可能有不同的框架偏好算法逻辑问题尝试偏理论型的 AI 模型代码解释和学习选择擅长教学的 AI快速原型选择代码生成速度快的工具\n操作要点：\n\n- 换工具时，重新整理一遍需求描述\n- 不要把前一个 AI 的错误代码带过去（避免干扰）\n- 只描述问题本身和期望结果\n### 方案二：搜索引擎找现成方案 ​\n\n很多问题已经被其他人遇到并解决过了。用搜索引擎找现成方案，可能比让 AI 从头生成更可靠。\n\n高效搜索技巧：\n\n`[错误信息关键词] site:stackoverflow.com`\n```\n[技术栈] [功能描述] github\n```\n\n```\n[库名] [具体问题] 官方文档\n```\n示例：\n\n`TypeError map undefined react site:stackoverflow.com`然后让 AI 帮你理解和适配：\nmarkdown\n`我在 Stack Overflow 上找到了这个解决方案：\n\n[粘贴找到的代码]\n\n请帮我：\n1. 解释这段代码的原理\n2. 根据我的项目情况（[描述你的技术栈]）进行适当修改`\n### 方案三：用 AI 理解概念，自己动手实现 ​\n当 AI 生成的代码不可靠时，可以退一步——让它帮你理解原理，然后你自己写代码。\n\n操作流程：\n\n- \n让 AI 解释原理：\nmarkdown\n`不要写代码。请解释 [概念/功能] 的工作原理，包括：\n- 核心思路是什么\n- 有哪些关键步骤\n- 有哪些常见的坑需要注意`\n- 让 AI 提供伪代码：\nmarkdown\n`请用伪代码（不是真正的代码）描述实现步骤，\n让我理解整体逻辑。`\n- 你自己编写代码，遇到具体问题再问 AI\n\n这种方式的好处：\n\n- 避免 AI 幻觉导致的错误\n- 你对代码有完整的理解\n- 后续维护更容易\n## 混合开发模式 ​\n\n「混合开发」是一种务实的策略：让 AI 做它擅长的部分，你来补充它做不好的部分。\n\n### 模式一：AI 做骨架，你做细节 ​\nmarkdown\n`请生成一个 [功能] 的代码框架，包括：\n- 基本的文件结构\n- 主要函数的签名（参数和返回值）\n- 每个函数的功能注释\n\n不需要实现具体逻辑，我自己来写。`适用场景：\n\n- 你熟悉业务逻辑，但懒得搭架子\n- AI 对细节理解可能出错，但骨架是通用的\n### 模式二：AI 做初版，你来审查修改 ​\n\n工作流：\n\n- 让 AI 生成完整代码\n- 你来审查，标记有问题的地方\n- 对于简单问题，让 AI 修正\n- 对于复杂问题，你自己改\n审查要点清单：\n\n- [ ] 代码逻辑是否正确？\n- [ ] 边界情况是否处理？\n- [ ] 引用的库和 API 是否存在？\n- [ ] 是否有安全隐患？\n- [ ] 是否符合项目规范？\n### 模式三：分工协作 ​\n\n把任务按特性分成两类：\nAI 负责你负责生成标准 CRUD 代码复杂业务逻辑编写单元测试模板关键算法实现生成 UI 组件骨架交互细节和动画编写文档注释架构设计决策\n## 何时寻求外部帮助 ​\n\n有些问题确实超出了「Vibe Coding + AI」能解决的范围。识别这些情况，及时寻求帮助，是更高效的选择。\n\n### 应该寻求帮助的信号 ​\n\n- 问题涉及你完全不理解的领域（如安全、性能优化、DevOps）\n- 卡住超过 2 小时，没有任何进展\n- 问题可能影响到数据安全或系统稳定性\n- 需要做出可能影响长远的架构决策\n### 去哪里寻求帮助 ​\n渠道适合的问题Stack Overflow技术细节问题，已有成熟答案的问题GitHub Issues特定库或框架的问题社区论坛/Discord需要讨论的开放性问题付费咨询/顾问复杂的架构问题、安全问题\n### 如何有效地提问 ​\n\n无论是问 AI 还是问人，好的问题能大大提高获得帮助的概率：\nmarkdown\n`**我想做什么**：[一句话描述目标]\n\n**我遇到的问题**：[具体问题描述]\n\n**我已经尝试过**：\n1. [尝试过的方法 1]\n2. [尝试过的方法 2]\n\n**相关代码/错误信息**：\n[附上最小可复现的代码或完整错误信息]\n\n**我的环境**：[技术栈版本等信息]`\n## 本节要点 ​\n✓ 认识边界：环境配置、实时验证、项目特定逻辑、安全操作是 AI 的弱项\n\n✓ 三种兜底：换 AI 工具、搜索现成方案、用 AI 学原理后自己实现\n\n✓ 混合开发：AI 做骨架/初版，你来补充细节和审查\n\n✓ 寻求帮助：卡住超过 2 小时、涉及安全架构时，及时寻求外部帮助\n\n预防胜于治疗。下一节我们来看如何从一开始就减少 AI「不听话」的概率。",
      "word_count": 2696,
      "estimated_time": 5
    },
    {
      "id": "lesson-098",
      "chapter_id": "chapter-03",
      "lesson_number": 29,
      "title": "3.6.5 预防胜于治疗：减少&quot;不听话&quot;的概率",
      "content": "# 3.6.5 预防胜于治疗：减少「不听话」的概率 ​\n\n## 经过本节学习，你将掌握 ​\n\n- 发送前的 5 条快速自检\n- 「让 AI 先复述」的预防技巧\n- 「小步快跑」的迭代策略\n- 及时纠偏的最佳时机\n## 发送前自检清单 ​\n\n在按下发送键之前，花 10 秒过一遍这个清单，可以避免大部分问题：\n\n### 5 条快速自检 ​\n\n- [ ] 任务是否聚焦？ 这次只让 AI 做一件事？\n- [ ] 上下文是否充足？ AI 有足够的背景信息理解任务？\n- [ ] 目标是否明确？ 说清楚了「什么算完成」？\n- [ ] 约束是否清晰？ 说明了「不要什么」？\n- [ ] 格式是否指定？ 告诉 AI 期望的输出格式？\n这和 3.1.3 中学的「五大错误」相对应。养成习惯后，这个检查只需要几秒钟。\n\n### 提问质量自评表 ​\n\n在开始重要任务前，用这个表格评估你的提示词质量：\n维度差（1分）中（2分）好（3分）任务范围包含多个不相关的功能有主次之分但都要做只聚焦一个功能上下文只说了要做什么说了技术栈或部分背景技术栈+项目背景+约束都有验收标准没说什么算完成模糊描述了期望给出了具体的验收条件约束条件没有任何限制有技术栈限制技术栈+不做清单+格式要求\n评分解读：\n\n- 10-12 分：很棒，发送吧\n- 7-9 分：可以发送，但准备好迭代\n- 4-6 分：建议补充信息后再发送\n- 4 分以下：重新组织提示词\n## 让 AI 先复述 ​\n\n这是一个简单但非常有效的预防技巧：在让 AI 开始写代码之前，先让它复述对任务的理解。\n\n### 复述 Prompt 模板 ​\nmarkdown\n`在开始写代码之前，请先回答以下问题：\n\n1. **你理解的任务目标是什么？**\n   用一句话描述。\n\n2. **你计划使用什么技术方案？**\n   列出关键技术点和实现思路。\n\n3. **有哪些地方你不确定，需要我澄清？**\n   如果没有请说\"无\"。\n\n请先回答这三个问题，我确认理解一致后，你再开始写代码。`\n### 为什么这招有效 ​\n\n- 提前暴露误解：AI 对任务的理解如果有偏差，在复述阶段就能发现\n- 统一预期：你和 AI 对「做什么」达成一致后再动手\n- 节省时间：纠正一个误解比修改一堆错误代码快得多\n### 使用时机 ​\n\n- ✅ 开始一个新功能时\n- ✅ 任务比较复杂时\n- ✅ 你不确定 AI 是否理解了你的意思时\n- ❌ 简单的小修改不需要\n## 小步快跑策略 ​\n「小步快跑」是指：把大任务拆成小任务，每完成一步就验证一下，确认没问题再继续。\n\n### 为什么要小步快跑 ​\n一次做完小步快跑问题累积到最后才发现每步都能及时发现问题出错后难以定位是哪步出的问题问题范围明确，容易定位修复成本高（可能要大改）修复成本低（只改最近一步）AI 上下文容易丢失每步上下文都是新鲜的\n### 拆分粒度建议 ​\n任务类型建议拆分粒度单个功能核心逻辑 → 错误处理 → 边界情况 → 样式多个功能每个功能单独一轮对话完整页面布局骨架 → 各组件 → 交互逻辑 → 数据获取数据流程数据模型 → API 接口 → 前端调用 → 状态管理\n### 小步快跑的节奏 ​\n\n`第一步：让 AI 做最小核心功能\n   ↓\n验证：能跑吗？结果对吗？\n   ↓\n确认 OK → 第二步：加一个小功能\n   ↓\n验证：还能跑吗？新功能对吗？之前的功能还正常吗？\n   ↓\n重复...`\n## 及时纠偏 ​\n发现问题后立即反馈，不要等到最后。\n\n### 为什么要及时 ​\n\n- 上下文新鲜：AI 刚输出完，上下文还在，修改最容易\n- 问题隔离：知道问题就出在最近这一步\n- 避免连锁反应：一个错误不纠正，后面可能越错越多\n### 何时该立即纠偏 ​\n情况行动发现理解偏差立即澄清，让 AI 重新理解技术方案不对立即指出，给出正确方向代码有明显错误立即反馈，在继续之前先修正功能缺失列出缺失项，让 AI 补充\n### 纠偏 Prompt 示例 ​\nmarkdown\n`暂停一下。\n\n上面的代码有个问题：[描述问题]\n\n在继续之前，请先修正这个问题。其他部分可以保留。`markdown\n```\n等等，这不是我想要的。\n\n我要的是 [正确的需求]，不是 [AI 做的]。\n\n请重新理解我的需求后再继续。\n```\n\n## 预防检查清单 ​\n每次开始和 AI 对话前，快速过一遍：\n\n### 开始前 ​\n\n- [ ] 我清楚知道这次要让 AI 做什么（一件事）\n- [ ] 我准备好了必要的上下文信息\n- [ ] 我知道什么算「完成」\n### 发送后 ​\n\n- [ ] AI 的复述和我的意图一致吗？\n- [ ] AI 的技术方案合理吗？\n- [ ] AI 用的库和 API 我认识吗？\n### 收到代码后 ​\n\n- [ ] 代码能跑吗？\n- [ ] 结果符合预期吗？\n- [ ] 边界情况处理了吗？\n## 本节要点 ​\n\n✓ 发送前自检：任务聚焦、上下文充足、目标明确、约束清晰、格式指定\n\n✓ 复述技巧：让 AI 先说它的理解，确认一致后再写代码\n\n✓ 小步快跑：拆分任务，每步验证，及时发现问题\n\n✓ 及时纠偏：发现问题立即反馈，不要等到最后\n\n## 本章总结 ​\n\n恭喜你完成了 3.6 节的学习。现在你已经掌握了：\n\n- 识别问题：六种常见的 AI「不听话」表现，特别是危险的 AI 幻觉\n- 诊断问题：三分钟快速诊断法，根因分析四象限\n- 修正问题：四种修正策略，错误驱动开发\n- 兜底方案：当 AI 搞不定时的备选策略\n- 预防问题：发送前自检，复述技巧，小步快跑\n记住这个心法：\n\nAI 出错不可怕，可怕的是不知道它错了。\n\n在 Vibe Coding 中，你的角色是指挥官，不是执行者。你负责把握方向、验收结果、处理异常。掌握了本节的技能，你就能从容应对 AI 的各种「不听话」，把它调教成一个可靠的助手。\n\n下一节是第三章的总结，我们会把本章所有技法整合成一个完整的工作流，并通过实战演练巩固所学。",
      "word_count": 2502,
      "estimated_time": 5
    },
    {
      "id": "lesson-099",
      "chapter_id": "chapter-03",
      "lesson_number": 30,
      "title": "3.7.1 本章核心要点回顾",
      "content": "# 3.7.1 本章核心要点回顾 ​\n\n## 六大核心技能总览 ​\n\n本章教会你六项核心技能。记住这张表，你就记住了本章的精华：\n技能核心问题一句话答案对应章节上下文思维AI 需要知道什么？项目背景 + 任务细节 + 个人需求3.1结构化表达如何组织信息？用 S.C.A.F.F. 或 R.G.C. 框架3.2技巧选择什么情况用什么技巧？Zero-shot → Few-shot → CoT → ToT3.3PRD 整合如何把想法变成任务书？整合第二章成果，填入 PRD 模板3.4迭代对话AI 没做对怎么办？精确反馈 + 逐步逼近3.5问题处理AI 出错了怎么办？诊断根因 + 精确修正 + 验证幻觉3.6\n## 从「差提示词」到「好提示词」的蜕变 ​\n\n学完本章，你的提示词应该发生这样的变化：\n\n### 蜕变前：模糊、不完整 ​\n\n`帮我做一个待办清单`问题清单：\n\n- ❌ 没有项目背景\n- ❌ 没有技术栈\n- ❌ 没有功能范围\n- ❌ 没有约束条件\n- ❌ 没有输出格式\n### 蜕变后：清晰、结构化 ​\nmarkdown\n`【Situation - 情境】\n我在做一个个人待办清单网页应用。\n技术栈：React + TypeScript + Tailwind CSS\n目标用户：容易忘事的职场新人（就是我自己）\n设计原则：极简，打开就是今日待办，添加任务 3 秒内完成\n\n【Challenge - 挑战】\n实现「添加任务」功能：\n- 用户在输入框输入任务内容\n- 按回车键或点击添加按钮，任务添加到列表\n- 添加成功后自动清空输入框\n- 空内容不能添加（显示简单提示）\n\n【Audience - 受众】\n代码维护者是我自己，React 初学者，请在关键逻辑处加注释\n\n【Format - 格式】\n给我完整的 AddTask 组件代码，使用 TypeScript\n\n【Foundations - 约束】\n- 不用任何外部状态管理库\n- 不用任何 UI 组件库\n- 样式用 Tailwind CSS`检查清单：\n\n- ✅ 有项目背景\n- ✅ 有技术栈\n- ✅ 有功能范围\n- ✅ 有约束条件\n- ✅ 有输出格式\n## 技巧选择决策树 ​\n\n遇到任务不知道用什么技巧？按这个流程走：\n\n`开始\n  │\n  ▼\n┌─────────────────────────────────────┐\n│ 这个任务 AI「直接会做」吗？          │\n│ （代码转换、内容生成、代码解释）      │\n└─────────────────────────────────────┘\n  │\n  ├─ 是 ──────────────────────────────▶ Zero-shot（直接问）\n  │\n  ▼ 否\n┌─────────────────────────────────────┐\n│ 需要特定的输出格式吗？              │\n│ （API 文档、分类任务、风格模仿）     │\n└─────────────────────────────────────┘\n  │\n  ├─ 是 ──────────────────────────────▶ Few-shot（给 2-3 个示例）\n  │\n  ▼ 否\n┌─────────────────────────────────────┐\n│ 需要多步推理/分析吗？               │\n│ （复杂度分析、Bug 排查、逻辑审查）   │\n└─────────────────────────────────────┘\n  │\n  ├─ 是 ──────────────────────────────▶ Chain of Thought（分步思考）\n  │\n  ▼ 否\n┌─────────────────────────────────────┐\n│ 需要对比多个方案吗？                │\n│ （技术选型、架构决策）              │\n└─────────────────────────────────────┘\n  │\n  ├─ 是 ──────────────────────────────▶ Tree of Thoughts（多方案对比）\n  │\n  ▼ 否\n┌─────────────────────────────────────┐\n│ 输出质量很重要吗？                  │\n│ （核心代码、公开文档）              │\n└─────────────────────────────────────┘\n  │\n  ├─ 是 ──────────────────────────────▶ 加上 Self-Critique（自查修正）\n  │\n  ▼ 否\n    Zero-shot 就够了`\n## 五个技巧的使用场景速查 ​\n技巧使用频率典型场景关键词Zero-shot50%代码转换、内容生成、代码解释「直接问」Few-shot25%API 文档生成、分类任务、风格模仿「给示例」Chain of Thought15%复杂度分析、Bug 排查、逻辑审查「分步骤」Tree of Thoughts2%技术选型、架构决策「比方案」Self-Critique8%核心代码、公开文档「自检查」实践建议：\n\n- 从 Zero-shot 开始尝试\n- 如果输出不满意，再升级到其他技巧\n- 重要输出记得加 Self-Critique\n## 心法与技法的完整闭环 ​\n\n第二章（心法）和第三章（技法）解决的是不同问题，但缺一不可：\n\n`┌─────────────────────────────────────────────────────────────┐\n│                        完整闭环                              │\n├─────────────────────────────────────────────────────────────┤\n│                                                             │\n│   第二章：心法                    第三章：技法               │\n│   ──────────────                 ──────────────             │\n│                                                             │\n│   问题发现 ─────────────────────▶ 写入 PRD 背景             │\n│   JTBD 思维 ────────────────────▶ 描述用户任务              │\n│   逆向思维 ─────────────────────▶ 列出约束条件              │\n│   减法思维 ─────────────────────▶ P0/P1/P2 优先级           │\n│   故事思维 ─────────────────────▶ 用户画像 + 场景           │\n│   灵魂三问 ─────────────────────▶ 最终自检                  │\n│                                                             │\n│   输出：清晰的需求                输出：AI 能执行的 Prompt    │\n│                                                             │\n└─────────────────────────────────────────────────────────────┘`维度心法（第2章）技法（第3章）核心问题做什么？为什么做？怎么让 AI 理解我要做什么？输入模糊的想法清晰的需求输出清晰的需求AI 能执行的指令关键能力产品思维、用户洞察Prompt 工程、需求表达\n## 本章关键公式 ​\n记住这三个公式，你就掌握了本章的精髓：\n\n### 公式一：AI 输出质量公式 ​\n\nAI 输出质量 = 上下文质量 × AI 能力\n\nAI 的能力是固定的，你能控制的只有上下文质量。\n\n### 公式二：好提示词公式 ​\n\n好提示词 = 背景 + 任务 + 约束 + 格式 + 示例（可选）\n\n缺少任何一个要素，AI 的输出都可能偏离预期。\n\n### 公式三：迭代修正公式 ​\n\n精确修正 = 指出问题 + 说明原因 + 给出期望\n\n模糊的「不对」不如精确的「这里应该是那样」。\n\n## 四种代码幻觉速查 ​\n类型危害程度表现验证方法包幻觉🔴 高推荐不存在的 npm/pip 包`npm search <包名>` 或访问官网API 幻觉🟡 中编造不存在的函数或方法查阅官方文档逻辑幻觉🟡 中代码逻辑与描述不符用边界情况测试版本幻觉🟡 中使用已废弃的语法或 API检查版本兼容性\n验证习惯：对 AI 推荐的包和 API，先验证再使用。\n\n## 本节要点 ​\n\n✓ 六大技能：上下文思维、结构化表达、技巧选择、PRD 整合、迭代对话、问题处理\n\n✓ 技巧选择流程：Zero-shot → Few-shot → CoT → ToT，重要输出加 Self-Critique\n\n✓ 心法与技法的关系：心法帮你想清楚，技法帮你说明白，两者缺一不可\n\n✓ 三个关键公式：输出质量公式、好提示词公式、迭代修正公式\n\n下一节，我们将把第二章和第三章串联起来，形成从想法到代码的完整工作流。",
      "word_count": 4105,
      "estimated_time": 8
    },
    {
      "id": "lesson-100",
      "chapter_id": "chapter-03",
      "lesson_number": 31,
      "title": "3.7.2 第二章 + 第三章：完整工作流",
      "content": "# 3.7.2 第二章 + 第三章：完整工作流 ​\n\n## 从想法到代码的八步流程 ​\n\n把第二章的「想清楚」和第三章的「说明白」串联起来，形成一个完整的工作流：\n\n`┌─────────────────────────────────────────────────────────────────────┐\n│                     从想法到代码：八步流程                            │\n├─────────────────────────────────────────────────────────────────────┤\n│                                                                     │\n│  第二章：想清楚                                                      │\n│  ─────────────────────────────────────────────────────────────────  │\n│                                                                     │\n│  Step 1: 问题发现                                                   │\n│  └─▶ 识别值得解决的问题（烦恼日记、五维评分）                         │\n│                                                                     │\n│  Step 2: 任务定义                                                   │\n│  └─▶ 用 JTBD 描述用户要完成的任务                                    │\n│                                                                     │\n│  Step 3: 风险预判                                                   │\n│  └─▶ 用逆向思维列出可能的失败原因                                    │\n│                                                                     │\n│  Step 4: 范围收敛                                                   │\n│  └─▶ 用减法思维确定 MVP 范围（P0/P1/P2）                             │\n│                                                                     │\n│  Step 5: 用户理解                                                   │\n│  └─▶ 用故事思维构建用户画像和旅程                                    │\n│                                                                     │\n│  Step 6: 最终自检                                                   │\n│  └─▶ 用灵魂三问确认准备就绪                                          │\n│                                                                     │\n│  第三章：说明白                                                      │\n│  ─────────────────────────────────────────────────────────────────  │\n│                                                                     │\n│  Step 7: 编写 PRD                                                   │\n│  └─▶ 整合前六步成果，形成 AI 能理解的任务书                          │\n│                                                                     │\n│  Step 8: 迭代对话                                                   │\n│  └─▶ 与 AI 对话，逐步逼近理想结果                                    │\n│                                                                     │\n└─────────────────────────────────────────────────────────────────────┘`\n## 成果映射表：第二章输出如何用于第三章 ​\n第二章输出对应 PRD 部分如何使用烦恼日记项目背景说明为什么要做这个项目JTBD 任务描述用户任务描述用户要完成什么Pre-mortem 清单约束条件转化为「不做清单」MVP 优先级功能范围明确 P0/P1/P2 功能用户画像目标用户描述用户特征和需求用户旅程使用场景描述关键触点灵魂三问答案最终自检确认需求完整性\n## 贯穿案例：小李的待办清单完整演示 ​\n让我们用小李的待办清单项目，完整演示八步流程。\n\n### Step 1-6：第二章的思考成果 ​\n\n小李在第二章完成了以下思考：\n\n问题发现：\n\n我经常遗漏重要任务，被领导批评了好几次。用烦恼日记记录了一周，五维评分 23 分，适合用 Vibe Coding 解决。\n\nJTBD 任务描述：\n\n当我每天开始工作时，我想快速记录今天要做的事，这样我就不会遗漏重要任务，可以安心投入工作。\n\nPre-mortem 风险清单：\n失败原因预防措施功能太多做不完第一版只做 3 个核心功能用起来比便签还麻烦添加任务必须 3 秒内完成做完了自己都不用先用一周纸质清单验证习惯\nMVP 优先级：\n优先级功能P0添加任务、完成任务、查看今日任务P1删除任务、任务排序不做分类标签、截止日期、提醒通知、历史统计\n用户画像：\n维度内容表面属性25 岁，职场新人，每天处理 10-15 件事务行为习惯早上到公司第一件事看邮件，用手机备忘录但经常忘记看深层动机害怕遗漏任务被批评，想成为靠谱的人\n灵魂三问：\n问题回答用户是谁？像我一样怕遗漏任务的职场新人痛点在哪？经常忘事被批评，感到焦虑为什么选我？比便签好用，比复杂工具简单\n### Step 7：编写 PRD（整合第二章成果） ​\n\n现在，把第二章的思考成果整合进 PRD：\nmarkdown\n`# 个人待办清单 PRD\n\n## 1. 项目背景\n\n### 问题来源\n我是一名 25 岁的职场新人，每天需要处理 10-15 件大小事务。\n经常因为忘记任务被领导批评，用过手机备忘录但经常忘记看。\n\n### 核心任务（JTBD）\n当我每天开始工作时，我想快速记录今天要做的事，\n这样我就不会遗漏重要任务，可以安心投入工作。\n\n### 为什么现有方案不够好\n- 便签纸：容易丢，不能随时带着\n- 手机备忘录：需要专门打开，经常忘记看\n- 专业工具（Notion、滴答清单）：功能太多，学习成本高\n\n## 2. 目标用户\n\n### 用户画像\n- **身份**：职场新人（1-3 年工作经验）\n- **特点**：事情多、容易忘、怕被批评\n- **场景**：早上到公司打开电脑、突然想起一件事、下班前检查\n\n### 核心需求\n- 打开就能看到今天的任务\n- 添加任务要极快（3 秒内）\n- 界面简单，没有学习成本\n\n## 3. 功能范围\n\n### P0 功能（第一版必须有）\n1. **添加任务**：输入框 + 回车即可添加\n2. **完成任务**：点击任务左侧圆圈打勾\n3. **查看任务**：打开页面就是今日任务列表\n\n### P1 功能（第二版考虑）\n- 删除任务\n- 任务排序（拖拽）\n\n### 不做清单\n- ❌ 任务分类或标签\n- ❌ 截止日期或提醒\n- ❌ 历史记录或统计\n- ❌ 用户登录\n- ❌ 多设备同步\n\n## 4. 技术约束\n\n- 技术栈：React + TypeScript + Tailwind CSS\n- 数据存储：浏览器 localStorage（暂不需要后端）\n- 响应式：手机和电脑都能用\n\n## 5. 验证标准\n\n### MVP 成功标准\n自己连续使用 7 天，每天都用它记录和完成任务。\n\n### 核心假设\n一个极简的每日待办清单，比便签纸和手机备忘录更好用。`\n### Step 8：转化为第一个 Prompt ​\n有了 PRD，我们可以开始与 AI 对话。第一个 Prompt 用于实现 P0 功能中的「添加任务」：\nmarkdown\n`【Situation - 情境】\n我在做一个个人待办清单网页应用。\n技术栈：React + TypeScript + Tailwind CSS\n目标用户：容易忘事的职场新人（就是我自己）\n设计原则：\n- 极简，打开就是今日待办\n- 添加任务 3 秒内完成\n- 没有学习成本\n\n当前进度：项目刚初始化，还没有任何功能代码\n\n【Challenge - 挑战】\n实现「添加任务」功能：\n- 用户在输入框输入任务内容\n- 按回车键或点击添加按钮，任务添加到列表\n- 添加成功后自动清空输入框并聚焦\n- 空内容不能添加，输入框轻微抖动提示\n\n【Audience - 受众】\n- 用户：我自己，希望操作越简单越好\n- 代码维护者：我自己，React 初学者\n- 请在关键逻辑处加注释，解释为什么这样写\n\n【Format - 格式】\n请提供：\n1. AddTask 组件代码（处理输入和添加）\n2. TaskList 组件代码（展示任务列表）\n3. 任务数据的 TypeScript 类型定义\n4. 简单的组件使用说明\n\n【Foundations - 约束】\n- 任务数据暂存在组件 state，不需要持久化\n- 不用任何状态管理库（Redux、Zustand 等）\n- 不用任何 UI 组件库\n- 样式用 Tailwind，保持简洁\n- 每个任务只需要：id + 内容文本 + 完成状态`\n## 工作流检查清单 ​\n在开始与 AI 对话之前，用这份清单确认你已经准备好了：\n\n### 第二章成果检查 ​\nmarkdown\n`□ 我知道要解决什么问题（问题发现）\n□ 我能用 JTBD 格式描述用户任务\n□ 我列出了可能导致失败的原因（Pre-mortem）\n□ 我明确了 P0/P1/P2 和不做清单（减法思维）\n□ 我知道用户是谁、在什么场景使用（用户画像）\n□ 灵魂三问都能一句话回答`\n### 第三章准备检查 ​\nmarkdown\n```\n□ 我整合了第二章成果，写好了 PRD\n□ 我知道第一个 Prompt 要实现什么功能\n□ 我选择了合适的提示词框架（S.C.A.F.F. / R.G.C.）\n□ 我准备好了迭代（不期待一次完美）\n□ 我知道如何验证 AI 的输出（特别是包和 API）\n```\n\n## 常见问题：从第二章到第三章的过渡 ​\n\n### Q1：第二章的内容太多，PRD 要全部写进去吗？ ​\nA：不需要。PRD 只需要包含 AI 执行任务所需的信息。\n第二章内容是否写入 PRD原因问题来源和动机✅ 写入背景帮助 AI 理解项目目的JTBD 任务描述✅ 写入用户需求明确用户要完成什么Pre-mortem 清单✅ 转化为约束变成「不做清单」五维评分细节❌ 不需要这是你自己的决策过程用户画像✅ 精简版写入帮助 AI 理解用户特征用户旅程全图❌ 精简为场景只保留关键触点\n### Q2：每次对话都要写完整的 PRD 吗？ ​\n\nA：不需要。PRD 是项目级别的文档，单次对话只需要提供当前任务所需的上下文。\n\n- 项目开始时：写完整的 PRD，让 AI 理解整体背景\n- 后续对话：引用 PRD 中的相关部分，聚焦当前任务\n### Q3：PRD 和 Prompt 有什么区别？ ​\n\nA：\n维度PRDPrompt粒度整个项目单个任务用途记录思考、统一理解让 AI 执行具体任务更新频率项目开始时写，后续微调每次对话都要写包含内容背景、用户、功能、约束当前任务 + 相关上下文\n## 本节要点 ​\n\n✓ 八步流程：问题发现 → 任务定义 → 风险预判 → 范围收敛 → 用户理解 → 最终自检 → 编写 PRD → 迭代对话\n\n✓ 成果映射：第二章的每个输出都能对应到 PRD 的某个部分\n\n✓ PRD 是桥梁：它连接了「想清楚」和「说明白」，是从思考到执行的转换器\n\n✓ 不需要完美：PRD 是活文档，可以在开发过程中不断完善\n\n下一节，我们将提供一份可随时查阅的提示词速查清单。",
      "word_count": 5753,
      "estimated_time": 11
    },
    {
      "id": "lesson-101",
      "chapter_id": "chapter-03",
      "lesson_number": 32,
      "title": "3.7.3 提示词速查清单",
      "content": "# 3.7.3 提示词速查清单 ​\n\n本节提供一系列可直接使用的速查清单和模板，建议收藏或打印备用。\n\n## 一页纸速查表：提问前必查 ​\n\n在向 AI 提问之前，快速检查这九项：\n\n`┌─────────────────────────────────────────────────────────────┐\n│                    提示词自检清单 v1.0                        │\n├─────────────────────────────────────────────────────────────┤\n│                                                             │\n│  □ 1. 我说清楚【背景】了吗？                                  │\n│       （项目类型、技术栈、当前进度）                          │\n│                                                             │\n│  □ 2. 我说清楚【任务】了吗？                                  │\n│       （要做什么、输入输出是什么）                            │\n│                                                             │\n│  □ 3. 我说清楚【约束】了吗？                                  │\n│       （必须遵守的限制、不能做什么）                          │\n│                                                             │\n│  □ 4. 我说清楚【格式】了吗？                                  │\n│       （要完整代码还是片段、需要注释吗）                      │\n│                                                             │\n│  □ 5. 我给【示例】了吗？                                      │\n│       （如果需要特定格式输出）                                │\n│                                                             │\n│  □ 6. 我的提示词够【具体】吗？                                │\n│       （能否更精确地描述期望）                                │\n│                                                             │\n│  □ 7. 我告诉 AI【什么不能做】了吗？                           │\n│       （防止 AI「加戏」）                                     │\n│                                                             │\n│  □ 8. 我准备好【迭代】了吗？                                  │\n│       （不期待一次完美）                                      │\n│                                                             │\n│  □ 9. 我整合了【第二章的思考成果】吗？                        │\n│       （用户画像、MVP 范围、灵魂三问）                        │\n│                                                             │\n└─────────────────────────────────────────────────────────────┘`\n## 分场景 Prompt 模板 ​\n\n### 场景一：代码生成 ​\n适用于：创建新组件、实现新功能、生成完整模块\nmarkdown\n`【背景】\n项目类型：[网页应用/数据分析/自动化脚本/...]\n技术栈：[React/Python/Node.js/...]\n当前进度：[项目刚开始/已有基础结构/...]\n\n【任务】\n请帮我实现 [功能名称]：\n- 功能描述：[用户做什么，系统做什么]\n- 输入：[用户输入什么]\n- 输出：[系统输出什么]\n\n【约束】\n必须：\n- [约束1]\n- [约束2]\n\n不能：\n- [约束3]\n- [约束4]\n\n【格式要求】\n- [ ] 完整代码文件\n- [ ] 包含 TypeScript 类型\n- [ ] 包含关键注释\n- [ ] 包含使用说明`填写示例：\nmarkdown\n`【背景】\n项目类型：个人待办清单网页应用\n技术栈：React + TypeScript + Tailwind CSS\n当前进度：项目已初始化，已有 AddTask 组件\n\n【任务】\n请帮我实现「删除任务」功能：\n- 功能描述：用户点击任务右侧的删除图标，该任务从列表中移除\n- 输入：用户点击删除图标\n- 输出：任务从列表中消失，显示简短的撤销提示\n\n【约束】\n必须：\n- 删除前显示确认提示（防止误删）\n- 删除后 3 秒内可撤销\n- 样式用 Tailwind CSS\n\n不能：\n- 不用任何 UI 组件库\n- 不用 confirm() 弹窗（体验不好）\n\n【格式要求】\n- [x] 完整代码文件\n- [x] 包含 TypeScript 类型\n- [x] 包含关键注释\n- [ ] 包含使用说明`\n### 场景二：代码修改 ​\n适用于：修复 Bug、优化性能、重构代码\nmarkdown\n`【当前代码】\n```[语言]\n[粘贴当前代码]`【问题描述】 现在的问题是：[具体描述问题现象] 期望的行为是：[描述正确的行为]\n\n【修改要求】\n\n- [要求1]\n- [要求2]\n【约束】\n\n- 只修改必要的部分，保持其他代码不变\n- [其他约束]\n`\n**填写示例**：\n\n```markdown\n【当前代码】\n```typescript\nconst handleSubmit = () => {\n  if (inputValue) {\n    addTask(inputValue);\n    setInputValue('');\n  }\n}`【问题描述】 现在的问题是：输入空格也能添加任务 期望的行为是：只有真正有内容时才能添加，空格应该被忽略\n\n【修改要求】\n\n- 添加前去除首尾空格\n- 去除空格后如果为空，显示提示\n【约束】\n\n- 只修改必要的部分，保持其他代码不变\n- 提示用 toast 而不是 alert\n`\n\n### 场景三：问题排查\n\n适用于：代码报错、功能异常、性能问题\n\n```markdown\n【问题现象】\n[描述你看到了什么]\n\n【期望行为】\n[描述你期望看到什么]\n\n【相关代码】\n```[语言]\n[粘贴相关代码]`【已尝试的方法】\n\n- [尝试1]：[结果]\n- [尝试2]：[结果]\n【环境信息】\n\n- 浏览器/运行环境：[版本]\n- 相关库版本：[版本]\n【请帮我】\n\n- 分析可能的原因\n- 给出解决方案\n- 解释为什么会出现这个问题\n`\n**填写示例**：\n\n```markdown\n【问题现象】\n点击「完成任务」按钮后，任务状态没有变化，控制台没有报错\n\n【期望行为】\n点击后任务左侧的圆圈应该变成勾选状态\n\n【相关代码】\n```typescript\nconst toggleComplete = (id: string) => {\n  setTasks(tasks.map(task => \n    task.id === id ? { ...task, complete: !task.complete } : task\n  ));\n}`【已尝试的方法】\n\n- 检查 id 是否正确传递：console.log 确认 id 是对的\n- 检查 tasks 状态：更新前后 tasks 数组没有变化\n【环境信息】\n\n- 浏览器：Chrome 120\n- React 版本：18.2.0\n【请帮我】\n\n- 分析可能的原因\n- 给出解决方案\n- 解释为什么会出现这个问题\n`\n\n### 场景四：技术选型\n\n适用于：选择库、框架、架构方案\n\n```markdown\n【项目背景】\n[简要描述项目]\n\n【选型需求】\n我需要选择 [选型类型]，主要考虑：\n- [考虑因素1]\n- [考虑因素2]\n- [考虑因素3]\n\n【候选方案】（可选）\n1. [方案A]\n2. [方案B]\n3. [方案C]\n\n【请帮我】\n1. 分析每个方案的优缺点\n2. 给出推荐方案及理由\n3. 说明什么情况下应该选择其他方案`填写示例：\nmarkdown\n`【项目背景】\n个人待办清单应用，目前数据存在 localStorage，想支持多设备同步\n\n【选型需求】\n我需要选择后端数据存储方案，主要考虑：\n- 免费或低成本（个人项目）\n- 上手简单（我是后端小白）\n- 支持用户认证\n\n【候选方案】\n1. Supabase\n2. Firebase\n3. 自己搭建 Node.js + MongoDB\n\n【请帮我】\n1. 分析每个方案的优缺点\n2. 给出推荐方案及理由\n3. 说明什么情况下应该选择其他方案`\n## 常见错误自检清单 ​\n在发送 Prompt 前，检查是否犯了这五个常见错误：\n#错误检查方法修正方式1没有背景删掉背景后 AI 还能理解吗？加上项目类型和技术栈2太模糊「优化代码」优化什么？具体说明优化哪个方面3没有约束AI 可能「加戏」吗？加上「不做清单」4没有格式AI 输出格式随机？指定要代码还是解释5一次要太多任务超过 3 个要点？拆分成多轮对话\n## 幻觉验证快速指南 ​\n\n当 AI 推荐了你不熟悉的包或 API 时，用这个流程验证：\n\n`AI 推荐了一个包或 API\n        │\n        ▼\n┌─────────────────────────┐\n│ 1. 验证包是否存在         │\n│    npm search <包名>     │\n│    或访问 npmjs.com      │\n└─────────────────────────┘\n        │\n        ├─ 不存在 ──────────▶ 🔴 包幻觉，要求 AI 重新推荐\n        │\n        ▼ 存在\n┌─────────────────────────┐\n│ 2. 检查包的可靠性         │\n│    - 周下载量 > 1000?    │\n│    - 最近更新 < 1年?     │\n│    - GitHub stars > 100? │\n└─────────────────────────┘\n        │\n        ├─ 不满足 ──────────▶ 🟡 谨慎使用，考虑替代方案\n        │\n        ▼ 满足\n┌─────────────────────────┐\n│ 3. 验证 API 是否正确      │\n│    查阅官方文档          │\n└─────────────────────────┘\n        │\n        ├─ API 不存在 ─────▶ 🔴 API 幻觉，查文档找正确 API\n        │\n        ▼ API 存在\n        ✅ 可以使用`\n## 迭代反馈模板 ​\n当 AI 的输出不满意时，使用这个模板给反馈：\nmarkdown\n`【问题】\n[具体指出哪里不对]\n\n【原因】\n[解释为什么这样不行]\n\n【期望】\n[明确说明你想要什么]\n\n【示例】（可选）\n[给一个你期望的示例]`填写示例：\nmarkdown\n`【问题】\n你给的代码中，删除任务后没有撤销功能\n\n【原因】\n用户可能误删，需要有后悔的机会\n\n【期望】\n删除后显示一个 3 秒的「撤销」提示，点击可以恢复任务\n\n【示例】\n类似 Gmail 删除邮件后底部出现的「撤销」按钮`\n## 可复制的万能模板 ​\n这是一个通用模板，适用于大多数场景：\nmarkdown\n`## 背景\n我正在做 [项目类型]。\n技术栈：[技术栈]\n目标用户：[用户描述]\n\n## 当前任务\n[具体描述要做什么]\n\n## 要求\n1. [要求1]\n2. [要求2]\n3. [要求3]\n\n## 不需要\n- [不需要1]\n- [不需要2]\n\n## 输出格式\n[说明期望的输出格式]\n\n## 关于我\n我是 [技术水平]，如果有 [注意事项]，请提醒我。`\n## 本节要点 ​\n✓ 提问前必查：背景、任务、约束、格式、示例、具体性、不做清单、迭代准备、第二章成果\n\n✓ 四种场景模板：代码生成、代码修改、问题排查、技术选型\n\n✓ 五个常见错误：没背景、太模糊、没约束、没格式、一次要太多\n\n✓ 幻觉验证：先验证存在性，再检查可靠性，最后查官方文档\n\n下一节，我们将通过四个综合练习，帮助你内化这些技能。",
      "word_count": 5762,
      "estimated_time": 11
    },
    {
      "id": "lesson-102",
      "chapter_id": "chapter-03",
      "lesson_number": 33,
      "title": "3.7.4 实战演练：综合练习",
      "content": "# 3.7.4 实战演练：综合练习 ​\n\n本节提供四个综合练习，帮助你内化本章所学技能。建议认真完成每个练习，然后对照参考答案自评。\n\n## 练习一：提示词改写 ​\n\n### 任务说明 ​\n\n下面有三个「差提示词」，请用 S.C.A.F.F. 框架改写成「好提示词」。\n\n### 差提示词 1 ​\n\n`帮我做一个登录页面`你的改写：\n\n（请先自己尝试改写，再看参考答案）\n点击查看参考答案markdown\n`【Situation - 情境】\n我正在开发一个个人博客的管理后台。\n技术栈：Next.js 16 + TypeScript + Tailwind CSS\n当前进度：首页和文章列表页已完成，现在需要添加登录功能\n设计风格：极简风格，参考 Notion 的登录页面\n\n【Challenge - 挑战】\n实现管理员登录页面：\n- 表单包含：邮箱输入框、密码输入框、登录按钮\n- 点击登录后，验证格式（邮箱格式、密码不为空）\n- 格式错误时，在对应输入框下方显示红色提示\n- 暂时不需要真正的后端验证，先做前端界面和交互\n\n【Audience - 受众】\n- 用户：只有我一个人（博客管理员）\n- 代码维护者：我自己，React 初学者\n- 请在关键逻辑处添加注释\n\n【Format - 格式】\n请提供：\n1. 完整的登录页面组件代码（单文件）\n2. 包含 TypeScript 类型定义\n3. 样式使用 Tailwind CSS\n4. 文件命名：LoginPage.tsx\n\n【Foundations - 约束】\n- 不使用任何 UI 组件库\n- 不使用第三方表单库\n- 状态管理用 React 原生的 useState\n- 响应式设计：移动端和桌面端都要适配`评分标准：\n\n- ✅ 有项目背景和技术栈（2分）\n- ✅ 任务描述具体，有输入输出（2分）\n- ✅ 说明了受众和技术水平（1分）\n- ✅ 指定了输出格式（2分）\n- ✅ 有明确的约束条件（2分）\n- ✅ 使用了框架结构（1分）\n满分 10 分，8 分以上为优秀。\n\n### 差提示词 2 ​\n\n`帮我分析一下这段代码有什么问题`你的改写：\n点击查看参考答案markdown\n`【当前代码】\n```typescript\nconst fetchUsers = async () => {\n  const response = await fetch('/api/users');\n  const data = response.json();\n  setUsers(data);\n}`【问题现象】 调用这个函数后，users 状态是一个 Promise 对象而不是数组，导致渲染时报错。\n\n【期望行为】 users 应该是从 API 获取的用户数组\n\n【请帮我】\n\n- 指出代码中的问题\n- 解释为什么会出现这个问题\n- 给出修正后的代码\n- 说明如何避免类似错误\n【关于我】 我是 JavaScript 初学者，对 async/await 还不太熟悉\n\n`\n**评分标准**：\n- ✅ 提供了具体的代码（2分）\n- ✅ 描述了问题现象（2分）\n- ✅ 说明了期望行为（2分）\n- ✅ 明确了需要什么帮助（2分）\n- ✅ 说明了自己的技术水平（2分）\n\n满分 10 分，8 分以上为优秀。\n\n</details>\n\n### 差提示词 3`我想做个记账软件\n\n`\n**你的改写**：\n\n<details>\n<summary>点击查看参考答案</summary>\n\n```markdown\n【Situation - 情境】\n我想做一个个人记账网页应用，帮助自己追踪日常开销。\n技术栈：React + TypeScript + Tailwind CSS\n目标用户：我自己（月光族，想知道钱花哪了）\n设计原则：极简，记一笔账不超过 5 秒\n\n【Challenge - 挑战】\n第一版（MVP）实现以下功能：\n1. 快速记账：选择分类 + 输入金额 + 可选备注\n2. 查看账单：按日期查看当天的所有记录\n3. 月度汇总：显示当月总支出和各分类占比\n\n【Audience - 受众】\n- 用户：我自己，需要简单快捷\n- 代码维护者：我自己，有一点 React 基础\n\n【Format - 格式】\n这是第一次对话，请先帮我：\n1. 确认这个 MVP 范围是否合理\n2. 建议项目的文件结构\n3. 列出需要实现的组件清单\n\n【Foundations - 约束】\n- 数据先存在 localStorage，不需要后端\n- 分类固定为：餐饮、交通、购物、娱乐、其他\n- 只记支出，不记收入（简化）\n- 不需要用户登录\n\n【不做清单】\n- 不做多账本\n- 不做预算功能\n- 不做数据导出\n- 不做图表可视化（第二版考虑）`评分标准：\n\n- ✅ 有完整的项目背景（2分）\n- ✅ MVP 功能范围明确（2分）\n- ✅ 有「不做清单」（2分）\n- ✅ 第一次对话请求合理（规划而非直接写代码）（2分）\n- ✅ 约束条件具体（2分）\n满分 10 分，8 分以上为优秀。\n\n## 练习二：PRD 编写实战 ​\n\n### 任务说明 ​\n\n假设你想做一个「读书笔记」工具，帮助自己记录读书心得。\n\n请整合第二章的思维工具，完成以下内容：\n\n- 用 JTBD 格式描述用户任务\n- 用减法思维确定 MVP 范围（P0/P1/不做）\n- 回答灵魂三问\n- 写出一份精简版 PRD\n### 你的答案 ​\n\n（请先自己完成，再看参考答案）\n点击查看参考答案\n### 1. JTBD 任务描述 ​\n\n当我读完一本书的某个章节时，我想快速记录关键观点和我的思考，这样我在需要回顾时能够快速找到这些笔记，而不是重新翻书。\n\n### 2. MVP 范围 ​\n优先级功能原因P0创建笔记（书名 + 章节 + 内容）核心功能P0查看所有笔记列表核心功能P0按书名筛选笔记找笔记必须快P1编辑已有笔记经常需要修改补充P1删除笔记清理无用笔记不做笔记标签/分类增加复杂度，MVP 不需要不做笔记分享个人使用，不需要不做Markdown 编辑器简单文本足够不做书籍信息自动获取手动输入书名即可\n### 3. 灵魂三问 ​\n问题回答用户是谁？我自己——喜欢读书但经常忘记书中内容的人痛点在哪？读过的书记不住，需要时找不到当时的思考为什么做这个？现有工具（Notion、备忘录）要么太重，要么不好按书检索\n### 4. 精简版 PRD ​\nmarkdown\n`# 读书笔记工具 PRD\n\n## 项目背景\n\n### 问题\n我喜欢读书，但经常读完就忘。需要回顾时，要么重新翻书，要么在各种 app 里找当时的笔记，很费时间。\n\n### JTBD\n当我读完一本书的某个章节时，我想快速记录关键观点和我的思考，这样我在需要回顾时能够快速找到这些笔记。\n\n## 目标用户\n\n- 身份：喜欢读书的个人用户\n- 场景：读完一章后记录、需要引用时检索\n- 核心需求：快速记录 + 快速检索\n\n## P0 功能\n\n### 功能1：创建笔记\n- 必填：书名、笔记内容\n- 选填：章节名、页码\n- 交互：打开页面直接可以开始写\n\n### 功能2：查看笔记列表\n- 按创建时间倒序显示\n- 每条显示：书名、章节、内容摘要、时间\n- 点击可查看完整内容\n\n### 功能3：按书名筛选\n- 页面顶部有书名筛选器\n- 选择后只显示该书的笔记\n\n## 技术方案\n\n- 前端：React + TypeScript + Tailwind CSS\n- 数据：localStorage（个人使用，不需要后端）\n- 响应式：支持手机和电脑\n\n## 不做清单\n\n- 不做笔记标签/分类\n- 不做笔记分享功能\n- 不做 Markdown 编辑器\n- 不做书籍封面/信息自动获取\n- 不做多端同步\n\n## 成功标准\n\n自己使用 2 周，记录至少 10 条笔记，并成功检索到之前的笔记。`自评标准：\n\n- ✅ JTBD 描述完整（场景 + 任务 + 价值）\n- ✅ MVP 范围有优先级，有「不做清单」\n- ✅ 灵魂三问都能回答\n- ✅ PRD 结构完整，AI 能理解执行\n## 练习三：迭代对话模拟 ​\n\n### 任务说明 ​\n\n假设你让 AI 帮你实现「读书笔记」的创建功能，AI 给了你以下代码，但有问题。\n\n请模拟 3 轮迭代对话，逐步修正问题。\n\n### AI 第一次输出 ​\ntypescript\n`const CreateNote = () => {\n  const [bookName, setBookName] = useState('');\n  const [content, setContent] = useState('');\n\n  const handleSubmit = () => {\n    const note = { bookName, content };\n    const notes = JSON.parse(localStorage.getItem('notes'));\n    notes.push(note);\n    localStorage.setItem('notes', JSON.stringify(notes));\n  }\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input value={bookName} onChange={e => setBookName(e.target.value)} />\n      <textarea value={content} onChange={e => setContent(e.target.value)} />\n      <button type=\"submit\">保存</button>\n    </form>\n  );\n}`\n### 问题识别 ​\n请找出这段代码的问题，然后写出你的反馈。\n点击查看问题分析和迭代示例\n### 问题清单 ​\n\n- localStorage.getItem 可能返回 null：第一次使用时会报错\n- 没有生成 note id：后续编辑/删除需要 id\n- 没有记录创建时间：列表需要按时间排序\n- 表单提交后没有清空输入：用户体验差\n- 没有表单验证：空内容也能提交\n- handleSubmit 没有阻止默认行为：表单会刷新页面\n### 第一轮反馈 ​\nmarkdown\n`【问题】\n1. localStorage.getItem('notes') 第一次会返回 null，导致 notes.push 报错\n2. handleSubmit 没有 e.preventDefault()，表单会刷新页面\n\n【原因】\nlocalStorage 第一次使用时没有数据，JSON.parse(null) 会出错\n\n【期望】\n1. 处理 localStorage 为空的情况，初始化为空数组\n2. 阻止表单默认提交行为`\n### AI 第二次输出 ​\ntypescript\n```\nconst handleSubmit = (e: React.FormEvent) => {\n  e.preventDefault();\n  const note = { bookName, content };\n  const existingNotes = localStorage.getItem('notes');\n  const notes = existingNotes ? JSON.parse(existingNotes) : [];\n  notes.push(note);\n  localStorage.setItem('notes', JSON.stringify(notes));\n}\n```\n\n### 第二轮反馈 ​\nmarkdown\n```\n【问题】\n1. 笔记没有 id，后续无法编辑或删除特定笔记\n2. 没有创建时间，列表无法按时间排序\n\n【期望】\n每条笔记需要包含：\n- id：使用 Date.now() 或 uuid\n- createdAt：创建时间戳\n- bookName：书名\n- content：内容\n```\n\n### AI 第三次输出 ​\ntypescript\n```\nconst handleSubmit = (e: React.FormEvent) => {\n  e.preventDefault();\n  const note = {\n    id: Date.now().toString(),\n    bookName,\n    content,\n    createdAt: new Date().toISOString()\n  };\n  const existingNotes = localStorage.getItem('notes');\n  const notes = existingNotes ? JSON.parse(existingNotes) : [];\n  notes.push(note);\n  localStorage.setItem('notes', JSON.stringify(notes));\n}\n```\n\n### 第三轮反馈 ​\nmarkdown\n```\n【问题】\n1. 保存成功后没有清空输入框\n2. 没有表单验证，书名和内容为空也能提交\n3. 没有保存成功的反馈提示\n\n【期望】\n1. 保存成功后清空 bookName 和 content\n2. 书名和内容都不能为空（去除空格后判断）\n3. 保存成功后显示简短提示（如 toast）\n\n【示例】\n保存成功后：\n- 输入框清空\n- 显示「笔记已保存」提示 2 秒后消失\n```\n\n### 最终代码 ​\ntypescript\n```\nconst CreateNote = () => {\n  const [bookName, setBookName] = useState('');\n  const [content, setContent] = useState('');\n  const [showToast, setShowToast] = useState(false);\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    \n    // 表单验证\n    if (!bookName.trim() || !content.trim()) {\n      return;\n    }\n\n    const note = {\n      id: Date.now().toString(),\n      bookName: bookName.trim(),\n      content: content.trim(),\n      createdAt: new Date().toISOString()\n    };\n    \n    const existingNotes = localStorage.getItem('notes');\n    const notes = existingNotes ? JSON.parse(existingNotes) : [];\n    notes.push(note);\n    localStorage.setItem('notes', JSON.stringify(notes));\n    \n    // 清空输入并显示提示\n    setBookName('');\n    setContent('');\n    setShowToast(true);\n    setTimeout(() => setShowToast(false), 2000);\n  }\n\n  return (\n    <>\n      <form onSubmit={handleSubmit}>\n        <input \n          value={bookName} \n          onChange={e => setBookName(e.target.value)}\n          placeholder=\"书名\"\n        />\n        <textarea \n          value={content} \n          onChange={e => setContent(e.target.value)}\n          placeholder=\"笔记内容\"\n        />\n        <button type=\"submit\">保存</button>\n      </form>\n      {showToast && <div className=\"toast\">笔记已保存</div>}\n    </>\n  );\n}\n```\n迭代要点：\n\n- 每轮只反馈 2-3 个问题，不要一次性列出所有问题\n- 反馈格式：问题 + 原因 + 期望\n- 重要问题（如报错）优先处理\n## 练习四：幻觉识别与修正 ​\n\n### 任务说明 ​\n\n假设 AI 给了你以下代码片段。请识别其中的幻觉问题，并说明如何验证和修正。\n\n### AI 输出 ​\ntypescript\n`// AI 推荐使用 super-easy-storage 库来简化 localStorage 操作\nimport { createStore, useStore } from 'super-easy-storage';\n\nconst notesStore = createStore('notes', []);\n\nconst CreateNote = () => {\n  const [notes, setNotes] = useStore(notesStore);\n  \n  // 使用 array.findLast() 获取最后一条笔记\n  const lastNote = notes.findLast(note => note.bookName === currentBook);\n  \n  // 使用 React 18 的 useTransition 处理大列表\n  const [isPending, startTransition] = useTransition();\n  \n  const handleSubmit = () => {\n    startTransition(() => {\n      setNotes([...notes, newNote]);\n    });\n  }\n}`\n### 你的答案 ​\n请识别上述代码中的幻觉问题，并说明验证方法。\n点击查看参考答案\n### 幻觉识别 ​\n代码位置问题类型问题描述验证方法`super-easy-storage`🔴 包幻觉这个包可能不存在`npm search super-easy-storage` 或访问 npmjs.com`array.findLast()`🟡 API 幻觉ES2023 新 API，旧环境不支持查 MDN 文档确认兼容性`useTransition`✅ 正确React 18 确实有这个 Hook但需确认项目用的是 React 18\n### 验证步骤 ​\n\n1. 验证 super-easy-storage 包\nbash\n`npm search super-easy-storage`结果：没有找到这个包。这是一个包幻觉。\n\n修正方案：\n\n- 使用真实存在的库，如 `zustand` 或 `jotai`\n- 或者自己封装一个简单的 localStorage hook\n2. 验证 findLast() API\n\n访问 MDN - Array.findLast()\n\n结果：\n\n- ES2023 引入\n- Chrome 97+、Firefox 104+、Safari 15.4+\n- Node.js 18+\n修正方案：\ntypescript\n`// 兼容写法\nconst lastNote = [...notes].reverse().find(note => note.bookName === currentBook);\n\n// 或添加 polyfill`3. 验证 useTransition\n\n访问 React 文档 - useTransition\n\n结果：React 18 确实有这个 Hook。\n\n需要确认：\n\n- 项目的 React 版本是否 >= 18\n- 当前场景是否真的需要 useTransition（这里可能是过度优化）\n### 修正后的代码 ​\ntypescript\n`// 使用 zustand 替代不存在的 super-easy-storage\nimport { create } from 'zustand';\nimport { persist } from 'zustand/middleware';\n\ninterface NotesState {\n  notes: Note[];\n  addNote: (note: Note) => void;\n}\n\nconst useNotesStore = create<NotesState>()(\n  persist(\n    (set) => ({\n      notes: [],\n      addNote: (note) => set((state) => ({ \n        notes: [...state.notes, note] \n      })),\n    }),\n    { name: 'notes-storage' }\n  )\n);\n\nconst CreateNote = () => {\n  const { notes, addNote } = useNotesStore();\n  \n  // 使用兼容写法替代 findLast\n  const lastNote = [...notes]\n    .reverse()\n    .find(note => note.bookName === currentBook);\n  \n  const handleSubmit = () => {\n    addNote(newNote);\n  }\n}`\n### 验证习惯总结 ​\n\n- 遇到不熟悉的包：先 npm search 验证存在性\n- 遇到不熟悉的 API：查阅 MDN 或官方文档\n- 遇到新语法：确认项目环境是否支持\n- 遇到「高级用法」：先验证是否真的需要\n## 练习自评表 ​\n完成四个练习后，用这个表格自评：\n练习完成情况主要收获需要加强的地方练习一：提示词改写□ 完成 □ 部分完成 □ 未完成练习二：PRD 编写□ 完成 □ 部分完成 □ 未完成练习三：迭代对话□ 完成 □ 部分完成 □ 未完成练习四：幻觉识别□ 完成 □ 部分完成 □ 未完成\n## 本节要点 ​\n\n✓ 提示词改写：用 S.C.A.F.F. 框架把模糊需求转化为结构化提示词\n\n✓ PRD 编写：整合第二章思考成果，形成 AI 能理解的任务书\n\n✓ 迭代对话：每轮反馈 2-3 个问题，格式为「问题 + 原因 + 期望」\n\n✓ 幻觉识别：对不熟悉的包和 API，先验证再使用\n\n恭喜你完成了第三章的所有学习内容！下一节我们将盘点你学到的技能，并为第四章的实战开发做准备。",
      "word_count": 9717,
      "estimated_time": 19
    },
    {
      "id": "lesson-103",
      "chapter_id": "chapter-03",
      "lesson_number": 34,
      "title": "3.7.5 从本章到下一章",
      "content": "# 3.7.5 从本章到下一章 ​\n\n## 能力盘点：你现在具备什么 ​\n\n完成第二章和第三章的学习后，你已经具备了以下能力：\n\n### 思维能力（第二章） ​\n能力你能做到问题发现从日常烦恼中识别值得解决的问题任务定义用 JTBD 描述用户真正要完成的任务风险预判用逆向思维提前识别失败原因范围收敛用减法思维确定 MVP 和「不做清单」用户理解构建用户画像，描述用户旅程自我检验用灵魂三问确认准备就绪\n### 表达能力（第三章） ​\n能力你能做到上下文构建给 AI 提供完整的项目、任务、个人上下文结构化表达用 S.C.A.F.F. 或 R.G.C. 框架组织提示词技巧选择根据任务类型选择 Zero-shot/Few-shot/CoT 等技巧PRD 编写整合思考成果，写出 AI 能理解的需求文档迭代对话通过精确反馈逐步逼近理想结果问题处理识别 AI 幻觉，知道何时需要人工干预\n## 心法 + 技法 = 准备好动手了 ​\n\n现在，你已经完成了「想清楚」和「说明白」的训练：\n\n`┌─────────────────────────────────────────────────────────────┐\n│                                                             │\n│   第一章                                                    │\n│   觉醒                                                      │\n│   └─▶ 理解 Vibe Coding 是什么                               │\n│                                                             │\n│   第二章          第三章                                     │\n│   心法            技法                                       │\n│   └─▶ 想清楚  +   └─▶ 说明白  =  准备好动手了                │\n│                                                             │\n│   第四章                                                    │\n│   实战                                                      │\n│   └─▶ 从 0 到 1 做出来                                      │\n│                                                             │\n└─────────────────────────────────────────────────────────────┘`下一章，你将把这些能力用在真实的项目上。\n\n## 第四章预告：从 0 到 1 开发个人工具 ​\n\n### 你将学到 ​\n阶段内容你会得到准备整合第二章 + 第三章成果完整的项目 PRD静态层搭建页面框架和样式可以看的界面交互层实现核心功能可以用的功能存储层让数据持久化刷新不丢失调试处理 AI 代码报错Debug 实战经验收尾完整项目回顾你的第一个作品\n### 贯穿案例 ​\n\n第四章将继续使用小李的待办清单项目。你会看到：\n\n- 如何把第二章的 PRD 转化为第一个 Prompt\n- 如何通过迭代对话实现三个 P0 功能\n- 如何处理 AI 代码中的 Bug\n- 最终得到一个完整可用的待办清单应用\n### 你需要准备的 ​\n\n进入第四章之前，请确认：\nmarkdown\n`□ 我有一个 AI 编程工具可用（Cursor、Windsurf、Bolt.new 等任意一个）\n□ 我完成了第二章的项目思考（或者准备用小李的待办清单跟着做）\n□ 我准备好了 2-3 小时的集中学习时间\n□ 我有心理准备：AI 可能会犯错，但我知道怎么修正`\n## 课后作业 ​\n在进入第四章之前，请完成以下作业：\n\n### 作业一：选择你的项目 ​\n\n从以下选项中选择一个，或者用你自己的想法：\n项目类型示例难度个人工具待办清单、读书笔记、习惯打卡⭐数据可视化个人开支分析、健身数据追踪⭐⭐自动化脚本文件批量重命名、数据格式转换⭐⭐给家人的工具老人用的大字时钟、简单相册⭐\n新手建议：选择「待办清单」跟着教程走完第一遍，然后再做自己的项目。\n\n### 作业二：完成项目 PRD ​\n\n用本章学到的方法，为你选择的项目完成 PRD。\n\nPRD 模板：\nmarkdown\n`# [项目名称] PRD\n\n## 1. 项目背景\n### 问题来源\n[描述你发现的问题]\n\n### JTBD 任务描述\n当我 [场景] 时，我想 [任务]，这样我就能 [价值]。\n\n## 2. 目标用户\n- 身份：\n- 场景：\n- 核心需求：\n\n## 3. 功能范围\n### P0 功能（第一版必须有）\n1. \n2. \n3. \n\n### 不做清单\n- \n- \n- \n\n## 4. 技术约束\n- 技术栈：\n- 数据存储：\n- 其他：\n\n## 5. 成功标准\n[如何验证项目成功]`\n### 作业三：写出第一个 Prompt ​\n基于你的 PRD，用 S.C.A.F.F. 框架写出实现第一个 P0 功能的 Prompt。\n\n不需要真的发给 AI，写完保存好，第四章会用到。\n\n## 自我检查清单 ​\n\n在进入第四章之前，确认你能回答这些问题：\n\n### 关于第二章 ​\nmarkdown\n`□ 我能用一句话描述项目要解决的问题\n□ 我知道目标用户是谁\n□ 我明确了第一版要做什么、不做什么\n□ 灵魂三问我都能回答`\n### 关于第三章 ​\nmarkdown\n```\n□ 我知道好提示词包含哪些要素\n□ 我能选择合适的提示技巧（Zero-shot/Few-shot/CoT）\n□ 我知道 AI 输出不满意时如何给反馈\n□ 我知道如何验证 AI 推荐的包和 API\n```\n如果有的问题答不上来，建议回顾对应章节再继续。\n\n## 写在最后 ​\n\n恭喜你完成了第二章和第三章的学习！\n\n这两章是 Vibe Coding 的核心基础。很多人急于动手，跳过思考和表达的训练，结果在开发时反复踩坑、不断返工。\n\n你选择了更扎实的路径：先想清楚，再说明白，最后才动手。\n\n这条路看似慢，实际上最快。\n\n下一章，你将看到这些积累如何转化为实实在在的成果——你的第一个 AI 编程作品。\n\n记住\n\nVibe Coding 的核心不是「让 AI 写代码」，而是「把你想要的说清楚」。\n\n你已经学会了怎么说。现在，让我们开始做。\n\n准备好了吗？\n\n👉 第四章：实战 —— 从 0 到 1 开发个人工具",
      "word_count": 2977,
      "estimated_time": 5
    },
    {
      "id": "lesson-104",
      "chapter_id": "chapter-03",
      "lesson_number": 35,
      "title": "A.1 项目创建类模板",
      "content": "# A.1 项目创建类模板 ​\n\n本节提供从零开始创建项目的 Prompt 模板，覆盖网页应用、数据分析、自动化脚本等常见场景。\n\n## 模板一：网页应用从零搭建 ​\n\n适用于：个人工具、产品原型、小型网站\nmarkdown\n`## 项目背景\n\n我想创建一个 [项目类型]。\n\n**目标用户**：[谁会使用这个应用]\n**核心需求**：[用一句话描述这个应用要解决什么问题]\n\n## 技术要求\n\n**技术栈偏好**：\n- 前端：[React/Vue/纯 HTML+CSS+JS/不限]\n- 样式：[Tailwind CSS/原生 CSS/不限]\n- 是否需要后端：[是/否]\n- 数据存储：[localStorage/无需存储/需要数据库]\n\n**我的技术水平**：[零基础/有一点基础/熟悉前端开发]\n\n## 功能需求\n\n**必须实现（P0）**：\n- [ ] [功能1]\n- [ ] [功能2]\n- [ ] [功能3]\n\n**暂不需要**：\n- [功能A]（原因：[为什么不需要]）\n- [功能B]（原因：[为什么不需要]）\n\n## 界面要求\n\n**风格**：[简洁/现代/可爱/专业/参考某网站]\n**配色**：[主色调偏好，如\"蓝白配色\"/\"暗色主题\"]\n**响应式**：[需要适配手机/只需桌面端]\n\n## 输出要求\n\n请提供：\n1. 项目的文件结构说明\n2. 完整的代码文件\n3. 如何在本地运行的说明`\n### 填写示例：个人记账本 ​\nmarkdown\n```\n## 项目背景\n\n我想创建一个极简记账网页应用。\n\n**目标用户**：我自己（想养成记账习惯但嫌其他 App 太复杂）\n**核心需求**：快速记录每笔支出，月底能看到总花费\n\n## 技术要求\n\n**技术栈偏好**：\n- 前端：纯 HTML+CSS+JS（我是初学者，想从简单的开始）\n- 样式：原生 CSS\n- 是否需要后端：否\n- 数据存储：localStorage\n\n**我的技术水平**：零基础，刚学完 Hello World\n\n## 功能需求\n\n**必须实现（P0）**：\n- [ ] 记录支出：金额 + 简单备注\n- [ ] 显示今日支出列表\n- [ ] 显示本月总支出\n- [ ] 删除错误记录\n\n**暂不需要**：\n- 收入记录（原因：我只想管支出）\n- 分类统计（原因：先跑起来，以后再加）\n- 图表可视化（原因：数字足够，不需要花哨）\n\n## 界面要求\n\n**风格**：极简，类似 iOS 备忘录的干净感\n**配色**：白色背景，深灰文字，绿色强调色\n**响应式**：需要适配手机（我主要在手机上用）\n\n## 输出要求\n\n请提供：\n1. 项目的文件结构说明\n2. 完整的代码文件\n3. 如何在本地运行的说明\n```\n\n## 模板二：数据分析项目 ​\n适用于：Excel 数据处理、销售分析、问卷统计、可视化报告\nmarkdown\n`## 分析背景\n\n我需要分析一份 [数据类型] 数据。\n\n**数据来源**：[Excel/CSV/数据库/API]\n**数据规模**：约 [行数] 行，[列数] 列\n**分析目的**：[回答什么业务问题/支持什么决策]\n\n## 数据描述\n\n**主要字段**：\n| 字段名 | 含义 | 数据类型 | 示例值 |\n|-------|------|---------|-------|\n| [字段1] | [说明] | [文本/数字/日期] | [示例] |\n| [字段2] | [说明] | [文本/数字/日期] | [示例] |\n\n**数据质量问题**（如有）：\n- [问题1，如\"部分日期格式不统一\"]\n- [问题2，如\"有些行缺少金额数据\"]\n\n## 分析需求\n\n**想要回答的问题**：\n1. [问题1]\n2. [问题2]\n3. [问题3]\n\n**输出形式**：\n- [ ] 数据清洗后的表格\n- [ ] 统计数字（如总和、平均值、占比）\n- [ ] 可视化图表（柱状图/折线图/饼图）\n- [ ] 分析结论文字说明\n\n## 技术要求\n\n**使用工具**：[Python + Pandas / Excel 公式 / SQL]\n**运行环境**：[本地 Python / Jupyter Notebook / Google Colab]\n**我的水平**：[零基础/会基本 Python/熟悉数据分析]\n\n## 输出要求\n\n请提供：\n1. 完整的代码（带注释说明每一步在做什么）\n2. 代码运行后预期看到的结果示例\n3. 如何修改代码以适应我的实际数据`\n### 填写示例：销售数据月度分析 ​\nmarkdown\n```\n## 分析背景\n\n我需要分析一份电商销售数据。\n\n**数据来源**：Excel 文件（从后台导出）\n**数据规模**：约 5000 行，8 列\n**分析目的**：了解本月销售情况，找出畅销商品和问题商品\n\n## 数据描述\n\n**主要字段**：\n| 字段名 | 含义 | 数据类型 | 示例值 |\n|-------|------|---------|-------|\n| 订单号 | 唯一标识 | 文本 | ORD20241201001 |\n| 商品名 | 商品名称 | 文本 | 无线蓝牙耳机 |\n| 分类 | 商品类别 | 文本 | 数码配件 |\n| 金额 | 订单金额 | 数字 | 299 |\n| 下单时间 | 订单时间 | 日期 | 2024-12-01 14:30 |\n\n**数据质量问题**：\n- 部分订单金额为 0（可能是退款订单）\n- 下单时间格式有两种：有的带时分，有的只有日期\n\n## 分析需求\n\n**想要回答的问题**：\n1. 本月总销售额是多少？日均销售额？\n2. 哪个商品类别卖得最好？占比多少？\n3. 哪些商品是 Top 10 畅销品？\n4. 销售额的日趋势是什么样的？\n\n**输出形式**：\n- [x] 统计数字（总额、日均、类别占比）\n- [x] 可视化图表（类别饼图、日趋势折线图、Top10 柱状图）\n- [x] 分析结论文字说明\n\n## 技术要求\n\n**使用工具**：Python + Pandas + Matplotlib\n**运行环境**：本地 Jupyter Notebook\n**我的水平**：会基本 Python，Pandas 用得不熟\n\n## 输出要求\n\n请提供：\n1. 完整的代码（带注释说明每一步在做什么）\n2. 代码运行后预期看到的结果示例\n3. 如何修改代码以适应我的实际数据\n```\n\n## 模板三：自动化脚本 ​\n适用于：文件批量处理、Excel 汇总、定时任务、数据抓取\nmarkdown\n`## 自动化需求\n\n我想自动完成 [任务描述]。\n\n**目前的痛点**：\n[描述现在手动做这件事有多麻烦]\n\n**期望效果**：\n[运行脚本后，应该发生什么]\n\n## 输入输出\n\n**输入**：\n- 来源：[文件夹/单个文件/网页/...]\n- 格式：[Excel/CSV/TXT/图片/...]\n- 位置：[具体路径或描述]\n- 示例：[举一个具体例子]\n\n**输出**：\n- 格式：[Excel/CSV/新文件/...]\n- 位置：[保存到哪里]\n- 命名规则：[如\"原文件名_processed.xlsx\"]\n\n## 处理逻辑\n\n请按以下步骤处理：\n1. [第一步：做什么]\n2. [第二步：做什么]\n3. [第三步：做什么]\n\n**特殊情况处理**：\n- 如果遇到 [情况A]，则 [处理方式]\n- 如果遇到 [情况B]，则 [处理方式]\n\n## 技术要求\n\n**语言**：[Python/批处理脚本/PowerShell]\n**运行环境**：[Windows/Mac/Linux]\n**依赖限制**：[尽量少用第三方库/可以用常见库]\n**我的水平**：[会运行脚本即可/想学习理解代码]\n\n## 输出要求\n\n请提供：\n1. 完整可运行的脚本代码\n2. 需要安装的依赖（如 pip install xxx）\n3. 使用说明（如何运行、如何修改参数）\n4. 常见问题及解决方法`\n### 填写示例：批量重命名图片 ​\nmarkdown\n```\n## 自动化需求\n\n我想自动批量重命名文件夹中的图片。\n\n**目前的痛点**：\n从相机导出的照片命名是 IMG_0001.jpg 这种格式，很难找到特定日期的照片。\n手动重命名几百张图片太费时间。\n\n**期望效果**：\n运行脚本后，所有图片按拍摄日期重命名为 2024-12-01_001.jpg 格式\n\n## 输入输出\n\n**输入**：\n- 来源：指定文件夹\n- 格式：jpg、png 图片\n- 位置：用户指定（运行时输入）\n- 示例：IMG_0001.jpg、IMG_0002.jpg...\n\n**输出**：\n- 格式：原图片（只改名，不改内容）\n- 位置：原地重命名\n- 命名规则：拍摄日期_序号.扩展名（如 2024-12-01_001.jpg）\n\n## 处理逻辑\n\n请按以下步骤处理：\n1. 读取文件夹中所有图片\n2. 从图片 EXIF 信息中提取拍摄日期\n3. 按日期排序，同一天的图片按时间顺序编号\n4. 重命名文件\n\n**特殊情况处理**：\n- 如果图片没有 EXIF 信息，使用文件修改时间\n- 如果目标文件名已存在，添加 _dup 后缀\n\n## 技术要求\n\n**语言**：Python\n**运行环境**：Windows 11\n**依赖限制**：可以用 Pillow 库读取 EXIF\n**我的水平**：会运行脚本即可，代码不需要太详细的注释\n\n## 输出要求\n\n请提供：\n1. 完整可运行的脚本代码\n2. 需要安装的依赖\n3. 使用说明（如何运行）\n```\n\n## 模板四：CLI 命令行工具（精简版） ​\n适用于：开发者工具、效率脚本、系统管理\nmarkdown\n`## 工具需求\n\n我想创建一个命令行工具，用于 [用途]。\n\n**使用方式示例**：\n```bash\n[命令名] [参数示例]\n# 例如：mytool --input data.csv --output result.json`主要功能：\n\n- [功能1]\n- [功能2]\n参数说明：\n参数必填说明默认值[参数1]是/否[说明][默认值]\n技术栈：[Python argparse / Node.js commander / Go cobra]\n\n请提供完整代码和使用示例。\n\n```\n\n## 常见填写误区\n\n| 误区 | 问题 | 正确做法 |\n|-----|------|---------|\n| 不写技术水平 | AI 给的代码太复杂或太简单 | 明确说明自己的水平 |\n| 功能需求太模糊 | \"做一个好用的工具\" | 列出具体的功能点 |\n| 忘记写\"不需要\" | AI 自作主张加了很多功能 | 明确边界，写清不做什么 |\n| 数据描述不清 | AI 无法写出正确的处理逻辑 | 给出字段说明和示例数据 |\n\n## 本节要点\n\n- ✅ **网页应用模板**：技术栈 + 功能需求 + 界面要求 + 输出格式\n- ✅ **数据分析模板**：数据描述 + 分析问题 + 输出形式\n- ✅ **自动化脚本模板**：输入输出 + 处理逻辑 + 异常处理\n- ✅ **关键技巧**：说明技术水平，AI 会调整代码复杂度\n```",
      "word_count": 4689,
      "estimated_time": 9
    },
    {
      "id": "lesson-105",
      "chapter_id": "chapter-03",
      "lesson_number": 36,
      "title": "A.2 代码修改类模板",
      "content": "# A.2 代码修改类模板 ​\n\n本节提供修改现有代码的 Prompt 模板，包括功能扩展、代码重构、性能优化和样式调整。\n\n## 模板一：功能扩展 ​\n\n适用于：在现有代码基础上添加新功能\nmarkdown\n`## 当前状态\n\n**项目背景**：[简述项目是做什么的]\n**技术栈**：[使用的技术]\n**要扩展的模块**：[哪个文件/组件]\n\n## 现有代码\n\n```[语言]\n[粘贴现有代码]`\n## 扩展需求 ​\n新增功能：[描述要添加什么功能]\n\n功能细节：\n\n- [细节1]\n- [细节2]\n- [细节3]\n触发方式：[用户如何触发这个功能] 预期结果：[功能执行后应该发生什么]\n\n## 约束条件 ​\n\n必须保持：\n\n- [现有功能A 不能受影响]\n- [现有功能B 要继续正常工作]\n不要改动：\n\n- [不要修改的部分1]\n- [不要修改的部分2]\n## 输出要求 ​\n\n- [ ] 只输出修改后的代码，不需要重复未修改的部分\n- [ ] 用注释标注新增的代码\n- [ ] 说明需要额外安装的依赖（如有）\n`\n### 填写示例：待办清单添加\"撤销删除\"功能\n\n```markdown\n## 当前状态\n\n**项目背景**：个人待办清单网页应用\n**技术栈**：React + TypeScript + Tailwind CSS\n**要扩展的模块**：TaskList.tsx 组件\n\n## 现有代码\n\n```tsx\nfunction TaskList({ tasks, onDelete }) {\n  return (\n    <ul>\n      {tasks.map(task => (\n        <li key={task.id}>\n          {task.content}\n          <button onClick={() => onDelete(task.id)}>删除</button>\n        </li>\n      ))}\n    </ul>\n  );\n}`\n## 扩展需求 ​\n新增功能：删除任务后显示\"撤销\"提示，3 秒内可恢复\n\n功能细节：\n\n- 删除任务后，底部显示\"已删除，点击撤销\"提示\n- 提示显示 3 秒后自动消失\n- 点击\"撤销\"按钮，任务恢复到原位置\n- 同时只能有一个撤销提示\n触发方式：用户点击删除按钮 预期结果：任务从列表消失，底部出现撤销提示\n\n## 约束条件 ​\n\n必须保持：\n\n- 现有的任务展示逻辑不变\n- 删除按钮的位置和样式不变\n不要改动：\n\n- 不要改变 props 的类型定义\n- 不要引入新的状态管理库\n## 输出要求 ​\n\n- [x] 只输出修改后的代码\n- [x] 用注释标注新增的代码\n- [ ] 说明需要额外安装的依赖\n`\n\n## 模板二：代码重构\n\n适用于：改进代码质量、提高可读性、统一代码风格\n\n```markdown\n## 重构目标\n\n**当前问题**：[代码现在有什么问题]\n**期望改进**：[重构后希望达到什么效果]\n\n## 待重构代码\n\n```[语言]\n[粘贴需要重构的代码]`\n## 重构要求 ​\n方向：[可多选]\n\n- [ ] 提高可读性（变量命名、函数拆分）\n- [ ] 减少重复代码（提取公共函数）\n- [ ] 统一代码风格\n- [ ] 添加类型定义（TypeScript）\n- [ ] 改进错误处理\n- [ ] 其他：[具体说明]\n必须保持：\n\n- 功能行为完全不变\n- [其他约束]\n参考规范（可选）： [如果有特定的代码规范，可以贴在这里]\n\n## 输出要求 ​\n\n请提供：\n\n- 重构后的完整代码\n- 简要说明做了哪些改动\n- 改动的理由\n`\n### 填写示例：重构重复的表单验证代码\n\n```markdown\n## 重构目标\n\n**当前问题**：注册、登录、修改密码三个表单都有类似的验证代码，复制粘贴了三遍\n**期望改进**：提取公共的验证函数，减少重复\n\n## 待重构代码\n\n```typescript\n// 注册表单\nfunction validateRegister(data) {\n  if (!data.email || !data.email.includes('@')) {\n    return '邮箱格式不正确';\n  }\n  if (!data.password || data.password.length < 8) {\n    return '密码至少8位';\n  }\n  if (data.password !== data.confirmPassword) {\n    return '两次密码不一致';\n  }\n  return null;\n}\n\n// 登录表单\nfunction validateLogin(data) {\n  if (!data.email || !data.email.includes('@')) {\n    return '邮箱格式不正确';\n  }\n  if (!data.password || data.password.length < 8) {\n    return '密码至少8位';\n  }\n  return null;\n}\n\n// 修改密码表单\nfunction validateChangePassword(data) {\n  if (!data.oldPassword || data.oldPassword.length < 8) {\n    return '旧密码至少8位';\n  }\n  if (!data.newPassword || data.newPassword.length < 8) {\n    return '新密码至少8位';\n  }\n  if (data.newPassword !== data.confirmPassword) {\n    return '两次密码不一致';\n  }\n  return null;\n}`\n## 重构要求 ​\n方向：\n\n- [x] 减少重复代码（提取公共函数）\n- [x] 添加类型定义（TypeScript）\n- [x] 改进错误处理（支持返回多个错误）\n必须保持：\n\n- 功能行为完全不变\n- 错误信息文案保持一致\n## 输出要求 ​\n\n请提供：\n\n- 重构后的完整代码\n- 简要说明做了哪些改动\n- 如何在原有表单中使用新的验证函数\n`\n\n## 模板三：性能优化\n\n适用于：页面加载慢、操作卡顿、内存占用高\n\n```markdown\n## 性能问题描述\n\n**问题现象**：[具体描述慢在哪里、卡在哪里]\n**触发条件**：[什么情况下会出现这个问题]\n**影响程度**：[大概延迟多久、卡顿多久]\n\n## 相关代码\n\n```[语言]\n[粘贴可能导致性能问题的代码]`\n## 优化目标 ​\n期望效果：[优化后应该达到什么程度] 度量标准：[如何判断优化成功]\n\n## 已知信息 ​\n\n数据规模：[处理的数据量大概多少] 运行环境：[浏览器/Node.js/移动端] 已尝试的优化：[如果有的话]\n\n## 约束条件 ​\n\n- 功能逻辑不能改变\n- [其他约束]\n## 输出要求 ​\n\n请提供：\n\n- 优化后的代码\n- 解释性能问题的原因\n- 优化的原理和效果预估\n`\n\n## 模板四：样式调整\n\n适用于：UI 美化、布局修改、响应式适配\n\n```markdown\n## 当前样式\n\n**问题描述**：[当前界面哪里不满意]\n\n**当前代码**：\n```[css/html]\n[粘贴当前样式相关代码]`\n## 期望效果 ​\n描述：[用文字描述想要的效果]\n\n参考（可选）：\n\n- 参考网站：[URL]\n- 参考图片：[描述或链接]\n- 关键词：[简洁/现代/圆角/阴影/渐变/...]\n## 具体要求 ​\n\n布局调整：\n\n- [调整1]\n- [调整2]\n视觉效果：\n\n- [效果1]\n- [效果2]\n响应式：\n\n- 桌面端（>1024px）：[要求]\n- 平板端（768-1024px）：[要求]\n- 手机端（<768px）：[要求]\n## 技术约束 ​\n\n使用技术：[Tailwind CSS/原生 CSS/其他] 必须兼容：[浏览器版本要求]\n\n## 输出要求 ​\n\n请提供修改后的样式代码，并标注改动的部分。\n\n`\n\n## 模板五：代码迁移（精简版）\n\n适用于：升级框架版本、更换技术栈\n\n```markdown\n## 迁移需求\n\n**原技术**：[如 React Class 组件]\n**目标技术**：[如 React Hooks 函数组件]\n\n## 原代码\n\n```[语言]\n[粘贴需要迁移的代码]`\n## 迁移要求 ​\n\n- 保持功能完全一致\n- 遵循目标技术的最佳实践\n- [其他要求]\n## 输出要求 ​\n请提供迁移后的代码，并说明主要改动点。\n\n`\n\n## 精简版：快速修改模板\n\n当你只需要做一个小改动时，可以使用这个精简版：\n\n```markdown\n请修改以下代码：\n\n```[语言]\n[代码]`修改内容：[简述要改什么]\n\n约束：\n\n- 保持其他部分不变\n- [其他约束]\n```\n\n## 常见填写误区\n\n| 误区 | 问题 | 正确做法 |\n|-----|------|---------|\n| 不贴现有代码 | AI 无法了解上下文 | 贴出相关的代码片段 |\n| 只说\"优化一下\" | 不知道优化什么方向 | 明确是可读性/性能/结构 |\n| 忘记说\"不要改\" | AI 可能重构整个文件 | 明确边界，哪些不动 |\n| 参考描述太抽象 | \"好看一点\"太模糊 | 给参考网站或具体描述 |\n\n## 本节要点\n\n- ✅ **功能扩展**：贴出现有代码 + 描述新功能 + 明确不能动的部分\n- ✅ **代码重构**：明确重构方向 + 保证功能不变\n- ✅ **性能优化**：描述问题现象 + 给出数据规模 + 设定度量标准\n- ✅ **样式调整**：提供参考 + 具体描述期望效果\n```",
      "word_count": 4154,
      "estimated_time": 8
    },
    {
      "id": "lesson-106",
      "chapter_id": "chapter-03",
      "lesson_number": 37,
      "title": "A.3 问题解决类模板",
      "content": "# A.3 问题解决类模板 ​\n\n本节提供排查问题和寻求帮助的 Prompt 模板，覆盖错误排查、技术选型、概念解释等场景。\n\n## 模板一：运行时错误排查 ​\n\n适用于：代码报错、程序崩溃、控制台报红\nmarkdown\n`## 错误信息\n\n运行时遇到以下错误：`[完整粘贴错误信息，包括堆栈跟踪]\n\n`\n## 触发场景\n\n**操作步骤**：\n1. [第一步做了什么]\n2. [第二步做了什么]\n3. [然后就报错了]\n\n**触发频率**：[每次都报错/偶尔报错/特定条件下报错]\n\n## 相关代码\n\n错误指向的代码：\n```[语言]\n[粘贴错误信息中提到的代码，以及上下文]`\n## 环境信息 ​\n\n- 运行环境：[浏览器版本/Node.js 版本/Python 版本]\n- 框架版本：[React 18/Vue 3/...]\n- 操作系统：[Windows/Mac/Linux]\n## 已尝试的方法 ​\n\n- [尝试1]：结果 [成功/失败/部分解决]\n- [尝试2]：结果 [成功/失败/部分解决]\n## 请帮我 ​\n\n- 分析错误的根本原因\n- 给出修复方案\n- 解释为什么会出现这个问题（帮助我理解）\n```\n\n### 填写示例\n\n```markdown\n## 错误信息\n\n运行时遇到以下错误：\n```\nTypeError: Cannot read properties of undefined (reading 'map') at TaskList (TaskList.tsx:15:23) at renderWithHooks (react-dom.development.js:14985:18) at mountIndeterminateComponent (react-dom.development.js:17811:13)\n\n`\n## 触发场景\n\n**操作步骤**：\n1. 打开应用首页\n2. 页面加载时直接报错\n3. 任务列表没有显示出来\n\n**触发频率**：每次刷新页面都报错\n\n## 相关代码\n\n错误指向的代码：\n```tsx\n// TaskList.tsx\nfunction TaskList({ tasks }) {\n  return (\n    <ul>\n      {tasks.map(task => (          // 第 15 行\n        <li key={task.id}>{task.title}</li>\n      ))}\n    </ul>\n  );\n}\n\n// App.tsx 中的调用\nfunction App() {\n  const [tasks, setTasks] = useState();  // 注意这里\n  \n  return <TaskList tasks={tasks} />;\n}`\n## 环境信息 ​\n\n- 运行环境：Chrome 120\n- 框架版本：React 18.2.0 + TypeScript 5.0\n- 操作系统：Mac\n## 已尝试的方法 ​\n\n- 检查 tasks 数据：console.log 发现是 undefined\n- 刷新页面：问题依旧\n## 请帮我 ​\n\n- 分析错误的根本原因\n- 给出修复方案\n- 解释为什么会出现这个问题\n```\n\n## 模板二：逻辑错误分析\n\n适用于：代码能跑但结果不对\n\n```markdown\n## 问题描述\n\n代码可以运行，但结果不符合预期。\n\n**期望行为**：[应该是什么结果]\n**实际行为**：[实际得到什么结果]\n\n## 测试用例\n\n| 输入 | 期望输出 | 实际输出 | 是否正确 |\n|-----|---------|---------|---------|\n| [输入1] | [期望1] | [实际1] | ❌ |\n| [输入2] | [期望2] | [实际2] | ❌ |\n| [输入3] | [期望3] | [实际3] | ✅ |\n\n## 相关代码\n\n```[语言]\n[粘贴相关代码]\n```\n\n## 我的分析 ​\n我怀疑问题可能出在：[你的猜测]\n\n## 请帮我 ​\n\n- 找出逻辑错误所在\n- 解释为什么当前逻辑会产生错误结果\n- 给出修复后的代码\n`\n### 填写示例\n\n```markdown\n## 问题描述\n\n代码可以运行，但结果不符合预期。\n\n**期望行为**：计算购物车总价时，满 100 减 20\n**实际行为**：无论金额多少，都减了 20\n\n## 测试用例\n\n| 输入（商品总价） | 期望输出 | 实际输出 | 是否正确 |\n|---------------|---------|---------|---------|\n| 150 | 130 | 130 | ✅ |\n| 80 | 80 | 60 | ❌ |\n| 100 | 80 | 80 | ✅ |\n\n## 相关代码\n\n```javascript\nfunction calculateTotal(items) {\n  let total = items.reduce((sum, item) => sum + item.price, 0);\n  \n  // 满 100 减 20\n  if (total > 100) {\n    total = total - 20;\n  } else {\n    total = total - 20;  // 问题可能在这里？\n  }\n  \n  return total;\n}`\n## 我的分析 ​\n我怀疑问题可能出在：else 分支也减了 20，应该是复制粘贴时忘记删掉\n\n## 请帮我 ​\n\n- 确认我的分析是否正确\n- 给出修复后的代码\n- 建议如何避免这类复制粘贴错误\n`\n\n## 模板三：技术选型咨询\n\n适用于：不知道选什么库、框架、工具\n\n```markdown\n## 项目背景\n\n**项目类型**：[简述项目是做什么的]\n**技术栈**：[当前使用的技术]\n**团队情况**：[个人项目/团队规模/技术水平]\n\n## 选型需求\n\n我需要选择一个 [类型] 来实现 [功能]。\n\n**核心需求**：\n- [需求1]\n- [需求2]\n- [需求3]\n\n**考虑因素**：\n| 因素 | 重要程度 | 说明 |\n|-----|---------|------|\n| 学习成本 | 高/中/低 | [说明] |\n| 社区活跃度 | 高/中/低 | [说明] |\n| 性能 | 高/中/低 | [说明] |\n| 包体积 | 高/中/低 | [说明] |\n| 长期维护 | 高/中/低 | [说明] |\n\n## 已知候选（可选）\n\n我目前了解到的选项有：\n1. [选项A]：[简单印象]\n2. [选项B]：[简单印象]\n3. [选项C]：[简单印象]\n\n## 请帮我\n\n1. 补充我可能遗漏的候选方案\n2. 从多个维度对比各方案的优缺点\n3. 给出推荐方案及理由\n4. 说明什么情况下应该选择其他方案`\n### 填写示例 ​\nmarkdown\n```\n## 项目背景\n\n**项目类型**：个人博客网站\n**技术栈**：Next.js + TypeScript\n**团队情况**：个人项目，前端熟练，后端初学\n\n## 选型需求\n\n我需要选择一个数据库方案来存储博客文章。\n\n**核心需求**：\n- 存储文章内容（Markdown 格式）\n- 支持分类和标签\n- 能按时间排序查询\n\n**考虑因素**：\n| 因素 | 重要程度 | 说明 |\n|-----|---------|------|\n| 学习成本 | 高 | 后端不熟，希望上手简单 |\n| 免费额度 | 高 | 个人项目，不想花钱 |\n| 与 Next.js 集成 | 中 | 希望有现成教程 |\n| 性能 | 低 | 博客访问量不大 |\n\n## 已知候选\n\n我目前了解到的选项有：\n1. Supabase：听说是 Firebase 替代品\n2. MongoDB Atlas：NoSQL 数据库\n3. PlanetScale：MySQL 云服务\n\n## 请帮我\n\n1. 补充我可能遗漏的候选方案\n2. 从多个维度对比各方案的优缺点\n3. 给出推荐方案及理由\n4. 说明什么情况下应该选择其他方案\n```\n\n## 模板四：概念解释 ​\n适用于：不理解某个技术概念\nmarkdown\n`## 想了解的概念\n\n我想理解 [概念名称]。\n\n## 当前困惑\n\n**我目前的理解**：[你现在认为它是什么]\n**困惑的地方**：[哪里不理解]\n\n## 希望的解释方式\n\n**技术深度**：[只要知道怎么用/想了解原理/需要深入细节]\n**类比偏好**：[喜欢生活化类比/喜欢技术类比/直接解释就好]\n\n## 相关背景\n\n**我的技术背景**：[熟悉什么技术/语言]\n**为什么要了解这个**：[应用场景]\n\n## 请帮我\n\n1. 用通俗的语言解释这个概念\n2. 给出一个简单的代码示例\n3. 说明什么时候会用到它\n4. 指出常见的理解误区`\n### 填写示例 ​\nmarkdown\n```\n## 想了解的概念\n\n我想理解 React 中的 useEffect。\n\n## 当前困惑\n\n**我目前的理解**：好像是用来处理\"副作用\"的，但不知道什么算副作用\n**困惑的地方**：\n- 什么时候需要用 useEffect？\n- 依赖数组是干什么的？\n- 为什么有时候会\"无限循环\"？\n\n## 希望的解释方式\n\n**技术深度**：只要知道怎么用就行，原理以后再说\n**类比偏好**：喜欢生活化类比\n\n## 相关背景\n\n**我的技术背景**：会基础 JavaScript，正在学 React\n**为什么要了解这个**：想在组件加载时获取数据\n\n## 请帮我\n\n1. 用通俗的语言解释 useEffect\n2. 给出\"获取数据\"的代码示例\n3. 说明依赖数组的作用\n4. 解释为什么会\"无限循环\"以及如何避免\n```\n\n## 模板五：代码审查 ​\n适用于：让 AI 检查代码质量\nmarkdown\n`## 审查目标\n\n请帮我审查以下代码：\n\n```[语言]\n[粘贴代码]`\n## 审查维度 ​\n请从以下维度检查：\n\n- [ ] 功能正确性：逻辑是否正确，边界情况是否处理\n- [ ] 安全性：是否有安全隐患（XSS、SQL注入等）\n- [ ] 性能：是否有明显的性能问题\n- [ ] 可读性：命名是否清晰，结构是否合理\n- [ ] 可维护性：是否容易扩展和修改\n- [ ] 错误处理：异常情况是否妥善处理\n## 代码背景 ​\n\n这段代码的作用：[简述功能] 使用场景：[在什么情况下运行]\n\n## 输出格式 ​\n\n请按以下格式输出：\n\n- 问题清单：列出发现的问题，按严重程度排序\n- 改进建议：针对每个问题给出具体建议\n- 优化后代码：给出改进后的完整代码\n`\n\n## 精简版：快速提问模板\n\n当问题比较简单时，可以用这个精简版：\n\n```markdown\n**问题**：[一句话描述问题]\n\n**背景**：[必要的上下文]\n\n**代码**：\n```[语言]\n[相关代码]`期望：[你希望得到什么帮助]\n\n`\n\n## 提问技巧：如何让回答更有用\n\n### 技巧一：先说结论，再给细节\n\n```markdown\n❌ 我有一个 React 项目，用的是 TypeScript，然后我在做一个表单验证...\n   （AI 读了半天还不知道问题是什么）\n\n✅ 我的表单验证代码报错了。\n   技术栈是 React + TypeScript，错误信息是 [xxx]。`\n### 技巧二：给出最小复现代码 ​\n不要贴整个文件，只贴能复现问题的最小代码。这样 AI 更容易定位问题。\n\n### 技巧三：说明已经尝试过什么 ​\n\n这能帮助 AI 避免给出你已经试过的无效方案。\n\n## 常见填写误区 ​\n误区问题正确做法只说\"不工作\"AI 不知道具体症状描述期望 vs 实际的差异错误信息只截一半丢失关键信息完整粘贴，包括堆栈跟踪不给代码AI 只能猜测贴出相关代码片段概念问题太宽泛\"解释一下 JavaScript\"具体到某个点，如\"解释闭包\"\n## 本节要点 ​\n\n- ✅ 错误排查：完整错误信息 + 触发步骤 + 相关代码 + 已尝试方法\n- ✅ 逻辑错误：用测试用例展示\"期望 vs 实际\"\n- ✅ 技术选型：明确需求优先级 + 列出考虑因素\n- ✅ 概念解释：说明当前理解和困惑点 + 期望的解释深度",
      "word_count": 5163,
      "estimated_time": 10
    },
    {
      "id": "lesson-107",
      "chapter_id": "chapter-03",
      "lesson_number": 38,
      "title": "A.4 文档生成类模板",
      "content": "# A.4 文档生成类模板 ​\n\n本节提供生成各类文档的 Prompt 模板，包括代码注释、README、API 文档和使用说明。\n\n## 模板一：代码注释生成 ​\n\n适用于：为现有代码添加注释\nmarkdown\n`## 注释需求\n\n请为以下代码添加中文注释：\n\n```[语言]\n[粘贴代码]`\n## 注释要求 ​\n注释类型：\n\n- [ ] 文件头注释（说明文件用途）\n- [ ] 函数注释（说明参数、返回值、功能）\n- [ ] 关键逻辑注释（解释复杂逻辑）\n- [ ] TODO 注释（标记待完善的地方）\n注释风格：\n\n- 语言：中文\n- 格式：[JSDoc 风格 / 普通注释 / 你的规范]\n- 详细程度：[简洁/适中/详尽]\n特别说明：\n\n- [其他要求，如\"不需要给简单的变量加注释\"]\n## 输出要求 ​\n\n请输出添加注释后的完整代码，保持原有代码逻辑不变。\n\n`\n### 填写示例\n\n```markdown\n## 注释需求\n\n请为以下代码添加中文注释：\n\n```typescript\ninterface Task {\n  id: string;\n  title: string;\n  completed: boolean;\n  createdAt: Date;\n}\n\nfunction useTasks() {\n  const [tasks, setTasks] = useState<Task[]>([]);\n  \n  const addTask = useCallback((title: string) => {\n    const newTask: Task = {\n      id: crypto.randomUUID(),\n      title,\n      completed: false,\n      createdAt: new Date(),\n    };\n    setTasks(prev => [...prev, newTask]);\n  }, []);\n  \n  const toggleTask = useCallback((id: string) => {\n    setTasks(prev => \n      prev.map(task => \n        task.id === id ? { ...task, completed: !task.completed } : task\n      )\n    );\n  }, []);\n  \n  return { tasks, addTask, toggleTask };\n}`\n## 注释要求 ​\n注释类型：\n\n- [x] 文件头注释\n- [x] 函数注释（JSDoc 格式）\n- [x] 关键逻辑注释\n注释风格：\n\n- 语言：中文\n- 格式：JSDoc 风格\n- 详细程度：适中\n特别说明：\n\n- interface 的每个字段需要注释\n- useCallback 需要解释为什么用它\n## 输出要求 ​\n\n请输出添加注释后的完整代码。\n\n`\n\n## 模板二：README 生成\n\n适用于：为项目生成说明文档\n\n```markdown\n## 项目信息\n\n**项目名称**：[名称]\n**一句话描述**：[简述项目做什么]\n\n**技术栈**：\n- 前端：[技术]\n- 后端：[技术，如无则写\"无\"]\n- 数据库：[技术，如无则写\"无\"]\n\n**目标用户**：[谁会用这个项目]\n\n## 项目功能\n\n**核心功能**：\n1. [功能1]\n2. [功能2]\n3. [功能3]\n\n**功能截图**（可选）：\n[如果有截图，描述截图内容]\n\n## 技术细节\n\n**项目结构**：`[粘贴项目目录结构]\n\n`\n**环境要求**：\n- Node.js 版本：[版本]\n- 其他依赖：[列出]\n\n**安装步骤**：\n[如果你知道安装步骤，可以先写出来]\n\n## README 要求\n\n**包含内容**：\n- [ ] 项目简介\n- [ ] 功能特性\n- [ ] 快速开始（安装和运行）\n- [ ] 项目结构说明\n- [ ] 技术栈说明\n- [ ] 贡献指南\n- [ ] License\n\n**风格要求**：\n- 语言：中文\n- 风格：[简洁专业/友好亲切/技术范]\n\n## 输出要求\n\n请生成完整的 README.md 文件内容。`\n### 填写示例 ​\nmarkdown\n```\n## 项目信息\n\n**项目名称**：极简待办\n**一句话描述**：一个打开浏览器就能用的极简待办清单\n\n**技术栈**：\n- 前端：React + TypeScript + Tailwind CSS\n- 后端：无\n- 数据库：浏览器 localStorage\n\n**目标用户**：想要简单记录每日待办的个人用户\n\n## 项目功能\n\n**核心功能**：\n1. 添加待办任务\n2. 标记任务完成\n3. 删除任务\n4. 数据本地持久化\n\n## 技术细节\n\n**项目结构**：\n```\nsrc/ ├── components/ │ ├── AddTask.tsx │ ├── TaskList.tsx │ └── TaskItem.tsx ├── hooks/ │ └── useTasks.ts ├── types/ │ └── index.ts ├── App.tsx └── main.tsx\n\n`\n**环境要求**：\n- Node.js 版本：18+\n- 包管理器：npm 或 pnpm\n\n## README 要求\n\n**包含内容**：\n- [x] 项目简介\n- [x] 功能特性\n- [x] 快速开始\n- [x] 项目结构说明\n- [ ] 贡献指南（不需要）\n- [ ] License（不需要）\n\n**风格要求**：\n- 语言：中文\n- 风格：简洁专业\n\n## 输出要求\n\n请生成完整的 README.md 文件内容。`\n## 模板三：API 文档生成 ​\n适用于：为后端接口生成文档\nmarkdown\n`## API 基本信息\n\n**API 名称**：[接口名称]\n**请求路径**：[如 /api/users]\n**请求方法**：[GET/POST/PUT/DELETE]\n**功能描述**：[这个接口做什么]\n\n## 接口代码\n\n```[语言]\n[粘贴接口实现代码]`\n## 文档要求 ​\n文档格式：[Markdown / OpenAPI YAML / 其他]\n\n包含内容：\n\n- [ ] 接口描述\n- [ ] 请求参数说明\n- [ ] 请求体示例\n- [ ] 响应格式说明\n- [ ] 响应示例\n- [ ] 错误码说明\n- [ ] 调用示例（curl/JavaScript）\n## 输出要求 ​\n\n请生成完整的 API 文档。\n\n`\n### 填写示例\n\n```markdown\n## API 基本信息\n\n**API 名称**：创建任务\n**请求路径**：/api/tasks\n**请求方法**：POST\n**功能描述**：创建一个新的待办任务\n\n## 接口代码\n\n```typescript\n// POST /api/tasks\nexport async function POST(request: Request) {\n  const body = await request.json();\n  const { title, priority } = body;\n  \n  if (!title || title.trim() === '') {\n    return Response.json(\n      { error: 'Title is required' },\n      { status: 400 }\n    );\n  }\n  \n  const task = {\n    id: crypto.randomUUID(),\n    title: title.trim(),\n    priority: priority || 'medium',\n    completed: false,\n    createdAt: new Date().toISOString(),\n  };\n  \n  // 保存到数据库...\n  await db.tasks.create(task);\n  \n  return Response.json(task, { status: 201 });\n}`\n## 文档要求 ​\n文档格式：Markdown\n\n包含内容：\n\n- [x] 接口描述\n- [x] 请求参数说明\n- [x] 请求体示例\n- [x] 响应格式说明\n- [x] 响应示例\n- [x] 错误码说明\n- [x] 调用示例（curl）\n## 输出要求 ​\n\n请生成完整的 API 文档。\n\n`\n\n## 模板四：使用说明生成\n\n适用于：为非技术用户编写使用指南\n\n```markdown\n## 产品信息\n\n**产品名称**：[名称]\n**产品类型**：[网页/App/桌面软件/脚本]\n**目标用户**：[谁会用，技术水平如何]\n\n## 核心功能\n\n请为以下功能编写使用说明：\n\n1. **[功能1]**\n   - 功能描述：[做什么]\n   - 入口位置：[在哪里找到这个功能]\n   \n2. **[功能2]**\n   - 功能描述：[做什么]\n   - 入口位置：[在哪里找到这个功能]\n\n## 说明要求\n\n**语言风格**：\n- 语气：[正式/亲切/简洁]\n- 技术术语：[避免使用/简单解释后使用]\n\n**内容结构**：\n- [ ] 功能介绍\n- [ ] 操作步骤（分步骤说明）\n- [ ] 注意事项\n- [ ] 常见问题\n\n**配图说明**（可选）：\n[描述需要配什么图，或标注\"无需配图\"]\n\n## 输出要求\n\n请生成用户友好的使用说明文档。`\n## 模板五：学习笔记整理 ​\n适用于：整理技术学习内容\nmarkdown\n`## 学习主题\n\n我学习了 [主题]，请帮我整理笔记。\n\n## 学习内容\n\n以下是我学习过程中记录的零散笔记：`[粘贴你的学习笔记、代码片段、关键词等]\n\n`\n## 整理要求\n\n**笔记结构**：\n- [ ] 概念定义\n- [ ] 核心要点（3-5 条）\n- [ ] 代码示例\n- [ ] 使用场景\n- [ ] 常见误区\n- [ ] 相关概念链接\n\n**格式偏好**：\n- 使用 Markdown\n- 代码块带语法高亮\n- 重点用加粗标注\n\n## 输出要求\n\n请输出结构化的学习笔记，方便日后复习。`\n### 填写示例 ​\nmarkdown\n```\n## 学习主题\n\n我学习了 React Hooks 中的 useEffect，请帮我整理笔记。\n\n## 学习内容\n\n以下是我学习过程中记录的零散笔记：\n```\nuseEffect 副作用\n\n- 获取数据\n- 订阅事件\n- 修改 DOM\n依赖数组 [] 空数组 - 只在挂载时执行一次 不写 - 每次渲染都执行 [dep1, dep2] - 依赖变化时执行\n\n清理函数 return () => {} 组件卸载时调用 避免内存泄漏\n\n常见错误： 无限循环 - 依赖数组没写对 内存泄漏 - 忘记清理订阅\n\n`\n## 整理要求\n\n**笔记结构**：\n- [x] 概念定义\n- [x] 核心要点\n- [x] 代码示例\n- [x] 使用场景\n- [x] 常见误区\n\n**格式偏好**：\n- 使用 Markdown\n- 代码块带语法高亮\n- 重点用加粗标注\n\n## 输出要求\n\n请输出结构化的学习笔记。`\n## 精简版：快速生成文档 ​\n当需求简单时，可以用这个精简版：\nmarkdown\n`请为以下代码生成 [注释/文档/说明]：\n\n```[语言]\n[代码]`要求：\n\n- 语言：中文\n- 格式：[Markdown/JSDoc/其他]\n- [其他要求]\n```\n\n## 文档生成技巧\n\n### 技巧一：提供足够的上下文\n\nAI 需要理解代码的用途才能写出好的文档。简单说明这段代码\"是做什么的\"，能让文档更准确。\n\n### 技巧二：指定目标读者\n\n给开发者看的文档和给普通用户看的说明，写法完全不同。明确读者是谁。\n\n### 技巧三：给出格式示例\n\n如果你有特定的文档格式要求，给一个示例比文字描述更有效。\n\n## 常见填写误区\n\n| 误区 | 问题 | 正确做法 |\n|-----|------|---------|\n| 不说明用途 | AI 不理解代码做什么 | 简要说明功能和场景 |\n| 不指定格式 | 输出格式随机 | 明确要 Markdown/JSDoc 等 |\n| 不指定语言 | 可能输出英文 | 明确要求中文 |\n| 要求过于笼统 | \"写个文档\" | 具体说明包含哪些内容 |\n\n## 本节要点\n\n- ✅ **代码注释**：指定注释类型 + 风格 + 详细程度\n- ✅ **README**：提供项目信息 + 功能列表 + 技术细节\n- ✅ **API 文档**：提供接口代码 + 指定文档格式\n- ✅ **使用说明**：明确目标用户 + 指定语言风格\n- ✅ **关键技巧**：提供上下文 + 指定目标读者 + 给出格式示例\n```",
      "word_count": 5467,
      "estimated_time": 10
    },
    {
      "id": "lesson-108",
      "chapter_id": "chapter-04",
      "lesson_number": 1,
      "title": "4.1.1 回顾第二章成果：小李的待办清单",
      "content": "# 4.1.1 回顾第二章成果：小李的待办清单 ​\n\n本小节目标：用 5 分钟把第二章的思考成果\"打包\"成可以交给 AI 的任务\n\n## 从\"思考\"到\"执行\" ​\n\n还记得第二章的小李吗？他是一个职场新人，经常忘事，想做一个待办清单来管理自己的任务。\n\n在第二章，我们帮小李做了很多思考工作：用户画像、灵魂三问、MVP 定义、风险预判......\n\n现在，这些思考要真正变成代码了。\n\n但在开始写 Prompt 之前，我们需要把这些思考成果\"打包\"成一个简洁的\"开发任务卡\"。\n\n## 小李案例的一页纸总结 ​\n\n如果你跟着第二章做了思考，现在把它整理成这样的格式：\n\n### 灵魂三问 ​\n问题答案用户是谁小李，职场新人，25岁，经常忘事痛点在哪脑子里装太多事，容易遗漏重要任务，事后懊悔为什么选这个方案简单、快速、随时能用，不需要学习成本\n### MVP 功能范围 ​\n优先级功能说明本章实现P0添加任务输入任务名称，点击添加✅P0显示列表看到所有待办任务✅P0标记完成点击任务，标记为已完成✅P0删除任务删除不需要的任务✅P1数据保存刷新页面后数据还在✅P2分类标签按类型给任务分组❌ 留给你扩展P2截止日期设置任务的截止时间❌ 留给你扩展P2优先级区分任务的紧急程度❌ 留给你扩展\n### 不做清单 ​\n\n第一版明确不做的事情：\n\n- ❌ 多用户/账号系统\n- ❌ 数据同步/云存储\n- ❌ 移动端专属适配\n- ❌ 提醒/通知功能\n## 为什么现在不需要完美的 PRD ​\n\n你可能会想：\"第二章不是教我们写 PRD 吗？我是不是应该把 PRD 写得更完整？\"\n\n不需要。\n\n第一版的目标是验证想法，不是做出完美产品。\n\n以小李的待办清单为例：\n\n- 核心假设是\"一个简单的待办清单能帮小李减少遗忘\"\n- 验证这个假设，只需要：能添加、能看到、能完成、能删除\n- 其他功能都是在假设验证成功后才需要考虑的\n所以，你现在手里的\"灵魂三问 + MVP 功能列表\"就够用了。\n\n💡 提示\n\n如果你在第二章写了更详细的 PRD，那更好。但如果你只有上面这些内容，完全足够开始了。\n\n## 把思考成果转化为\"开发任务卡\" ​\n\n现在，把你的思考成果整理成这张\"项目启动卡\"：\nmarkdown\n`# 项目启动卡\n\n## 项目名称\n个人待办清单\n\n## 一句话描述\n帮助小李管理日常任务，减少遗忘的简单网页工具\n\n## 目标用户\n职场新人，经常忘事，需要一个随时能用的任务管理工具\n\n## 第一版核心功能（按优先级）\n1. 添加任务（输入任务名称，点击添加按钮）\n2. 显示任务列表（看到所有待办任务）\n3. 标记完成（点击任务，标记为已完成，视觉上有区分）\n4. 删除任务（删除不需要的任务）\n5. 数据保存（刷新页面后数据还在）\n\n## 明确不做\n- 账号系统\n- 云同步\n- 提醒通知\n- 移动端专属适配\n\n## 技术约束\n- 纯前端实现（HTML + CSS + JavaScript）\n- 使用浏览器本地存储（localStorage）保存数据\n- 不需要后端服务器`这张卡片包含了你需要告诉 AI 的所有核心信息。在 4.2 节，我们会用第三章学的 S.C.A.F.F. 框架，把这些信息组织成 Prompt。\n\n## 如果你有自己的项目想法 ​\n\n到目前为止，我们一直在用小李的待办清单作为案例。如果你想做自己的项目，完全可以。\n\n但建议第一次先跟着小李案例走完整个流程，原因是：\n\n- 待办清单涵盖了最常用的操作（增删改查）\n- 遇到问题时，你可以对照教程排查\n- 完成后你会获得完整的经验，做自己的项目时更有信心\n做完小李的项目后，你可以立刻用同样的方法做自己的项目。\n\n## 本小节要点 ​\n\n✓ 你已经有了\"需求文档\"：第二章的思考成果就是你的需求文档，现在只是把它整理成可执行的格式。\n\n✓ 不需要完美：灵魂三问 + MVP 功能列表就够开始了。\n\n✓ 项目启动卡是你的指南针：接下来的开发过程中，随时可以回来看这张卡，确认自己在做对的事情。\n\n下一步\n\n现在你明确了\"要做什么\"，接下来确认\"工具能用\"。\n\n→ 4.1.2 准备你的 AI IDE",
      "word_count": 1734,
      "estimated_time": 3
    },
    {
      "id": "lesson-109",
      "chapter_id": "chapter-04",
      "lesson_number": 2,
      "title": "4.1.2 准备你的 AI IDE",
      "content": "# 4.1.2 准备你的 AI IDE ​\n\n本小节目标：用 5 分钟确认你的 AI IDE 已准备就绪\n\n## 确认工具已安装 ​\n\n如果你跟着第一章学习，应该已经选择并安装了一个 AI IDE。\n\n还没安装？请先回顾 1.4 工具选型指南，完成安装后再继续。\n\n重要\n\n本章使用本地安装的 AI IDE 进行开发。请确保你的电脑上已经安装好工具。\n\n## 熟悉 AI IDE 的界面布局 ​\n\n无论你使用哪款 AI IDE，它们都有相似的界面结构：\n\n`┌────────────────────────────────────────────────────────────┐\n│                        AI IDE 通用布局                      │\n├──────────────┬─────────────────────┬───────────────────────┤\n│              │                     │                       │\n│   文件区      │      代码区          │       预览区          │\n│  (项目文件)   │   (AI生成的代码)      │   (实时效果)          │\n│              │                     │                       │\n├──────────────┴─────────────────────┴───────────────────────┤\n│                        对话区                               │\n│               (你输入 Prompt 的地方)                         │\n└────────────────────────────────────────────────────────────┘`\n### 对话区：你和 AI 沟通的地方 ​\n这是最重要的区域。你在这里输入 Prompt（也叫指令、需求描述），AI 会理解你的意图并生成代码。\n\n找到它：通常在界面底部或侧边，有一个输入框，可能标注着 \"Ask AI\"、\"Chat\"、\"Composer\" 等字样。\n\n### 代码区：AI 生成代码的地方 ​\n\nAI 生成的代码会显示在这里。你通常不需要直接编辑这些代码，但可以查看。\n\n找到它：通常在界面中央，显示着类似 `index.html`、`app.js` 这样的文件内容。\n\n### 文件区：管理项目文件的地方 ​\n\n这里显示项目中的所有文件和文件夹。随着开发推进，你会看到越来越多的文件出现在这里。\n\n找到它：通常在界面左侧，是一个树状的文件列表。\n\n### 预览区：看到效果的地方 ​\n\n这是最有成就感的区域。你的网页会在这里实时显示。\n\n找到它：通常在界面右侧，可能需要点击 \"Preview\"、\"Run\" 或类似按钮才会出现。有些 AI IDE 也支持在浏览器中打开预览。\n\n## 创建项目文件夹 ​\n\n在开始之前，建议在你的电脑上创建一个专门的项目文件夹：\n\n- 打开\"文档\"或\"桌面\"文件夹\n- 创建一个新文件夹，命名为 `vibe-coding-projects`\n- 在里面再创建一个子文件夹 `todo-list`（待办清单项目）\n文件夹结构如下：\n\n`文档/\n└── vibe-coding-projects/\n    └── todo-list/        ← 本章项目放这里`💡 为什么要这样做\n\n把项目放在固定位置，方便你以后找到。AI IDE 生成的文件都会保存在这个文件夹里。\n\n## 在 AI IDE 中打开项目文件夹 ​\n\n- 打开你的 AI IDE\n- 找到\"打开文件夹\"或\"Open Folder\"选项\n- 选择刚才创建的 `todo-list` 文件夹\n- 确认打开\n现在，你的 AI IDE 应该显示一个空的项目。\n\n## 验证工具正常：一个简单测试 ​\n\n在对话区输入以下 Prompt，测试工具是否正常工作：\n\n`请帮我创建一个简单的网页，显示\"Hello, Vibe Coding!\"这句话，文字居中，使用蓝色。`\n### 预期结果 ​\n你应该看到：\n\n- AI 开始生成代码（通常是一个 `index.html` 文件）\n- 代码区显示生成的 HTML 代码\n- 文件区出现新的文件\n- 预览区显示一个网页，上面有蓝色居中的 \"Hello, Vibe Coding!\" 文字\n### 如果一切正常 ​\n\n恭喜！你的工具已经准备好了。可以直接跳到 4.1.4 最终检查清单。\n\n### 如果遇到问题 ​\n问题可能原因解决方法对话区没反应网络问题或未登录检查网络连接，确认已登录账号AI 回复很慢网络延迟耐心等待，或检查网络状况代码生成了但看不到预览预览未开启找到 \"Preview\" 或 \"Run\" 按钮，或在浏览器中打开生成的 HTML 文件提示额度用完免费额度耗尽查看是否可以购买额度，或等待月度额度刷新界面全是英文语言设置不影响使用，AI 可以理解中文 Prompt\n## 关于免费额度 ​\n\n大多数 AI IDE 都提供免费额度或试用期。对于本教程的待办清单项目，免费额度通常足够。\n\n如果额度不够：\n\n- 查看工具是否有付费选项\n- 优化你的 Prompt，减少不必要的对话\n- 等待月度额度刷新\n## 本小节要点 ​\n\n✓ 工具已安装：你的电脑上有一个可用的 AI IDE\n\n✓ 界面已熟悉：知道对话区、代码区、文件区、预览区在哪里\n\n✓ 项目已创建：有一个专门的项目文件夹，AI IDE 已打开这个文件夹\n\n✓ 测试已通过：用 \"Hello, Vibe Coding!\" 验证了工具正常工作\n\n下一步\n\n工具确认可用后，我们来做最后的环境检查。\n\n→ 4.1.3 工具准备与环境检查",
      "word_count": 2528,
      "estimated_time": 5
    },
    {
      "id": "lesson-110",
      "chapter_id": "chapter-04",
      "lesson_number": 3,
      "title": "4.1.3 工具准备与环境检查",
      "content": "# 4.1.3 工具准备与环境检查 ​\n\n本小节目标：用 3 分钟完成环境检查，排除常见问题\n\n## 5 项快速检查 ​\n\n逐项确认以下内容。全部通过后，你就可以开始了。\n\n### ✅ 检查 1：工具能打开 ​\n\n- [ ] AI IDE 已安装并能正常启动\n- [ ] 能正常登录（如需要）\n- [ ] 界面加载完成，没有报错\n### ✅ 检查 2：网络正常 ​\n\n- [ ] AI IDE 能连接到服务器\n- [ ] 对话区输入后能收到 AI 回复\n### ✅ 检查 3：额度充足 ​\n\n- [ ] 确认还有免费额度可用\n- [ ] 或已准备好付费方案\n### ✅ 检查 4：时间充足 ​\n\n- [ ] 有至少 30 分钟的连续时间（完成第一轮）\n- [ ] 最好有 1-2 小时（完成整个第四章）\n- [ ] 期间不会被频繁打断\n### ✅ 检查 5：心态就位 ​\n\n- [ ] 准备好接受\"第一次不完美\"\n- [ ] 准备好看到报错信息\n- [ ] 相信\"报错可以用 AI 帮忙修\"\n## 常见问题速查 ​\n\n如果上面某项检查没通过，看看这里有没有解决方案：\n\n### 问题：网络访问不稳定 ​\n\n症状：AI 回复超时，频繁断连\n\n解决方案：\n\n- 尝试切换网络（如从 WiFi 切到手机热点）\n- 检查是否需要配置代理\n- 重启 AI IDE 后重试\n### 问题：账号登录失败 ​\n\n症状：提示登录失败、账号不存在、密码错误\n\n解决方案：\n\n- 确认使用正确的登录方式（邮箱/GitHub/Google 等）\n- 尝试重置密码\n- 检查邮箱是否收到验证邮件\n### 问题：提示额度用完 ​\n\n症状：AI 不再回复，提示 \"quota exceeded\" 或类似信息\n\n解决方案：\n\n- 等待月度额度刷新（通常每月 1 号）\n- 购买额外额度\n- 优化 Prompt，减少不必要的对话次数\n### 问题：工具崩溃或卡住 ​\n\n症状：界面无响应，一直在加载\n\n解决方案：\n\n- 重启 AI IDE\n- 检查是否有软件更新\n- 如果问题持续，尝试重新安装\n### 问题：生成的代码看不懂 ​\n\n症状：AI 生成了很多代码，但你不知道是什么意思\n\n这不是问题。Vibe Coding 的核心理念就是：你不需要完全理解代码。只要结果符合预期，代码细节可以交给 AI。\n\n如果结果不符合预期，你需要做的是告诉 AI 哪里不对，而不是自己修改代码。\n\n## 推荐的学习环境设置 ​\n\n为了获得最佳学习体验，建议：\n\n### 屏幕布局 ​\n\n如果你有大屏幕或双显示器：\n\n- 一边放 AI IDE（用于操作）\n- 一边放本教程（用于参考）\n如果只有一个屏幕：\n\n- 可以用浏览器标签页切换\n- 或者用分屏功能并排显示\n### 窗口布局建议 ​\n\n开始之前，建议准备好：\n\n- AI IDE（全屏或半屏显示）\n- 浏览器（打开本教程页面）\n### 减少干扰 ​\n\n- 关闭不必要的通知\n- 告诉家人/室友你需要一段专注时间\n- 准备好水或饮料（减少起身次数）\n## 快速通道：如果你很有信心 ​\n\n如果你满足以下所有条件，可以跳过剩余检查，直接进入 4.2：\n\n- ✅ 工具测试通过（4.1.2 的 Hello World 测试成功）\n- ✅ 知道自己要做什么（待办清单或自己的项目）\n- ✅ 有 1 小时以上的时间\n- ✅ 准备好接受报错\n→ 4.2 第一轮：搭建页面框架\n\n## 本小节要点 ​\n\n✓ 5 项检查：工具、网络、额度、时间、心态\n\n✓ 常见问题有解：大多数问题都可以快速解决\n\n✓ 环境影响效率：好的学习环境能让你更专注\n\n最后一步\n\n环境检查通过后，让我们做最后的确认。\n\n→ 4.1.4 本节检查清单",
      "word_count": 1558,
      "estimated_time": 3
    },
    {
      "id": "lesson-111",
      "chapter_id": "chapter-04",
      "lesson_number": 4,
      "title": "4.1.4 本节检查清单",
      "content": "# 4.1.4 本节检查清单 ​\n\n本小节目标：60 秒完成最终确认，然后开始动手\n\n## 60 秒快速确认 ​\n\n### 我知道要做什么 ​\n\n- [ ] 我要做一个待办清单（或其他已想好的项目）\n- [ ] 我知道第一版的核心功能：添加、显示、完成、删除、保存\n- [ ] 我知道什么不做：账号系统、云同步、提醒通知\n### 我的工具已就绪 ​\n\n- [ ] AI IDE 已打开，能正常使用\n- [ ] 测试 Prompt 通过（\"Hello, Vibe Coding!\" 能显示）\n- [ ] 我知道项目保存在哪里\n### 我的心态已就位 ​\n\n- [ ] 我准备好看到报错信息（这很正常）\n- [ ] 我准备好第一次不完美（先跑通再优化）\n- [ ] 我相信 AI 可以帮我修复问题\n## 判断标准 ​\n\n### 🟢 全部打勾 → 可以开始 ​\n\n恭喜！你已经准备好了。下一节，你将写出第一个 Prompt，开始真正的开发。\n\n### 🟡 有 1-2 项没打勾 → 快速补上 ​\n\n回到对应的小节，花 2-3 分钟解决：\n\n- 不知道做什么 → 4.1.1 回顾第二章成果\n- 工具有问题 → 4.1.2 准备你的 AI IDE\n- 环境有问题 → 4.1.3 工具准备与环境检查\n### 🔴 有 3 项以上没打勾 → 先别急 ​\n\n建议从 4.1.1 开始，按顺序完成准备工作。不用着急，多花 10 分钟准备，比中途卡住要好。\n\n## 给自己的心态提醒 ​\n\n在你点击\"下一节\"之前，记住这几点：\n\n### 1. 报错是正常的 ​\n\n几乎每个项目都会遇到报错。这不代表你做错了，也不代表 AI 不行。报错只是程序告诉你\"这里有点问题\"。\n\n遇到报错时，你需要做的就是把报错信息告诉 AI，让它帮你修复。\n\n### 2. 第一次不需要完美 ​\n\n你的目标是做出来，而不是做完美。\n\n一个能用但丑陋的待办清单，比一个永远做不出来的完美设计更有价值。\n\n先跑通，再优化。\n\n### 3. 你比想象中准备得更好 ​\n\n你已经：\n\n- 用第二章的方法想清楚了要做什么\n- 用第三章的方法学会了如何与 AI 沟通\n- 用本节确认了工具和环境\n很多人没有这些准备就开始了。你已经走在前面了。\n\n## 本节回顾 ​\n\n在 4.1 节，你完成了以下准备工作：\n准备项你获得了什么回顾第二章一张清晰的\"项目启动卡\"准备 AI IDE一个经过测试的可用工具环境检查排除了常见的障碍心态准备准备好迎接挑战\n这些准备会在接下来的开发过程中持续发挥作用。\n\n## 下一节预告 ​\n\n在 4.2 节，你将：\n\n- 用第三章学的 S.C.A.F.F. 框架写出第一个 Prompt\n- 让 AI 生成待办清单的基础页面\n- 看到你的第一个\"作品\"出现在屏幕上\n- 学会如何调整和优化页面样式\n预计时间：20 分钟\n\n🎉 准备好了吗？\n\n你已经完成了所有准备工作。\n\n现在，让我们开始真正的开发！\n\n→ 4.2 第一轮：搭建页面框架",
      "word_count": 1255,
      "estimated_time": 3
    },
    {
      "id": "lesson-112",
      "chapter_id": "chapter-04",
      "lesson_number": 5,
      "title": "4.2.1 用第三章框架写第一个 Prompt",
      "content": "# 4.2.1 用第三章框架写第一个 Prompt ​\n\n本步目标：把 4.1 节的\"项目启动卡\"转化为 AI 能理解的 Prompt\n\n## 从项目启动卡到 Prompt ​\n\n在 4.1 节，我们整理了小李项目的「项目启动卡」。现在要把它转化为 Prompt，让 AI 帮我们生成代码。\n\n`项目启动卡                         Prompt\n┌──────────────┐                ┌──────────────┐\n│ 项目名称      │                │ Situation    │\n│ 目标用户      │  ──转化──→     │ Challenge    │\n│ 核心功能      │                │ Audience     │\n│ 明确不做      │                │ Format       │\n│ 技术约束      │                │ Foundations  │\n└──────────────┘                └──────────────┘`转化的逻辑：\n项目启动卡内容对应 Prompt 位置作用项目名称 + 目标用户Situation（情境）告诉 AI 你在做什么核心功能列表Challenge（挑战）告诉 AI 当前要做什么你是谁Audience（受众）让 AI 调整代码复杂度期望输出格式Format（格式）让 AI 知道给你什么明确不做 + 技术约束Foundations（基础）告诉 AI 边界在哪\n## 三种 Prompt 版本 ​\n\n根据你的时间和需求，可以选择不同详细程度的 Prompt。\n\n### 版本一：最简版（赶时间用） ​\n\n如果你已经熟悉了这个流程，或者只是想快速看到效果：\n\n`帮我做一个待办清单网页的静态页面。\n包含：标题、输入框、添加按钮、任务列表（带完成和删除按钮）。\n风格简约现代，要能在手机上正常显示。\n先不需要功能，只要页面样式。用 HTML + CSS，不用任何框架。`这个版本大约 70 字，能覆盖最核心的信息。\n\n### 版本二：标准版（推荐日常使用） ​\n\n使用第三章的 S.C.F. 精简框架：\n\n`【背景】\n我正在做一个个人待办清单网页，帮助管理日常任务。\n我是编程零基础的初学者。\n\n【任务】\n请生成待办清单的静态页面，包含以下元素：\n- 页面标题：\"我的待办清单\"\n- 一个输入框，用于输入新任务\n- 一个\"添加\"按钮\n- 任务列表区域，先用 3 条假数据展示样式\n- 每个任务有\"完成\"按钮和\"删除\"按钮\n\n【约束】\n- 只需要静态页面，暂时不需要任何功能\n- 使用纯 HTML + CSS，不使用任何框架\n- 现代简约风格，清新配色\n- 响应式设计，手机上也能正常显示\n- 代码加上必要的中文注释`\n### 版本三：完整版（第一次使用建议） ​\n使用 S.C.A.F.F. 全要素框架，给 AI 最充分的上下文：\n\n`【Situation - 情境】\n我是一个编程零基础的初学者，正在学习用 AI 做一个个人待办清单网页。\n这是我的第一个 AI 编程项目。\n目标用户是像我一样容易忘事的职场新人，需要一个简单的任务管理工具。\n\n【Challenge - 挑战】\n请帮我生成待办清单的静态页面，包含以下元素：\n1. 页面标题：\"我的待办清单\"\n2. 输入区域：\n   - 一个输入框（用于输入新任务）\n   - 一个\"添加\"按钮\n3. 任务列表区域：\n   - 先用 3 条假数据展示样式（如：\"完成项目报告\"、\"买牛奶\"、\"给妈妈打电话\"）\n   - 每个任务显示任务内容\n   - 每个任务右侧有\"完成\"按钮和\"删除\"按钮\n\n【Audience - 受众】\n- 代码将由我这个初学者阅读和修改\n- 请保持代码简单易懂\n- 在关键位置添加中文注释，帮助我理解代码结构\n\n【Format - 格式】\n请生成一个完整的 HTML 文件，包含：\n- HTML 结构\n- 内嵌的 CSS 样式（写在 <style> 标签里）\n- 文件可以直接在浏览器中打开查看效果\n\n【Foundations - 基础约束】\n- 只做静态页面，暂时不需要 JavaScript 功能\n- 不使用任何外部框架或库（如 Bootstrap、Tailwind）\n- 设计风格：现代简约，参考苹果或 Notion 的设计语言\n- 配色清新，主色调可以用蓝色或绿色系\n- 响应式设计：在手机（宽度 375px）和电脑上都能正常显示\n- 页面整体居中显示，最大宽度 500px`\n## 为什么要告诉 AI 你是初学者？ ​\n你可能注意到，每个版本都提到了\"我是初学者\"。这不是谦虚，而是一个重要的策略：\n不说\"初学者\"说了\"初学者\"AI 可能使用高级语法和技巧AI 会使用基础、直观的写法代码可能没有注释AI 会主动添加解释性注释变量名可能很简短AI 会使用更具描述性的命名遇到问题你可能看不懂代码更容易阅读和调试\n这个小技巧能让 AI 生成的代码更适合你当前的水平。\n\n## 描述方式对比：模糊 vs 具体 ​\n\n写 Prompt 时，越具体越好。看看这些对比：\n方面模糊描述（避免）具体描述（推荐）颜色好看的颜色主色调用蓝色系，如 #4F46E5布局居中显示页面最大宽度 500px，水平居中风格现代风格参考苹果官网的极简风格，圆角卡片按钮添加一些按钮每个任务右侧有\"完成\"和\"删除\"两个按钮数据展示一些任务用 3 条假数据，如\"完成项目报告\"等\n为什么具体描述更好？因为 AI 面对模糊描述时只能\"猜\"，而具体描述让 AI 知道你到底想要什么。\n\n## 检查你的 Prompt ​\n\n在发送之前，用这个清单检查一下：\n\n- [ ] 说明了项目背景（做什么、给谁用）？\n- [ ] 列出了要包含的页面元素？\n- [ ] 指定了技术约束（HTML + CSS，不用框架）？\n- [ ] 说明了设计风格和配色偏好？\n- [ ] 提到了响应式需求？\n- [ ] 告诉 AI 你是初学者，需要注释？\n## 选择哪个版本？ ​\n你的情况建议使用第一次跟着教程做完整版，获得最好的结果已经做过一次，想快速复习标准版已经很熟练，想快速验证想法最简版\n建议\n\n如果这是你第一次做 AI 编程项目，建议使用完整版。多花 2 分钟写 Prompt，能省下后面很多调整时间。\n\n## 本步检查点 ​\n\n- [ ] 选择了适合自己的 Prompt 版本\n- [ ] 复制好了 Prompt，准备发送给 AI\n→ 4.2.2 生成静态页面",
      "word_count": 2762,
      "estimated_time": 5
    },
    {
      "id": "lesson-113",
      "chapter_id": "chapter-04",
      "lesson_number": 6,
      "title": "4.2.2 生成静态页面",
      "content": "# 4.2.2 生成静态页面 ​\n\n本步目标：把 Prompt 发送给 AI，获得第一版静态页面\n\n## 发送 Prompt ​\n\n现在，把你在上一步准备好的 Prompt 发送给 AI IDE。\n\n还记得 4.1.2 节介绍的界面布局吗？找到 对话区，把 Prompt 粘贴进去，按回车发送。\n\n不同 AI IDE 的对话区位置可能略有不同，但都很好找：\n\n- 通常在界面底部或侧边栏\n- 可能标注着 \"Chat\"、\"AI\"、\"Composer\"、\"Cascade\" 等字样\n- 有些工具可以用快捷键打开（如 Cursor 的 `Cmd/Ctrl + L`）\n找不到对话区？\n\n回顾 4.1.2 准备你的 AI IDE 中的界面布局说明。如果你使用的工具不在常见列表中，可以查看 1.4.1 AI 编程工具全景图 获取更多工具信息。\n\n发送后，等待 AI 生成代码。通常需要 10-30 秒。\n\n## 你应该看到什么 ​\n\nAI 生成完成后，你应该能看到一个待办清单页面，包含以下结构：\n\n`┌─────────────────────────────────────┐\n│                                     │\n│        我的待办清单                  │  ← 标题区\n│                                     │\n├─────────────────────────────────────┤\n│  ┌─────────────────────┐ ┌────┐    │\n│  │ 输入新任务...        │ │添加│    │  ← 输入区\n│  └─────────────────────┘ └────┘    │\n├─────────────────────────────────────┤\n│                                     │\n│  □ 完成项目报告      [完成] [删除]  │  ← 任务列表区\n│  □ 买牛奶            [完成] [删除]  │    （假数据）\n│  □ 给妈妈打电话      [完成] [删除]  │\n│                                     │\n└─────────────────────────────────────┘`具体检查这些元素是否存在：\n\n- [ ] 页面有标题\"我的待办清单\"\n- [ ] 有一个输入框\n- [ ] 有一个\"添加\"按钮\n- [ ] 有任务列表，显示几条假数据\n- [ ] 每个任务有\"完成\"和\"删除\"按钮\n- [ ] 整体布局居中，看起来比较整齐\n## 五种可能的情况及处理 ​\n\n第一次生成的结果可能会有差异。根据你看到的情况，选择对应的处理方式：\n\n### 情况一：完美符合预期 ​\n\n现象：页面布局、样式、元素都符合预期。\n\n处理：太棒了！直接跳到 4.2.4 阶段性成果检查。\n\n### 情况二：结构对，但样式不满意 ​\n\n现象：所有元素都在，但颜色太暗、按钮太小、间距不够等。\n\n处理：进入 4.2.3 调整样式与布局，用迭代对话调整。\n\n### 情况三：缺少某些元素 ​\n\n现象：比如没有\"完成\"按钮，或者没有假数据。\n\n处理：发送追加说明：\n\n`页面整体不错，请补充以下内容：\n- 每个任务需要有\"完成\"按钮和\"删除\"按钮\n- 任务列表先用 3 条假数据展示样式`\n### 情况四：页面空白 ​\n现象：浏览器显示空白页面，什么都没有。\n\n处理：这通常是文件保存或预览问题，按以下顺序排查：\n\n- 确认文件已保存：在 AI IDE 中按 `Ctrl+S`（Mac 用 `Cmd+S`）\n- 刷新预览：按 `Ctrl+Shift+R`（Mac 用 `Cmd+Shift+R`）强制刷新\n- 检查文件位置：确认 HTML 文件保存在正确的位置\n- 查看控制台：按 `F12` 打开开发者工具，看是否有红色错误\n如果以上都不行，让 AI 帮你检查：\n\n`页面显示空白，请帮我检查代码是否有问题。\n如果有问题，请修复并给我完整的正确代码。`\n### 情况五：代码报错 ​\n现象：浏览器控制台显示红色错误信息。\n\n处理：跳到 4.5.2 用 AI 帮你修 AI 的代码，学习如何让 AI 帮你修复。\n\n## 理解 AI 生成的代码结构 ​\n\n你不需要完全理解代码，但了解大致结构会帮助你后续调整。AI 生成的 HTML 文件通常是这样的：\nhtml\n`<!DOCTYPE html>\n<html>\n<head>\n    <!-- 页面标题和设置 -->\n    <title>我的待办清单</title>\n    <style>\n        /* \n         * 这里是 CSS 样式代码\n         * 控制页面的颜色、大小、布局\n         */\n    </style>\n</head>\n<body>\n    <!-- 这里是页面内容 -->\n    \n    <div class=\"container\">\n        <!-- 标题 -->\n        <h1>我的待办清单</h1>\n        \n        <!-- 输入区域 -->\n        <div class=\"input-area\">\n            <input type=\"text\" placeholder=\"输入新任务...\">\n            <button>添加</button>\n        </div>\n        \n        <!-- 任务列表 -->\n        <ul class=\"task-list\">\n            <li>\n                <span>完成项目报告</span>\n                <button>完成</button>\n                <button>删除</button>\n            </li>\n            <!-- 更多任务... -->\n        </ul>\n    </div>\n</body>\n</html>`简单理解：\n代码部分作用`<head>...</head>`页面的\"幕后设置\"，包括标题和样式`<style>...</style>`CSS 样式，控制外观`<body>...</body>`页面的\"正文内容\"，用户看到的部分`<div>`一个容器，用来分组和布局`<input>`输入框`<button>`按钮`<ul>` 和 `<li>`列表和列表项\n不需要记住这些\n\n这只是帮助你理解代码结构。在 Vibe Coding 中，你不需要自己写这些代码——只需要告诉 AI 你想要什么，它会帮你写。\n\n## 点击按钮没反应？ ​\n\n如果你尝试点击\"添加\"按钮，发现什么都没发生——这是完全正常的。\n\n现在的页面只是一个\"壳\"，还没有任何功能代码。就像一辆车的模型，看起来像车，但还不能开动。\n\n在 4.3 节，我们会让这些按钮\"活\"起来。\n\n## 常见问题速查 ​\n问题可能原因解决方法页面完全空白文件未保存或未正确预览保存文件，刷新浏览器样式看起来很丑AI 的默认样式不符合你的审美进入 4.2.3 调整只有文字没有样式CSS 未正确引入让 AI 检查代码结构页面在手机上显示异常缺少响应式设置要求 AI 添加响应式样式按钮点击无反应正常！静态页面没有功能4.3 节会添加功能\n## 本步检查点 ​\n\n继续之前，确认：\n\n- [ ] AI 已经生成了代码\n- [ ] 能在浏览器中看到页面\n- [ ] 页面包含标题、输入框、按钮、任务列表\n如果样式不满意，进入下一步调整。如果已经满意，可以直接跳到 4.2.4 阶段性成果检查。\n\n→ 4.2.3 调整样式与布局",
      "word_count": 3331,
      "estimated_time": 6
    },
    {
      "id": "lesson-114",
      "chapter_id": "chapter-04",
      "lesson_number": 7,
      "title": "4.2.3 调整样式与布局",
      "content": "# 4.2.3 调整样式与布局 ​\n\n本步目标：用迭代对话优化页面的外观，让它更符合你的审美\n\n## 迭代调整的心态 ​\n\n第一版代码很少是完美的，这很正常。\n\n还记得第三章学的\"迭代对话\"吗？现在就是用它的时候：\n\n`第一版 → 看看哪里不满意 → 告诉 AI → 拿到新版本 → 再看看 → ...`通常 2-3 轮调整就能达到满意的效果。不要期望一次完美，也不要无限调整。\n\n## 分场景的调整 Prompt 库 ​\n\n下面是一些常见调整场景的 Prompt，你可以直接复制使用，也可以根据需要修改。\n\n### 颜色调整类 ​\n\n整体配色太暗：\n\n`整体配色太暗了，请改成更清新明亮的风格。\n建议：\n- 背景用浅灰色（如 #f5f5f5）\n- 主色调用亮蓝色（如 #3b82f6）\n- 按钮使用渐变或更鲜艳的颜色`想换一个主题色：\n\n`请把主色调从蓝色改成绿色系。\n添加按钮用深绿色（#059669），完成按钮用浅绿色。`按钮颜色不够醒目：\n\n`\"添加\"按钮的颜色太淡了，改成更醒目的蓝色（#2563eb），\n文字改成白色，鼠标悬停时颜色加深。`\n### 布局调整类 ​\n输入框和按钮的位置：\n\n`把输入框和添加按钮放在同一行。\n输入框占大部分宽度，按钮在右边。\n两者之间留 8px 间距。`页面整体位置：\n\n`页面内容整体往上移一些，距离顶部 30px 就够了。\n标题和输入区域之间的间距减小到 16px。`任务列表太挤：\n\n`任务列表的每一项之间间距太小，看起来很挤。\n请把每个任务项之间的间距增加到 12px，让视觉更清爽。`\n### 间距调整类 ​\n整体太紧凑：\n\n`页面整体看起来太拥挤。请增加以下间距：\n- 页面内边距增加到 24px\n- 标题下方间距增加到 24px\n- 输入区域和列表之间间距增加到 20px`整体太松散：\n\n`页面元素之间间距太大，看起来很空。\n请适当减小各部分之间的间距，让页面更紧凑。`\n### 尺寸调整类 ​\n输入框太窄：\n\n`输入框太窄了，打字不方便。\n请把输入框高度增加到 44px，内边距增加到 12px。`按钮太小：\n\n`按钮太小，不容易点击。\n请把所有按钮的最小高度设为 36px，内边距增加到 12px 16px。`字体大小调整：\n\n`标题字体再大一些（28px），任务内容用 16px，按钮文字用 14px。`\n### 响应式适配类 ​\n手机上显示不正常：\n\n`页面在手机上显示有问题，内容超出屏幕边缘。\n请确保：\n- 在窄屏幕（宽度小于 400px）时，页面宽度自适应\n- 按钮在窄屏幕时可以换行显示\n- 字体大小在手机上不要太小`\n### 风格参考类 ​\n参考特定产品风格：\n\n`请把整体风格改成类似苹果备忘录的感觉：\n- 纯白背景\n- 圆角更大一些（12px）\n- 阴影更柔和\n- 字体使用系统默认字体`更现代的感觉：\n\n`风格再现代一些：\n- 添加轻微的卡片阴影\n- 使用圆角（8px）\n- 鼠标悬停时有轻微的颜色变化\n- 整体使用无衬线字体`\n## 小李的调整过程示例 ​\n来看小李如何用迭代对话优化他的待办清单页面。\n\n### 第一轮：整体感觉 ​\n\n小李看到第一版后的想法：结构对了，但颜色太普通，按钮太小。\n\n小李发送：\n\n`页面结构不错，请做以下调整：\n1. 整体配色改成蓝绿色系，更清新\n2. 添加按钮改成圆角，颜色更鲜艳\n3. 按钮高度增加，更容易点击`\n### 第二轮：细节调整 ​\n小李看到新版后的想法：好多了，但输入框和列表的间距还可以优化。\n\n小李发送：\n\n`颜色好多了！再调整两个细节：\n1. 输入框和任务列表之间的间距增加到 20px\n2. 每个任务项加一条浅灰色的分隔线`\n### 第三轮：收尾 ​\n小李发送：\n\n`整体很好了。最后一个小调整：\n- 任务右侧的两个按钮之间留一点间距（8px）\n- \"完成\"按钮用绿色，\"删除\"按钮用红色，颜色对比更明显`经过三轮调整，小李得到了一个满意的页面。\n\n## 常见样式问题速查表 ​\n问题快速调整 Prompt输入框太窄输入框宽度改成 100%，减去按钮的宽度按钮太小所有按钮最小高度 36px，内边距 12px 16px列表间距太小任务项之间增加 12px 的间距颜色太暗整体配色改成明亮清新的风格没有视觉层次给卡片添加轻微阴影，标题加粗加大手机上显示错乱添加响应式样式，宽度使用百分比鼠标悬停没反馈按钮添加 hover 效果，颜色变深或加阴影输入框太靠边增加页面内边距到 24px\n## \"够好\"的标准 ​\n\n什么时候应该停止调整，进入下一步？用这个清单判断：\n\n### 必须满足 ​\n\n- [ ] 所有元素都在正确的位置\n- [ ] 可以清楚地看到标题、输入框、按钮、任务列表\n- [ ] 页面在手机宽度（375px）下不会变形\n- [ ] 没有明显的视觉问题（文字溢出、元素重叠）\n### 加分项（有更好，没有也行） ​\n\n- [ ] 配色符合你的审美\n- [ ] 鼠标悬停有交互反馈\n- [ ] 整体风格统一\n- [ ] 间距看起来舒适\n### 不需要追求的 ​\n\n- [ ] 完美的像素级对齐\n- [ ] 动画效果\n- [ ] 复杂的视觉效果\n重要\n\n80 分就够了，先跑通再优化。如果你已经调整了 3-4 轮，差不多就可以停了。\n\n记住，我们的目标是做出一个能用的待办清单，不是参加设计比赛。\n\n## 调整建议 ​\n\n- 一次只调整一类问题：颜色、布局、间距分开调整，这样更容易控制\n- 具体描述：不要说\"好看点\"，要说\"按钮用 #3b82f6 蓝色\"\n- 保留好的部分：如果某些部分已经满意，在 Prompt 中提到\"颜色保持不变\"\n- 不超过 5 轮：如果 5 轮还不满意，可能需要更清晰地描述你的需求\n## 本步检查点 ​\n\n调整完成后，确认：\n\n- [ ] 整体布局正确（标题、输入区、列表区都在）\n- [ ] 配色基本满意\n- [ ] 间距和尺寸看起来舒适\n- [ ] 手机宽度下也能正常显示\n→ 4.2.4 阶段性成果检查",
      "word_count": 2494,
      "estimated_time": 4
    },
    {
      "id": "lesson-115",
      "chapter_id": "chapter-04",
      "lesson_number": 8,
      "title": "4.2.4 阶段性成果检查",
      "content": "# 4.2.4 阶段性成果检查 ​\n\n本步目标：确认第一轮完成，准备进入下一轮\n\n## 第一轮完成检查清单 ​\n\n在进入下一轮之前，请确认以下内容：\n\n### 必须项 ​\n\n- [ ] 页面能正常显示：在浏览器中打开，没有空白或报错\n- [ ] 标题存在：能看到\"我的待办清单\"（或你自定义的标题）\n- [ ] 输入框存在：有一个可以输入文字的输入框\n- [ ] 添加按钮存在：有一个\"添加\"按钮\n- [ ] 任务列表存在：能看到任务列表区域（即使是假数据）\n- [ ] 操作按钮存在：每个任务有\"完成\"和\"删除\"按钮\n### 加分项 ​\n\n- [ ] 整体样式你基本满意\n- [ ] 鼠标悬停在按钮上有视觉反馈\n- [ ] 在手机尺寸下也能正常显示\n## 如何测试响应式效果 ​\n\n想知道页面在手机上看起来怎么样？不需要真的用手机，浏览器可以模拟：\n\n- 在浏览器中打开你的页面\n- 按 `F12` 打开开发者工具\n- 点击工具栏左上角的\"设备切换\"图标（长得像手机和平板）\n- 选择一个手机型号（如 iPhone 12）或者直接拖动页面宽度\n检查这些情况：\n\n- [ ] 页面内容没有超出屏幕\n- [ ] 文字大小在手机上也能看清\n- [ ] 按钮在手机上也容易点击\n- [ ] 输入框宽度适合手机屏幕\n小技巧\n\n如果手机上显示有问题，回到 4.2.3 节，使用\"响应式适配类\"的调整 Prompt。\n\n## 预期效果参考 ​\n\n此时你的页面应该看起来类似这样：\n\n[配图建议] 画面内容：完成第一轮后的待办清单页面截图，展示桌面和手机两种视图 Prompt: clean mockup of a simple todo list webpage, showing both desktop and mobile views, minimalist design, soft blue accent colors, friendly and approachable style, white background, high quality, 8k --ar 16:9\n\n## 此时的\"正常\"状态 ​\n\n现在你的页面是这样的状态：\n功能当前状态页面显示✅ 正常点击\"添加\"按钮❌ 没反应（正常！）点击\"完成\"按钮❌ 没反应（正常！）点击\"删除\"按钮❌ 没反应（正常！）刷新页面后数据还在❌ 数据会消失（正常！）\n这些都是正常的——我们目前只完成了\"外观\"，还没有添加\"功能\"。\n\n## 🎉 第一轮完成！ ​\n\n恭喜你！你已经完成了待办清单的第一轮开发。\n\n现在你拥有了：\n\n- ✅ 一个可以在浏览器中打开的 HTML 页面\n- ✅ 包含标题、输入框、按钮的完整界面\n- ✅ 一个任务列表区域\n- ✅ 基本美观的视觉设计\n这是一个重要的里程碑——你已经从\"什么都没有\"变成了\"能看到东西\"。\n\n## 回顾：你用到了什么 ​\n\n在这一轮中，你实践了：\n来源用到的内容第二章项目启动卡作为 Prompt 的素材第三章S.C.A.F.F. 框架组织 Prompt第三章迭代对话调整样式\n这就是 Vibe Coding 的工作流程：想清楚 → 说明白 → 让 AI 做 → 调整优化。\n\n## 下一步预告 ​\n\n页面有了，但还只是一个\"空壳\"——点击按钮没有反应，刷新页面数据就没了。\n\n下一轮，我们要让它\"活\"起来：\n\n- 点击\"添加\"按钮，能把新任务加到列表\n- 点击\"完成\"按钮，任务显示为已完成状态\n- 点击\"删除\"按钮，任务从列表中消失\n准备好了吗？\n\n→ 4.2.5 完整 Prompt 对话记录（可选阅读）\n\n→ 4.3 第二轮：实现核心功能",
      "word_count": 1526,
      "estimated_time": 3
    },
    {
      "id": "lesson-116",
      "chapter_id": "chapter-04",
      "lesson_number": 9,
      "title": "4.2.5 完整 Prompt 对话记录",
      "content": "# 4.2.5 完整 Prompt 对话记录 ​\n\n本节目标：回顾从零到静态页面的完整对话过程，作为你的参考模板\n\n## 为什么要记录对话？ ​\n\n记录完整的对话过程有几个好处：\n\n- 可复现：如果换一个项目，你可以参照这个流程\n- 可学习：回看每一轮用了什么技巧，加深理解\n- 可排错：如果后续出问题，可以回顾哪里可能出错\n## 完整对话记录示例 ​\n\n以下是小李完成第一轮静态页面的完整对话过程。\n\n### 第 1 轮：初始生成 ​\n\n小李发送：\n\n`【Situation - 情境】\n我是一个编程零基础的初学者，正在学习用 AI 做一个个人待办清单网页。\n这是我的第一个 AI 编程项目。\n目标用户是像我一样容易忘事的职场新人，需要一个简单的任务管理工具。\n\n【Challenge - 挑战】\n请帮我生成待办清单的静态页面，包含以下元素：\n1. 页面标题：\"我的待办清单\"\n2. 输入区域：\n   - 一个输入框（用于输入新任务）\n   - 一个\"添加\"按钮\n3. 任务列表区域：\n   - 先用 3 条假数据展示样式\n   - 每个任务显示任务内容\n   - 每个任务右侧有\"完成\"按钮和\"删除\"按钮\n\n【Audience - 受众】\n代码将由我这个初学者阅读和修改，请保持简单易懂，在关键位置添加中文注释。\n\n【Format - 格式】\n请生成一个完整的 HTML 文件，包含内嵌的 CSS 样式。\n\n【Foundations - 基础约束】\n- 只做静态页面，暂时不需要 JavaScript 功能\n- 不使用任何外部框架\n- 现代简约风格，配色清新\n- 响应式设计，手机上也能正常显示`AI 回复：[生成 HTML + CSS 代码，页面包含基本结构]\n\n使用的技巧：\n\n- ✓ S.C.A.F.F. 完整框架\n- ✓ 明确说明是初学者（降低代码复杂度）\n- ✓ 具体列出页面元素（避免遗漏）\n- ✓ 明确技术约束（不用框架，纯 HTML+CSS）\n小李的检查结果：\n\n- ✅ 结构完整，所有元素都在\n- ⚠️ 按钮样式有点普通\n- ⚠️ 整体配色偏暗\n### 第 2 轮：调整配色和按钮 ​\n\n小李发送：\n\n`整体结构很好！请做以下调整：\n\n1. 配色问题：\n   - 背景改成更浅的灰色（#f8fafc）\n   - 主色调用明亮的蓝色（#3b82f6）\n   \n2. 按钮样式：\n   - \"添加\"按钮改成圆角（8px），背景用蓝色，文字白色\n   - 鼠标悬停时颜色加深\n   - \"完成\"按钮用绿色（#10b981），\"删除\"按钮用红色（#ef4444）\n\n其他部分保持不变。`AI 回复：[更新后的代码，配色和按钮样式已调整]\n\n使用的技巧：\n\n- ✓ 具体的颜色值（不是\"好看的颜色\"）\n- ✓ 明确指出要保留的部分（\"其他部分保持不变\"）\n- ✓ 一次只调整一类问题（配色 + 按钮）\n小李的检查结果：\n\n- ✅ 配色清新多了\n- ✅ 按钮好看了\n- ⚠️ 任务之间间距太小\n### 第 3 轮：调整间距 ​\n\n小李发送：\n\n`颜色很好！请调整一下间距：\n\n1. 任务列表的每一项之间增加 12px 的间距\n2. 每个任务加一条浅灰色的底边框（颜色用 #e5e7eb）\n3. 任务右侧的\"完成\"和\"删除\"按钮之间留 8px 间距\n\n配色和其他样式保持不变。`AI 回复：[最终版本代码，间距已调整]\n\n使用的技巧：\n\n- ✓ 具体的像素值（12px、8px）\n- ✓ 具体的颜色值（#e5e7eb）\n- ✓ 再次强调保留已满意的部分\n小李的检查结果：\n\n- ✅ 间距舒适\n- ✅ 视觉层次清晰\n- ✅ 整体满意，可以进入下一轮\n### 第 4 轮：最后确认 ​\n\n小李发送：\n\n`看起来很不错了！请帮我确认一下：\n1. 页面在手机宽度（375px）下显示是否正常？\n2. 如果有问题，请修复。`AI 回复：[确认响应式正常，或者提供修复后的代码]\n\n使用的技巧：\n\n- ✓ 主动确认潜在问题\n- ✓ 给出具体的测试条件（375px）\n## 对话中使用的技巧汇总 ​\n轮次主要技巧来自章节第 1 轮S.C.A.F.F. 框架3.2.2第 2 轮具体描述 + 保留好的部分3.5.3第 3 轮渐进式调整3.5.2第 4 轮主动验证3.5.3\n## 这段对话可以改进的地方 ​\n\n回顾这段对话，有几个地方可以做得更好：\n\n### 1. 第一轮可以更具体 ​\n\n原版：\n\n`现代简约风格，配色清新`改进版：\n\n`参考苹果备忘录的风格，纯白背景，圆角卡片，主色调用蓝色（#3b82f6）`教训：第一轮就给出具体的风格参考和颜色，可以减少后续调整轮数。\n\n### 2. 可以合并第 2、3 轮 ​\n\n如果一开始就把配色和间距问题一起说，可以省一轮对话：\n\n`请做以下调整：\n\n配色：\n- 背景用 #f8fafc\n- 主色调用 #3b82f6\n\n按钮：\n- 圆角 8px，悬停时颜色加深\n- \"完成\"用绿色，\"删除\"用红色\n\n间距：\n- 任务之间 12px 间距\n- 按钮之间 8px 间距`教训：如果问题明确，可以一次提多个调整，节省对话轮数。\n\n### 3. 第 4 轮可以更早做 ​\n\n响应式测试可以在第 1 轮生成后就做，不用等到最后。\n\n教训：核心功能和响应式要尽早验证，发现问题早修复。\n\n## 你的对话记录模板 ​\n\n你可以用这个模板记录自己的对话过程：\nmarkdown\n`## 项目：[项目名称]\n## 日期：[日期]\n\n### 第 1 轮\n**我发送**：\n[你的 Prompt]\n\n**AI 回复**：\n[简要描述 AI 做了什么]\n\n**检查结果**：\n- ✅ [好的地方]\n- ⚠️ [需要改进的地方]\n\n### 第 2 轮\n...`记录对话不是必须的，但如果你想回顾学习过程，或者以后遇到类似项目想参考，这会很有帮助。\n\n## 本节小结 ​\n\n通过这个完整的对话记录，你可以看到：\n\n- 第一轮用 S.C.A.F.F. 框架，给 AI 充分的上下文\n- 后续轮次用具体描述，一次调整一类问题\n- 每轮都检查结果，确认哪些满意、哪些需要改进\n- 3-4 轮对话是正常的，不要期望一次完美\n现在，你可以进入第二轮，让页面\"活\"起来了。\n\n→ 4.3 第二轮：实现核心功能",
      "word_count": 2604,
      "estimated_time": 5
    },
    {
      "id": "lesson-117",
      "chapter_id": "chapter-04",
      "lesson_number": 10,
      "title": "4.3.1 功能一：添加任务",
      "content": "# 4.3.1 功能一：添加任务 ​\n\n本步目标：让用户能够输入任务内容，点击按钮后任务出现在列表中\n\n这是待办清单最核心的功能——没有它，其他功能都没有意义。\n\n## 🎯 我们要实现什么 ​\n\n用户的操作流程：\n\n- 在输入框中输入任务内容（比如\"买牛奶\"）\n- 点击\"添加\"按钮\n- \"买牛奶\"出现在下方的任务列表中\n- 输入框自动清空，方便输入下一个任务\n## 📝 完整 Prompt ​\n\n复制下面的 Prompt，发送给你的 AI IDE：\n\n`【背景】\n我已经有一个待办清单的静态页面（HTML + CSS）。\n页面包含：标题、输入框、添加按钮、任务列表区域。\n现在需要添加 JavaScript 让它能真正工作。\n\n【当前任务】\n请实现\"添加任务\"功能：\n1. 用户在输入框输入内容后，点击\"添加\"按钮\n2. 输入的内容作为新任务，显示在任务列表中\n3. 每个任务显示：任务内容 + \"完成\"按钮 + \"删除\"按钮\n4. 添加成功后，输入框自动清空\n5. 如果输入框为空，点击添加按钮不应该添加空任务\n\n【技术要求】\n- 使用原生 JavaScript，不使用任何框架\n- 把 JavaScript 代码写在 HTML 文件底部的 <script> 标签内\n- 关键逻辑添加中文注释，帮助我理解代码\n\n【我是初学者】\n请保持代码简单易懂，变量命名要有描述性。`\n## ✅ 预期结果 ​\n发送 Prompt 后，AI 会给你更新后的代码。替换你的 HTML 文件内容后，你应该看到：\n\n测试步骤：\n\n- 在输入框输入\"买牛奶\"\n- 点击\"添加\"按钮\n- 检查结果：检查项预期效果任务列表出现\"买牛奶\"这个任务输入框变成空的按钮每个任务旁边有\"完成\"和\"删除\"按钮\n再测试一次：\n\n- 输入框保持空白，直接点击\"添加\"\n- 预期：不应该添加任何任务\n## 🔍 检查点 ​\n\n在继续之前，确认以下几点：\n\n- [ ] 输入内容后点击添加，任务出现在列表中\n- [ ] 添加后输入框会清空\n- [ ] 空输入不会添加空任务\n- [ ] 可以连续添加多个任务\n- [ ] 页面没有报错（按 F12 打开控制台检查）\n## ⚠️ 常见问题排查 ​\n\n### 问题 1：点击按钮没有任何反应 ​\n\n可能原因：JavaScript 代码没有正确加载，或者按钮没有绑定事件。\n\n排查步骤：\n\n- 按 F12 打开浏览器开发者工具\n- 查看\"控制台\"（Console）标签页\n- 如果有红色报错信息，复制给 AI\n修复 Prompt：\n\n`点击添加按钮没有反应。\n控制台报错信息：[粘贴你看到的红色文字]\n请帮我修复这个问题。`\n### 问题 2：任务添加了但看不到 ​\n可能原因：任务被添加到了错误的位置，或者样式有问题。\n\n修复 Prompt：\n\n`我点击添加后，输入框清空了（说明代码执行了），\n但是任务列表里看不到新任务。\n请检查代码，确保新任务能正确显示在任务列表区域。`\n### 问题 3：输入框没有清空 ​\n修复 Prompt：\n\n`添加任务功能可以用了，任务能显示。\n但有个问题：添加成功后，输入框里的文字没有清空。\n请修复这个问题。`\n### 问题 4：空输入也能添加 ​\n修复 Prompt：\n\n`现在输入框为空时，点击添加按钮也会添加一个空的任务项。\n请添加验证：如果输入框为空或只有空格，不执行添加操作。`\n## 💡 技术小贴士：理解事件处理 ​\n你可能好奇 AI 写的代码是怎么工作的。这里用一个生活类比帮你理解：\n\n场景：你在奶茶店等取餐\n奶茶店场景对应的代码概念叫号屏幕按钮元素\"您的订单好了\"点击事件（click）你听到叫号去取餐事件监听器（addEventListener）拿走奶茶事件处理函数（执行的代码）\nAI 生成的代码大概是这个结构：\njavascript\n`// 1. 找到按钮（就像知道叫号屏在哪）\nconst addButton = document.querySelector('.add-btn');\n\n// 2. 告诉按钮：有人点你的时候，执行这个任务\naddButton.addEventListener('click', function() {\n    // 3. 这里是点击后要做的事情\n    // - 获取输入框的内容\n    // - 创建新的任务元素\n    // - 把任务添加到列表\n    // - 清空输入框\n});`你不需要记住这些代码。只需要知道：告诉 AI 你想要什么效果，AI 会帮你写对应的代码。\n\n## 🎯 完成确认 ​\n\n如果你已经：\n\n- ✅ 能成功添加新任务\n- ✅ 添加后输入框会清空\n- ✅ 空输入不会添加任务\n恭喜！\"添加\"功能已经完成。\n\n接下来，我们让\"删除\"按钮也能工作。\n\n→ 4.3.2 功能二：删除任务",
      "word_count": 2005,
      "estimated_time": 4
    },
    {
      "id": "lesson-118",
      "chapter_id": "chapter-04",
      "lesson_number": 11,
      "title": "4.3.2 功能二：删除任务",
      "content": "# 4.3.2 功能二：删除任务 ​\n\n本步目标：点击任务旁边的\"删除\"按钮，让该任务从列表中消失\n\n买错了东西想划掉？任务完成后想清理？删除功能必不可少。\n\n## 🎯 我们要实现什么 ​\n\n用户的操作流程：\n\n- 看到任务列表中有多个任务\n- 点击某个任务旁边的\"删除\"按钮\n- 该任务从列表中消失\n- 其他任务不受影响\n## 📝 完整 Prompt ​\n\n由于我们已经有了\"添加任务\"的代码，现在是在现有基础上追加功能。复制下面的 Prompt：\n\n`【当前状态】\n添加任务功能已经可以正常使用了。\n现在请在此基础上，添加删除功能。\n\n【需要实现】\n当用户点击某个任务旁边的\"删除\"按钮时：\n1. 只删除这一个任务\n2. 列表中的其他任务保持不变\n3. 删除后不需要确认提示，直接删除即可\n\n【技术要求】\n- 在现有代码基础上添加，不要重写整个文件\n- 保持代码风格一致\n- 关键逻辑添加中文注释`💡 增量式 Prompt\n\n注意这个 Prompt 的开头是\"添加任务功能已经可以正常使用了\"。这样做是告诉 AI 当前的上下文，避免它重写已有的代码。\n\n## ✅ 预期结果 ​\n\n测试步骤：\n\n- 先添加三个任务：任务A、任务B、任务C\n- 点击\"任务B\"旁边的删除按钮\n- 检查结果：检查项预期效果任务B已经消失任务A还在，位置不变任务C还在，位置不变\n再测试：\n\n- 继续点击\"任务A\"的删除按钮\n- 预期：任务A 消失，只剩任务C\n## 🔍 检查点 ​\n\n- [ ] 点击删除按钮，对应任务消失\n- [ ] 删除一个任务不影响其他任务\n- [ ] 可以连续删除多个任务\n- [ ] 删除全部任务后，列表为空（正常显示）\n## ⚠️ 常见问题排查 ​\n\n### 问题 1：点击删除后，所有任务都消失了 ​\n\n可能原因：删除逻辑错误，清空了整个列表而不是单个任务。\n\n修复 Prompt：\n\n`删除功能有问题：我点击一个任务的删除按钮后，所有任务都消失了。\n应该只删除我点击的那一个任务。\n请检查删除逻辑，确保只移除被点击的那个任务元素。`\n### 问题 2：点击删除按钮没反应 ​\n修复 Prompt：\n\n`删除按钮点击没有反应。\n我的任务是通过 JavaScript 动态添加的（不是写死在 HTML 里的）。\n请确保对动态添加的元素也能正确绑定删除事件。`\n### 问题 3：删错了任务（点A删了B） ​\n修复 Prompt：\n\n`删除功能有问题：我点击任务A的删除按钮，结果删掉的是任务B。\n请检查代码，确保删除的是按钮所在的那个任务，而不是其他任务。`\n## 💡 技术小贴士：动态元素的事件绑定 ​\n你可能会遇到一个有趣的问题：为什么页面加载时就存在的按钮能点，但后来添加的任务的按钮点不了？\n\n这就像一个比喻：\n\n你在公司门口贴了一张通知\"有事找前台\"。 后来新来的员工没看到这张通知，所以不知道有事该找谁。\n\n代码里也是这样：如果你在页面加载时就给\"删除按钮\"绑定了事件，那只有当时存在的按钮会响应。后来添加的新任务，它的删除按钮\"没见过\"那个通知。\n\n解决方案叫做\"事件委托\"——不是给每个按钮单独绑定事件，而是告诉它们的\"父容器\"：\n\n\"如果有人点击了你内部的删除按钮，就执行删除操作\"\n\n这样，无论是已有的还是后来添加的任务，点击删除按钮都能正常工作。\n\nAI 通常会自动处理这个问题，但如果遇到\"新添加的任务删除不了\"的情况，把上面的问题 2 的 Prompt 发给 AI 就行。\n\n## 🎯 完成确认 ​\n\n如果你已经：\n\n- ✅ 能删除指定的任务\n- ✅ 删除不影响其他任务\n- ✅ 动态添加的任务也能删除\n删除功能完成。\n\n接下来是最后一个核心功能：标记任务完成。\n\n→ 4.3.3 功能三：标记完成",
      "word_count": 1567,
      "estimated_time": 3
    },
    {
      "id": "lesson-119",
      "chapter_id": "chapter-04",
      "lesson_number": 12,
      "title": "4.3.3 功能三：标记完成",
      "content": "# 4.3.3 功能三：标记完成 ​\n\n本步目标：点击\"完成\"按钮，任务显示为已完成状态；再次点击可以取消\n\n这是待办清单的灵魂功能——看着任务一个个被划掉，成就感满满。\n\n## 🎯 我们要实现什么 ​\n\n用户的操作流程：\n\n- 点击某个任务的\"完成\"按钮\n- 该任务显示为\"已完成\"状态（文字加删除线，颜色变淡）\n- 再次点击，任务恢复为\"未完成\"状态\n- 这是一个开关式的切换\n## 📝 完整 Prompt ​\n\n继续在现有代码基础上添加功能：\n\n`【当前状态】\n添加任务和删除任务功能都已正常工作。\n现在请添加\"标记完成\"功能。\n\n【需要实现】\n当用户点击某个任务的\"完成\"按钮时：\n\n1. 首次点击 - 标记为已完成：\n   - 任务文字添加删除线\n   - 文字颜色变成灰色\n   - 按钮文字从\"完成\"变成\"取消\"\n\n2. 再次点击 - 取消完成状态：\n   - 删除线消失\n   - 文字颜色恢复正常\n   - 按钮文字从\"取消\"变回\"完成\"\n\n【技术要求】\n- 这是一个切换（toggle）效果，可以反复切换\n- 在现有代码基础上添加，保持风格一致\n- 关键逻辑添加中文注释`\n## ✅ 预期结果 ​\n测试步骤：\n\n- 添加一个任务\"写周报\"\n- 点击它的\"完成\"按钮\n- 检查视觉变化：检查项点击前点击后任务文字正常显示有删除线，颜色变灰按钮文字\"完成\"\"取消\"\n- 再次点击同一个按钮\n- 检查是否恢复原状\n## 🔍 检查点 ​\n\n- [ ] 点击完成按钮，任务文字有删除线\n- [ ] 点击完成按钮，文字颜色变灰\n- [ ] 点击完成按钮，按钮文字变成\"取消\"\n- [ ] 再次点击，所有效果恢复原状\n- [ ] 标记完成不影响其他任务\n- [ ] 已完成的任务仍然可以删除\n## ⚠️ 常见问题排查 ​\n\n### 问题 1：点击后没有任何视觉变化 ​\n\n可能原因：CSS 样式没有正确应用，或者类名添加错误。\n\n修复 Prompt：\n\n`点击完成按钮后，代码可能执行了（按钮文字变了），\n但是任务文字没有添加删除线，颜色也没变。\n请检查 CSS 样式是否正确定义，以及是否正确添加到了任务元素上。`\n### 问题 2：无法取消完成状态 ​\n修复 Prompt：\n\n`标记完成功能只能用一次：\n第一次点击可以标记为完成，但再次点击无法取消。\n请修复，让这个按钮能够切换状态（toggle）。`\n### 问题 3：按钮文字没有变化 ​\n修复 Prompt：\n\n`点击完成后，任务样式变了，但按钮文字一直是\"完成\"，没有变成\"取消\"。\n请在切换状态的同时，也切换按钮的文字。`\n### 问题 4：点一个任务，其他任务也变了 ​\n修复 Prompt：\n\n`点击任务A的完成按钮，结果任务B和任务C也被标记为完成了。\n请修复，确保只修改被点击的那个任务的状态。`\n## 💡 技术小贴士：状态切换的\"开关灯\"思维 ​\n\"标记完成\"功能本质上是一个状态切换，就像开关灯：\n灯的状态对应任务状态按下开关后灯灭（关）未完成变成开（完成）灯亮（开）已完成变成关（未完成）\n在代码里，这通常通过给元素添加或移除一个\"已完成\"的标记（叫做 class）来实现：\n\n`点击前：<div class=\"task\">买牛奶</div>\n点击后：<div class=\"task completed\">买牛奶</div>\n                    ↑ 添加了这个标记\n\n再次点击：<div class=\"task\">买牛奶</div>\n                          ↑ 标记被移除`CSS 里预先定义好了 `.completed` 的样式（删除线、灰色），所以添加这个标记后，样式就自动生效了。\n\n这种\"通过添加/移除标记来改变样式\"的方式，是前端开发中非常常见的模式。\n\n## 🎉 三大核心功能完成 ​\n\n如果你已经：\n\n- ✅ 添加任务 - 能用\n- ✅ 删除任务 - 能用\n- ✅ 标记完成 - 能用\n恭喜！你的待办清单已经具备了最核心的功能。\n\n现在的状态：这是一个\"能用\"的待办清单了。你可以：\n\n- 添加今天要做的事情\n- 做完一件划掉一件\n- 不需要的任务可以删除\n但你可能对某些细节不太满意，比如：\n\n- 样式想再调整一下\n- 想让已完成的任务自动移到底部\n- 想添加一个\"清空已完成\"的按钮\n下一节，我们来学习如何有效地与 AI 沟通这些调整需求。\n\n→ 4.3.4 迭代优化的艺术",
      "word_count": 1864,
      "estimated_time": 3
    },
    {
      "id": "lesson-120",
      "chapter_id": "chapter-04",
      "lesson_number": 13,
      "title": "4.3.4 迭代优化的艺术",
      "content": "# 4.3.4 迭代优化的艺术 ​\n\n本节目标：学会如何有效地追问，让 AI 把\"能用\"变成\"好用\"\n\n到目前为止，你的待办清单已经\"能用\"了。但可能有些地方不太满意：\n\n- 样式想再调整一下\n- 交互细节想优化\n- 想添加一些小功能\n这时候，迭代追问就派上用场了。\n\n## 为什么 AI 第一次输出往往不完美 ​\n\n这不是 AI 的问题，也不是你的问题。原因很简单：\n你脑海中的画面AI 理解的内容实际输出100% 细节70% 文字描述60% 代码实现\n信息在传递过程中必然会有损失。所以第一次输出不完美是正常的，迭代追问才是常态。\n\n📖 回顾第三章\n\n这正是第三章 3.5 节\"迭代对话的艺术\"中讲到的核心观点。本节是那些原则的实战演练。\n\n## 追问的三要素 ​\n\n有效的追问需要包含三个信息：\n要素说明示例现状现在是什么样\"点击完成后，任务还在原来的位置\"期望你想要什么样\"我希望已完成的任务自动移到列表底部\"差异具体差在哪\"现在位置不变，我要它移到底部\"\n## 真实迭代对话示例 ​\n\n假设你对\"标记完成\"功能不太满意，想做一些调整。看看这个三轮对话：\n\n### 第一轮：发现问题 ​\n\n你发现：已完成的任务和未完成的混在一起，不好区分。\n\n你发送：\n\n`完成功能可以用了，但我有个改进想法：\n我希望已完成的任务能自动移到列表底部，\n这样未完成的任务始终显示在上面，更容易看到。\n请帮我实现这个功能。`AI 可能的回应：修改代码，实现了自动排序。\n\n### 第二轮：继续调整 ​\n\n你测试后发现：排序是有了，但新添加的任务出现在了列表最后面，不方便看。\n\n你发送：\n\n`排序功能实现了，但有个新问题：\n当前情况：新添加的任务出现在列表最后面\n我希望的效果：新任务应该出现在未完成任务的最上面\n请调整一下，让新任务总是显示在最顶部（已完成的任务之前）。`\n### 第三轮：细节打磨 ​\n你发送：\n\n`排序逻辑现在正确了。\n还想做一个小优化：能否添加一个\"清空已完成\"按钮？\n点击后可以一次性删除所有已完成的任务。\n按钮可以放在列表底部，只在有已完成任务时才显示。`三轮对话后，你得到了一个比最初版本好用很多的待办清单。\n\n## 有效反馈 vs 无效反馈 ​\n无效反馈问题在哪有效反馈\"不对，再改改\"AI 不知道哪里不对\"添加后任务没显示，请检查...\"\"样式不好看\"太模糊，AI 无从下手\"标题字体太小，请改成24px\"\"感觉怪怪的\"没有具体信息\"按钮点击后，文字变化有延迟\"\"能不能更好一点\"什么叫\"更好\"？\"希望按钮有悬停效果，颜色加深\"\n核心原则：你的描述越具体，AI 修改得越准确。\n\n## 追问时的实用句式 ​\n\n收集一些好用的句式，遇到问题时可以直接套用：\n\n### 描述问题 ​\n\n`当前情况：[现在是什么样]\n我期望的效果：[想要什么样]\n请帮我修改。`\n### 请求添加功能 ​\n\n```\n现有功能运行正常。\n我想在此基础上添加一个新功能：[描述功能]\n具体来说：[列出细节]\n```\n\n### 调整样式 ​\n\n```\n功能正常，但样式想调整：\n- 当前：[现在的样式]\n- 期望：[想要的样式]\n请只修改样式，不要改变功能逻辑。\n```\n\n### 修复 Bug ​\n\n```\n发现一个问题：\n- 操作步骤：[1、2、3]\n- 期望结果：[应该发生什么]\n- 实际结果：[实际发生了什么]\n请帮我修复。\n```\n\n## 知道什么时候换个思路 ​\n如果同一个问题追问了 3 次还没解决，考虑：\n情况建议AI 似乎理解错了需求换一种描述方式，用更具体的例子问题太复杂把需求拆成更小的步骤，一步步来AI 反复给出类似的错误代码开始一个新对话，把需求重新整理后发送超出了当前技术范围这个功能可能需要更复杂的实现，考虑暂时搁置\n## 什么时候开始新对话 ​\n\n有时候，与其在旧对话里继续追问，不如开始一个新对话：\n场景建议对话已经很长（超过 10 轮）AI 可能\"失忆\"，开新对话需求发生了较大变化把新需求整理清楚，开新对话代码改得面目全非保存当前可用版本，开新对话从头优化AI 似乎陷入了某种错误循环开新对话，换一种描述方式\n开始新对话时的模板：\n\n`我正在开发一个待办清单网页。\n\n【当前状态】\n- 已实现：添加任务、删除任务、标记完成\n- 现有代码运行正常\n\n【本次目标】\n我想优化 [具体功能]，具体需求：\n1. [需求1]\n2. [需求2]\n\n【现有代码】\n[粘贴当前代码]`\n## 本节核心要点 ​\n\n- ✓ 第一次输出不完美是正常的，迭代才是常态\n- ✓ 有效追问需要三要素：现状 + 期望 + 差异\n- ✓ 描述越具体，AI 修改得越准确\n- ✓ 追问 3 次还没解决，考虑换思路或开新对话\n## 练习建议 ​\n趁热打铁，尝试用本节学到的技巧，对你的待办清单做一些优化：\n\n- [ ] 调整一个你不满意的样式\n- [ ] 添加一个你想要的小功能\n- [ ] 如果有 Bug，尝试用\"描述问题\"的句式让 AI 修复\n做完后，进入下一节确认所有功能正常。\n\n→ 4.3.5 阶段性成果检查",
      "word_count": 2108,
      "estimated_time": 4
    },
    {
      "id": "lesson-121",
      "chapter_id": "chapter-04",
      "lesson_number": 14,
      "title": "4.3.5 阶段性成果检查",
      "content": "# 4.3.5 阶段性成果检查 ​\n\n本步目标：确认第二轮所有功能正常，准备进入下一轮\n\n## 第二轮完成检查清单 ​\n\n在进入数据存储（4.4）之前，请确认以下功能都能正常工作：\n\n### 添加任务 ​\n\n- [ ] 输入内容后点击添加，任务出现在列表中\n- [ ] 添加后输入框自动清空\n- [ ] 空输入不会添加空任务\n- [ ] 可以连续添加多个任务\n### 删除任务 ​\n\n- [ ] 点击删除按钮，对应任务消失\n- [ ] 删除一个任务不影响其他任务\n- [ ] 新添加的任务也能正常删除\n### 标记完成 ​\n\n- [ ] 点击完成按钮，任务有视觉变化（删除线、变灰）\n- [ ] 再次点击可以取消完成状态\n- [ ] 完成/取消操作可以反复进行\n- [ ] 已完成的任务仍然可以删除\n### 整体检查 ​\n\n- [ ] 按 F12 打开控制台，没有红色报错信息\n- [ ] 三个功能可以配合使用，互不影响\n## 🎉 第二轮完成！ ​\n\n恭喜你！经过这一轮，你的待办清单已经从\"静态页面\"变成了\"可交互应用\"。\n\n### 你完成了什么 ​\n功能第一轮结束时第二轮结束时添加任务❌ 点击无反应✅ 能正常添加删除任务❌ 点击无反应✅ 能正常删除标记完成❌ 点击无反应✅ 能正常切换\n### 回顾：本轮用到了什么 ​\n来源你用到的内容第二章 2.3 节MVP 功能定义（P0 功能清单）第三章 3.2 节S.C.F. 精简框架写 Prompt第三章 3.5 节迭代对话追问技巧第四章 4.2 节在静态页面基础上添加功能\n这就是 Vibe Coding 的完整工作流：想清楚 → 说明白 → 让 AI 做 → 调整优化。\n\n### 当前状态总结 ​\n功能状态备注页面显示✅ 正常添加任务✅ 可用删除任务✅ 可用标记完成✅ 可用刷新后数据还在❌ 数据会丢失下一轮解决\n## 发现问题了吗？ ​\n\n现在试试：刷新一下页面（按 F5 或 Ctrl+R）。\n\n你会发现：所有任务都消失了。\n\n这是正常的。目前我们的待办清单只\"活\"在浏览器的内存里，就像在白板上写字——关掉白板，字就没了。\n\n下一轮，我们要解决这个问题：让数据能够保存下来，即使刷新页面、关闭浏览器，你的任务列表也不会丢失。\n\n💡 遇到问题？\n\n如果某个功能不正常，先回到对应的小节查看\"常见问题排查\"。\n\n如果是看不懂的报错，可以先跳到 4.5 Debug 实战 学习如何让 AI 帮你修复。\n\n也可以继续往下学，遇到问题随时回来解决。\n\n## 下一步预告 ​\n\n第三轮是\"存储层\"——让你的待办清单具备\"记忆\"能力：\n\n- 关闭浏览器，数据不丢失\n- 第二天打开，昨天的任务还在\n- 就像真正的应用一样\n准备好了吗？\n\n→ 4.4 第三轮：让数据活起来",
      "word_count": 1160,
      "estimated_time": 3
    },
    {
      "id": "lesson-122",
      "chapter_id": "chapter-04",
      "lesson_number": 15,
      "title": "4.4.1 为什么需要数据存储",
      "content": "# 4.4.1 为什么需要数据存储 ​\n\n本步目标：理解数据存储的必要性，了解 localStorage 的基本概念\n\n## 小李的困惑 ​\n\n还记得第二章的小李吗？他兴冲冲地完成了待办清单的交互功能，添加了几个任务，准备明天继续用。\n\n第二天打开电脑，打开页面——任务列表空空如也。\n\n\"我的任务呢？\"小李懵了。\n\n这不是 Bug，而是因为小李的待办清单还缺少最后一个关键能力：数据存储。\n\n## 用生活类比理解 ​\n\n想象两种记录方式：\n场景类比结果在沙滩上写字数据只存在浏览器内存中浪一来（刷新页面），字就没了在石板上刻字数据存储到 localStorage风吹雨打（刷新、关闭），字还在\n目前我们的待办清单就像在沙滩上写字。本轮要做的，就是把它变成\"刻在石板上\"。\n\n## 网页数据存储的几种方式 ​\n方式存在哪里特点本章是否使用localStorage浏览器本地简单、免费、无需配置✅ 使用sessionStorage浏览器本地关闭标签页就没了❌ 不适合云数据库远程服务器多设备同步，需要后端❌ 进阶篇内容\n## 为什么选择 localStorage？ ​\n\n对于个人工具类项目，localStorage 是最佳起点：\n优势说明零配置浏览器原生支持，不需要安装任何东西持久化关闭浏览器、重启电脑，数据依然存在容量足够约 5MB 空间，存几千条任务都没问题隐私安全数据只存在你自己的电脑上学习成本低只需要两个方法：保存和读取\n## localStorage 的局限性 ​\n\n当然，localStorage 也有不适用的场景：\n场景为什么不适合解决方案多设备同步数据只存在当前浏览器需要云数据库（进阶篇）团队协作别人看不到你的数据需要后端服务（进阶篇）大量数据超过 5MB 会报错需要专业数据库\n进阶预告\n\n在进阶篇中，我们会学习如何使用 Supabase 等云数据库服务，实现多设备同步和数据备份。但对于个人工具的第一版来说，localStorage 完全够用。\n\n## 本节检查点 ​\n\n在继续之前，确认你理解了：\n\n- [ ] 目前待办清单的数据为什么会在刷新后消失\n- [ ] localStorage 是什么（浏览器提供的本地存储空间）\n- [ ] 为什么我们选择 localStorage 作为第一步\n理解了这些概念，接下来就可以动手实现了。\n\n→ 4.4.2 使用本地存储（localStorage）",
      "word_count": 1010,
      "estimated_time": 3
    },
    {
      "id": "lesson-123",
      "chapter_id": "chapter-04",
      "lesson_number": 16,
      "title": "4.4.2 使用本地存储（localStorage）",
      "content": "# 4.4.2 使用本地存储（localStorage） ​\n\n本步目标：让 AI 帮我们实现数据的自动保存和读取\n\n本节是数据存储的核心实现。我们会分两步完成：先实现「保存」，再实现「读取」。\n\n## 技术小贴士：理解 localStorage ​\n\n在开始之前，用一个生活类比帮你建立直觉：\n生活场景对应概念快递寄存柜localStorage柜子编号（如 A-15）存储的 key（键名）柜子里的包裹存储的 value（值）存包裹`localStorage.setItem(key, value)`取包裹`localStorage.getItem(key)`\n就像快递柜一样，localStorage 可以帮你\"寄存\"数据，下次来还能取回来。\n\n注意\n\nlocalStorage 只能存储文本（字符串）。如果要存储任务列表这样的复杂数据，需要先把它转换成文本格式（JSON），取出来时再转回去。这个转换 AI 会自动帮你处理。\n\n## 步骤 1：添加保存和读取功能 ​\n\n我们用一个完整的 Prompt，让 AI 同时实现保存和读取逻辑。\n\n### 完整 Prompt ​\n\n复制下面的 Prompt，发送给你的 AI IDE：\n\n`【背景】\n我有一个待办清单网页，目前已经实现了添加、删除、标记完成的功能。\n但刷新页面后，所有任务都会消失。\n我需要添加数据持久化功能，让任务能够保存下来。\n\n【当前任务】\n请帮我实现 localStorage 数据存储功能：\n\n1. 保存功能：\n   - 每当任务列表发生变化（添加、删除、完成状态改变）时\n   - 自动将当前任务列表保存到 localStorage\n   - 使用 \"todoList\" 作为存储的 key 名\n\n2. 读取功能：\n   - 页面加载时，自动从 localStorage 读取之前保存的任务\n   - 如果有保存的数据，用它来初始化任务列表\n   - 如果没有保存的数据（第一次使用），显示空列表\n\n3. 数据格式：\n   - 每个任务需要保存：任务内容、完成状态\n   - 使用 JSON 格式存储\n\n【技术要求】\n- 使用原生 JavaScript\n- 关键逻辑添加中文注释\n- 确保保存和读取的数据格式一致\n\n【我是初学者】\n请保持代码简洁易懂，并解释关键的保存/读取逻辑。`\n### 预期结果 ​\n发送 Prompt 后，AI 会更新你的代码。替换文件内容后：\n\n- 表面上看起来没变化 - 页面还是和之前一样\n- 但数据已经在自动保存了 - 每次操作都会触发保存\n### 如何确认保存生效？ ​\n\n用浏览器开发者工具查看：\n\n- 按 F12 打开开发者工具\n- 点击顶部的 Application（应用程序）标签\n- 在左侧找到 Storage > Local Storage\n- 点击你的网页地址\n- 你应该能看到一条 key 为 `todoList` 的数据\n截图对照\n\n如果操作正确，你会看到类似这样的界面：\n\n- 左侧：Local Storage > `file://` 或你的网址\n- 右侧：Key 列显示 `todoList`，Value 列显示类似 `[{\"text\":\"买牛奶\",\"completed\":false}]` 的内容\n### 检查点 ​\n\n在继续之前，确认以下几点：\n\n- [ ] 代码更新后，页面能正常显示\n- [ ] 添加一个任务，开发者工具中能看到 `todoList` 数据\n- [ ] 再添加一个任务，`todoList` 的值会更新\n- [ ] 标记一个任务为完成，`todoList` 的值会更新\n- [ ] 删除一个任务，`todoList` 的值会更新\n### 常见问题排查 ​\n\n#### 问题 1：开发者工具中看不到 Local Storage ​\n\n可能原因：你可能打开的是 Console 或其他标签页。\n\n解决方法：\n\n- 确保点击的是 Application 标签（不是 Elements、Console 等）\n- 如果找不到 Application，试试点击 >> 展开更多标签\n#### 问题 2：Local Storage 中没有 todoList ​\n\n可能原因：保存逻辑没有正确执行。\n\n修复 Prompt：\n\n`我按照你的代码修改了，但是在浏览器的 Local Storage 中看不到 todoList 数据。\n请检查保存逻辑，确保每次任务变化时都会调用 localStorage.setItem。\n给我检查后的完整代码。`\n#### 问题 3：todoList 的值是 undefined 或 [object Object] ​\n可能原因：数据没有正确转换为 JSON 字符串。\n\n修复 Prompt：\n\n`Local Storage 中的 todoList 值显示为 [object Object] 或 undefined。\n请确保保存时使用 JSON.stringify 转换数据，读取时使用 JSON.parse 解析数据。\n给我修复后的完整代码。`\n#### 问题 4：页面报错，功能不正常 ​\n排查步骤：\n\n- 按 F12 打开开发者工具\n- 点击 Console 标签\n- 查看红色的报错信息\n修复 Prompt：\n\n`更新代码后页面报错了。\n控制台报错信息：[粘贴你看到的红色报错内容]\n请帮我修复这个问题。`\n## 步骤 2：验证刷新后数据恢复 ​\n保存功能确认正常后，现在验证最关键的部分——刷新页面后数据是否还在。\n\n### 验证流程 ​\n\n- 确保当前有 1-2 个任务（如果没有，先添加几个）\n- 标记其中一个为已完成\n- 刷新页面（按 F5 或点击浏览器刷新按钮）\n- 检查结果\n### 预期结果 ​\n检查项刷新前刷新后（预期）任务数量2 个2 个（不变）任务内容\"买牛奶\"、\"写报告\"相同（不变）完成状态\"买牛奶\"已完成仍然是已完成\n### 如果刷新后数据丢失 ​\n\n可能原因：读取逻辑没有正确执行。\n\n修复 Prompt：\n\n`保存功能正常（我能在 Local Storage 中看到数据），\n但刷新页面后，任务列表变空了，没有从 localStorage 读取数据。\n\n请检查页面加载时的读取逻辑，确保：\n1. 页面加载时会调用 localStorage.getItem(\"todoList\")\n2. 读取到的数据会正确解析并显示在页面上\n\n给我修复后的完整代码。`\n### 检查点 ​\n\n- [ ] 刷新页面后，之前添加的任务还在\n- [ ] 刷新页面后，任务的完成状态也保留了\n- [ ] 关闭浏览器标签页，重新打开文件，任务还在\n## 技术小贴士：JSON 是什么？ ​\n你可能注意到 AI 的代码中使用了 `JSON.stringify` 和 `JSON.parse`。这里简单解释一下：\n方法作用类比`JSON.stringify`把数据转换成文本把衣服叠好装进行李箱`JSON.parse`把文本转换回数据从行李箱里把衣服拿出来\n因为 localStorage 只能存储文本，所以：\n\n- 存的时候：先用 `JSON.stringify` 把任务列表\"打包\"成文本\n- 取的时候：再用 `JSON.parse` 把文本\"解包\"还原成任务列表\n你不需要记住这些，只需要知道 AI 生成的代码中会包含这两个步骤。\n\n## 本步完成确认 ​\n\n如果你已经：\n\n- ✅ 在开发者工具中能看到 `todoList` 数据\n- ✅ 刷新页面后任务还在\n- ✅ 完成状态也能保留\n恭喜！数据存储功能已经实现。接下来我们做更完整的测试。\n\n→ 4.4.3 测试数据持久化",
      "word_count": 3179,
      "estimated_time": 6
    },
    {
      "id": "lesson-124",
      "chapter_id": "chapter-04",
      "lesson_number": 17,
      "title": "4.4.3 测试数据持久化",
      "content": "# 4.4.3 测试数据持久化 ​\n\n本步目标：通过多种场景验证数据存储功能是否完善\n\n在 4.4.2 中，我们已经初步验证了刷新后数据还在。本节进行更全面的测试，确保各种情况下数据都能正确保存。\n\n## 五步验证法 ​\n\n按照以下步骤，系统性地测试数据持久化功能：\n\n### 步骤 1：准备测试数据 ​\n\n- 如果当前有任务，先全部删除（从一个干净的状态开始）\n- 添加 3 个任务： \"学习 Vibe Coding\"\n- \"完成待办清单项目\"\n- \"庆祝一下\"\n### 步骤 2：修改任务状态 ​\n\n- 将 \"学习 Vibe Coding\" 标记为已完成\n- 确认它有视觉变化（删除线或变灰）\n### 步骤 3：刷新页面测试 ​\n\n- 按 F5 或 Ctrl+R（Mac: Cmd+R）刷新页面\n- 检查结果：检查项预期结果任务数量3 个\"学习 Vibe Coding\"仍然是已完成状态其他两个任务仍然是未完成状态\n### 步骤 4：关闭标签页测试 ​\n\n这是更严格的测试：\n\n- 完全关闭当前浏览器标签页\n- 重新打开 HTML 文件（或重新访问网址）\n- 检查结果：任务列表应该和关闭前一样\n### 步骤 5：删除操作测试 ​\n\n- 删除 \"庆祝一下\" 这个任务\n- 刷新页面\n- 检查结果：应该只剩 2 个任务，\"庆祝一下\" 不应该回来\n## 如何查看 localStorage 中的原始数据 ​\n\n有时候需要直接查看存储的数据内容，可以这样操作：\n\n- 按 F12 打开开发者工具\n- 点击 Application 标签\n- 展开左侧的 Storage > Local Storage\n- 点击你的网页地址（如 `file://` 或 `localhost`）\n- 在右侧找到 Key 为 `todoList` 的那一行\n- 双击 Value 列可以查看完整内容\n正确的数据格式示例：\njson\n`[\n  {\"text\": \"学习 Vibe Coding\", \"completed\": true},\n  {\"text\": \"完成待办清单项目\", \"completed\": false}\n]`提示\n\n如果你的数据格式和上面不完全一样也没关系，只要包含任务内容和完成状态两个信息即可。不同的 AI 可能会使用不同的属性名（如 `content` 代替 `text`，`done` 代替 `completed`）。\n\n## 测试检查清单 ​\n\n完成所有测试后，确认以下项目都通过：\n\n- [ ] 添加任务后，刷新页面任务还在\n- [ ] 删除任务后，刷新页面任务不会回来\n- [ ] 标记完成后，刷新页面完成状态保留\n- [ ] 取消完成后，刷新页面状态正确更新\n- [ ] 关闭标签页再打开，数据完整保留\n- [ ] 在开发者工具中能看到 `todoList` 数据\n## 常见问题排查 ​\n\n### 问题 1：刷新后所有任务消失 ​\n可能原因排查方法保存逻辑没执行检查开发者工具中有没有 `todoList`读取逻辑没执行有 `todoList` 但页面空白数据格式错误`todoList` 值是乱码或 undefined\n通用修复 Prompt：\n\n`刷新页面后任务都消失了。\n我在开发者工具的 Local Storage 中 [能看到/看不到] todoList 数据。\n请帮我检查保存和读取逻辑，确保：\n1. 每次任务变化都会保存到 localStorage\n2. 页面加载时会读取并显示保存的数据\n给我修复后的完整代码。`\n### 问题 2：任务内容在，但完成状态丢失 ​\n可能原因：保存时没有包含 `completed` 状态。\n\n修复 Prompt：\n\n`刷新页面后任务内容还在，但所有任务都变成未完成状态了。\n请检查保存逻辑，确保每个任务对象都包含完成状态（completed 或 done 属性）。\n给我修复后的完整代码。`\n### 问题 3：删除的任务刷新后又回来了 ​\n可能原因：删除操作后没有更新 localStorage。\n\n修复 Prompt：\n\n`我删除了一个任务，但刷新页面后它又出现了。\n请确保删除任务后会立即更新 localStorage 中的数据。\n给我修复后的完整代码。`\n### 问题 4：控制台报错 JSON 相关错误 ​\n常见报错如：\n\n- `SyntaxError: Unexpected token`\n- `JSON.parse: unexpected character`\n修复 Prompt：\n\n`控制台报错：[粘贴具体报错信息]\n这似乎是 JSON 解析相关的问题。\n请检查 localStorage 数据的保存和读取逻辑，确保格式正确。\n给我修复后的完整代码。`\n## 本节检查点 ​\n在继续之前，确认：\n\n- [ ] 完成了五步验证法的所有测试\n- [ ] 所有测试场景都通过\n- [ ] 没有控制台报错\n全部通过后，进入最后的完整功能验证。\n\n→ 4.4.4 完整功能验证",
      "word_count": 2071,
      "estimated_time": 4
    },
    {
      "id": "lesson-125",
      "chapter_id": "chapter-04",
      "lesson_number": 18,
      "title": "4.4.4 完整功能验证与阶段回顾",
      "content": "# 4.4.4 完整功能验证与阶段回顾 ​\n\n本步目标：完成最终验收测试，回顾本轮学习成果\n\n## 最终验收测试 ​\n\n在结束本轮之前，让我们做一次完整的端到端测试，确保所有功能协同工作。\n\n### 测试流程 ​\n\n请按顺序执行以下操作：\n步骤操作预期结果1清空所有现有任务任务列表变空2添加任务 \"买牛奶\"任务出现在列表中3添加任务 \"写周报\"列表中有 2 个任务4添加任务 \"学习 Vibe Coding\"列表中有 3 个任务5标记 \"买牛奶\" 为已完成该任务有视觉变化6删除 \"写周报\"列表中剩 2 个任务7刷新页面任务状态完全保留8关闭并重新打开页面任务状态完全保留\n### 最终检查清单 ​\n\n刷新/重新打开后，确认以下状态：\n\n- [ ] 任务数量：2 个\n- [ ] \"买牛奶\"：显示已完成状态（有删除线或变灰）\n- [ ] \"学习 Vibe Coding\"：显示未完成状态\n- [ ] \"写周报\"：已被删除，不应该出现\n- [ ] 控制台无报错\n- [ ] 添加、删除、完成功能仍然正常工作\n## 第三轮完成 ​\n\n恭喜你！经过三轮迭代，你的待办清单已经从一个静态页面，变成了一个真正可用的个人工具。\n\n### 你完成了什么 ​\n功能4.2 结束时4.3 结束时4.4 结束时（现在）页面显示✅ 静态页面✅ 静态页面✅ 静态页面添加任务❌ 不可用✅ 可用✅ 可用删除任务❌ 不可用✅ 可用✅ 可用标记完成❌ 不可用✅ 可用✅ 可用数据持久化❌ 刷新丢失❌ 刷新丢失✅ 刷新保留\n从\"空壳\"到\"能用\"，再到\"好用\"——这就是渐进式开发的力量。\n\n### 本轮用到了什么 ​\n来源内容用在哪里第二章 2.3 节MVP 功能定义确定本轮只做 localStorage第三章 3.2 节S.C.F. 精简框架写存储功能的 Prompt第三章 3.5 节迭代对话技巧排查和修复问题第三章 3.6 节验证 AI 输出测试数据是否正确保存\n### 本轮技能点 ​\n\n通过这一轮，你学到了：\n技能说明数据持久化概念理解为什么需要存储、存储在哪里localStorage 使用浏览器本地存储的基本用法JSON 序列化基础数据如何\"打包\"和\"解包\"（虽然 AI 帮你写了代码）数据验证思维知道如何检查数据是否正确保存开发者工具使用学会查看 Application > Local Storage\n### 与第二章小李案例的呼应 ​\n\n还记得第二章小李的 MVP 功能定义吗？\n优先级功能状态P0添加任务✅ 已完成（4.3）P0显示任务列表✅ 已完成（4.2）P0删除任务✅ 已完成（4.3）P0标记完成✅ 已完成（4.3）P1刷新后数据保留✅ 已完成（4.4）P2任务分类留给进阶版P2截止日期留给进阶版\n小李的 MVP 核心功能（P0 + P1），现在全部实现了。\n\n## 当前项目状态 ​\n\n你现在拥有的是一个：\n\n- 功能完整的待办清单：增删改查 + 数据持久化\n- 可以真正使用的个人工具：刷新不丢、关机不丢\n- 你亲手做出来的第一个 AI 编程项目\n这不是一个练习，而是一个真正能用的东西。\n\n进阶预告\n\n在进阶篇中，我们会学习：\n\n- 使用云数据库（如 Supabase）实现多设备同步\n- 添加用户登录，每个人有自己的任务列表\n- 部署到互联网，让别人也能访问\n但对于个人使用来说，你现在做的这个版本已经完全够用了。\n\n## 遇到问题怎么办？ ​\n\n在实际开发中，遇到报错是常态。如果你在本轮遇到了无法解决的问题，不用担心——下一节专门讲如何 Debug。\n\n如果有问题\n\n先不要卡住，继续往下学。4.5 节会教你系统性的排查方法，学完后可以回来解决遗留问题。\n\n## 下一步 ​\n\n核心功能已经完成，但在开发过程中你可能遇到过一些报错。\n\n下一节，我们专门学习当 AI 代码出错时该怎么办——这是 Vibe Coding 的必备技能。\n\n→ 4.5 Debug 实战",
      "word_count": 1639,
      "estimated_time": 3
    },
    {
      "id": "lesson-126",
      "chapter_id": "chapter-04",
      "lesson_number": 19,
      "title": "4.5.1 常见错误类型速查",
      "content": "# 4.5.1 常见错误类型速查 ​\n\n经过本节学习，你将掌握：\n\n- 区分四类常见错误：语法错误、运行时错误、逻辑错误、样式错误\n- 阅读浏览器控制台的报错信息\n- 根据错误类型选择正确的排查方向\n## 打开控制台：你的 Debug 第一步 ​\n\n控制台是浏览器内置的「错误报告器」。当代码出问题时，它会告诉你哪里错了。\n系统打开方式Windows按 `F12`，点击 Console 标签Mac按 `Cmd + Option + J`\n打开后，你会看到一个面板。如果有红色文字，那就是错误信息。\n\n## 如何阅读报错信息 ​\n\n控制台的报错信息看起来像这样：\n\n`Uncaught TypeError: Cannot read properties of undefined (reading 'push')\n    at addTask (index.html:45:15)\n    at HTMLButtonElement.<anonymous> (index.html:52:5)`这段信息告诉你三件事：\n组成部分含义上面例子中的值错误类型这是什么类型的错误`TypeError`错误描述具体出了什么问题试图读取 undefined 的 'push' 属性错误位置错误发生在哪个文件的哪一行`index.html` 第 45 行\n有了这些信息，你就能告诉 AI 准确的问题描述。\n\n## 四类常见错误 ​\n\n### 第一类：语法错误（SyntaxError） ​\n\n什么是语法错误：代码写法不符合 JavaScript 的语法规则，就像写作文时标点符号用错了。\n\n典型报错：\n\n`Uncaught SyntaxError: Unexpected token '}'`\n```\nUncaught SyntaxError: missing ) after argument list\n```\n常见原因：\n原因示例括号不匹配`function test( { }` 少了一个 `)`引号不匹配`let name = \"小李;` 少了结束引号多了或少了逗号`{name: \"小李\" age: 20}` 少了逗号关键字拼写错误`funtion` 写成了 `funtion`\n快速定位：语法错误通常会指向具体行号，检查那一行及其附近的括号、引号、逗号。\n\n修复 Prompt 模板：\n\n`控制台报错：SyntaxError: [具体错误信息]\n错误位置：第 X 行\n请帮我检查这一行附近的语法问题，找出缺失或多余的符号。`\n### 第二类：运行时错误（TypeError / ReferenceError） ​\n什么是运行时错误：代码语法没问题，但运行时出了问题。就像食谱步骤正确，但冰箱里没有需要的食材。\n\n常见的运行时错误：\n错误类型含义典型报错TypeError对一个值进行了不恰当的操作`Cannot read properties of undefined`ReferenceError使用了一个不存在的变量`xxx is not defined`\n待办清单中的典型场景：\n\n场景 1：变量是 undefined\n\n`Uncaught TypeError: Cannot read properties of undefined (reading 'push')`原因：试图对一个还没有值的变量调用方法。比如任务列表 `tasks` 还没初始化就调用了 `tasks.push()`。\n\n场景 2：函数未定义\n\n`Uncaught ReferenceError: addTask is not defined`原因：调用了一个还没有定义的函数。可能是函数名拼写错误，或者代码顺序不对。\n\n快速定位：查看报错信息中提到的变量名或方法名，检查它是否被正确定义和初始化。\n\n修复 Prompt 模板：\n\n`控制台报错：TypeError: Cannot read properties of undefined (reading 'push')\n错误位置：addTask 函数第 X 行\n\n请帮我检查：\n1. 相关变量是否被正确初始化\n2. 是否存在拼写错误\n3. 代码执行顺序是否正确`\n### 第三类：逻辑错误（无报错但行为异常） ​\n什么是逻辑错误：代码能运行，控制台也没有红色报错，但结果不是你想要的。这是最难排查的一类错误。\n\n待办清单中的典型场景：\n现象可能原因点击添加按钮没反应事件监听器没有正确绑定任务添加了但看不到任务被添加到了错误的位置刷新后数据丢失localStorage 保存逻辑没有执行标记完成但刷新后恢复完成状态没有保存到 localStorage删除按钮删错了任务任务索引计算错误\n快速定位：由于没有报错信息，需要用「排除法」逐步缩小问题范围。\n\n修复 Prompt 模板：\n\n`我遇到了一个逻辑问题：\n【现象】点击添加按钮后，任务没有出现在列表中\n【期望】任务应该出现在任务列表区域\n【已确认】控制台没有报错信息\n\n请帮我检查：\n1. 事件监听器是否正确绑定到按钮\n2. 添加任务的函数是否被调用\n3. 新任务是否被正确添加到页面的任务列表区域`\n### 第四类：样式错误（CSS 问题） ​\n什么是样式错误：功能正常，但页面显示不对。元素错位、颜色不对、布局混乱。\n\n待办清单中的典型场景：\n现象可能原因整个页面样式消失CSS 代码被误删或有语法错误任务列表挤成一团flex 或 grid 布局设置错误按钮看不见颜色与背景相同，或元素被隐藏手机上显示异常缺少响应式设计\n快速定位：使用浏览器的「元素检查」功能（右键 → 检查），查看元素的样式是否生效。\n\n修复 Prompt 模板：\n\n`页面样式出现问题：\n【现象】任务列表区域的样式全部消失，变成了纯文本\n【期望】任务应该有背景色、边框和合理的间距\n\n请帮我检查 CSS 代码，确保：\n1. 样式选择器正确匹配 HTML 元素\n2. CSS 语法没有错误\n3. 关键样式属性没有被覆盖`\n## 错误类型速查表 ​\n遇到问题时，用这张表快速判断属于哪类错误：\n判断依据错误类型下一步行动控制台有 `SyntaxError`语法错误检查报错行附近的括号、引号、逗号控制台有 `TypeError` 或 `ReferenceError`运行时错误检查报错中提到的变量是否正确定义控制台没有报错，但功能不对逻辑错误描述现象和期望，让 AI 帮你排查功能正常，但显示不对样式错误用「检查元素」查看 CSS 是否生效\n## 本节要点 ​\n\n- 打开控制台是 debug 的第一步，红色文字就是错误信息\n- 报错信息包含三个关键部分：错误类型、错误描述、错误位置\n- 四类错误各有特征：语法错误有具体位置、运行时错误提到变量名、逻辑错误没有报错、样式错误看页面显示\n- 根据错误类型选择对应的排查方向，能大大提高修复效率\n接下来，我们学习如何用 AI 系统化地修复这些错误。\n\n→ 4.5.2 用 AI 帮你修 AI 的代码",
      "word_count": 2899,
      "estimated_time": 5
    },
    {
      "id": "lesson-127",
      "chapter_id": "chapter-04",
      "lesson_number": 20,
      "title": "4.5.2 用 AI 帮你修 AI 的代码",
      "content": "# 4.5.2 用 AI 帮你修 AI 的代码 ​\n\n经过本节学习，你将掌握：\n\n- 向 AI 报告问题的标准流程\n- 诊断、修复、验证的三个 Prompt 模板\n- 避免无效沟通的常见误区\n## Debug 的三步流程 ​\n\n用 AI 修复代码问题，遵循「诊断 → 修复 → 验证」的三步流程：\n\n`┌─────────┐    ┌─────────┐    ┌─────────┐\n│  诊断   │ → │  修复   │ → │  验证   │\n│ 找到原因 │    │ 获取方案 │    │ 确认解决 │\n└─────────┘    └─────────┘    └─────────┘`每一步都有对应的 Prompt 模板。\n\n## 第一步：诊断 Prompt ​\n\n目标：让 AI 帮你分析问题原因，而不是直接给修复代码。\n\n诊断 Prompt 模板：\n\n`我的待办清单代码出现了问题，请帮我分析原因。\n\n【错误现象】\n[描述你看到了什么]\n\n【控制台报错】\n[粘贴完整的报错信息，包括行号]\n\n【相关代码】\n[粘贴报错位置附近的代码，大约 10-20 行]\n\n请帮我分析：\n1. 这个错误是什么意思？\n2. 最可能的原因是什么？\n3. 应该检查哪些地方？\n\n先不要给修复代码，我想先理解问题。`为什么先诊断：直接让 AI 修复，有时会「治标不治本」。先理解问题，你才能判断 AI 的修复方案是否靠谱。\n\n诊断 Prompt 示例：\n\n`我的待办清单代码出现了问题，请帮我分析原因。\n\n【错误现象】\n点击添加按钮后，任务没有出现在列表中\n\n【控制台报错】\nUncaught TypeError: Cannot read properties of undefined (reading 'push')\n    at addTask (index.html:45:15)\n\n【相关代码】\nfunction addTask() {\n    const input = document.querySelector('.task-input');\n    const taskText = input.value.trim();\n    if (taskText) {\n        tasks.push({ text: taskText, completed: false });\n        renderTasks();\n        input.value = '';\n    }\n}\n\n请帮我分析：\n1. 这个错误是什么意思？\n2. 最可能的原因是什么？\n3. 应该检查哪些地方？\n\n先不要给修复代码，我想先理解问题。`\n## 第二步：修复 Prompt ​\n目标：在理解问题后，让 AI 提供修复方案。\n\n修复 Prompt 模板：\n\n`根据刚才的分析，请帮我修复这个问题。\n\n【问题原因】\n[用你自己的话复述 AI 分析的原因]\n\n【修复要求】\n1. 给出修复后的完整代码\n2. 用注释标注修改的地方\n3. 解释为什么这样修改能解决问题\n\n【技术要求】\n- 保持原有的代码风格\n- 不要改动其他功能\n- 关键逻辑添加中文注释`修复 Prompt 示例：\n\n`根据刚才的分析，请帮我修复这个问题。\n\n【问题原因】\ntasks 变量在使用前没有初始化，所以是 undefined，无法调用 push 方法\n\n【修复要求】\n1. 给出修复后的完整代码\n2. 用注释标注修改的地方\n3. 解释为什么这样修改能解决问题\n\n【技术要求】\n- 保持原有的代码风格\n- 不要改动其他功能\n- 关键逻辑添加中文注释`\n## 第三步：验证 Prompt ​\n目标：修改代码后，让 AI 帮你确认问题是否真正解决。\n\n验证 Prompt 模板：\n\n`我已经按照你的建议修改了代码。请帮我验证：\n\n【修改后的代码】\n[粘贴修改后的代码]\n\n【当前状态】\n[描述现在的运行情况]\n\n请确认：\n1. 原来的问题是否解决了？\n2. 修改是否引入了新的问题？\n3. 还有什么需要注意的地方？`\n## 有效信息采集清单 ​\n向 AI 报告问题时，提供的信息越完整，AI 的回答越准确。\n\n必须提供的信息：\n信息类型说明获取方式错误现象发生了什么用自己的话描述控制台报错完整的报错文本从控制台复制相关代码报错位置附近的代码根据行号定位\n建议提供的信息：\n信息类型说明获取方式你的操作步骤做了什么导致报错回忆并记录之前的状态报错前代码是否正常回忆已尝试的方法你做过哪些尝试记录\n## 常见沟通误区 ​\n\n以下是一些无效的问题描述，以及如何改进：\n\n### 误区 1：描述太模糊 ​\n无效描述有效描述\"代码不工作\"\"点击添加按钮后，任务没有出现在列表中\"\"有个错误\"\"控制台显示 TypeError: Cannot read properties of undefined\"\"样式有问题\"\"任务列表的背景色消失了，变成了白色\"\n### 误区 2：不提供报错信息 ​\n无效做法有效做法\"控制台有报错\"复制完整的报错信息，包括行号\"我看到红色文字\"截图或复制红色文字的内容\n### 误区 3：一次问太多问题 ​\n无效做法有效做法\"添加不行，删除也不行，刷新还丢数据\"先解决一个问题，确认修复后再处理下一个\n### 误区 4：不提供代码上下文 ​\n无效做法有效做法\"第 45 行有问题\"粘贴第 40-50 行的代码，让 AI 看到上下文\n## 快速修复话术 ​\n\n如果你想跳过诊断，直接让 AI 修复，可以用这个精简版话术：\n\n`我的待办清单报错了：\n\n【现象】[一句话描述]\n【报错】[粘贴控制台报错]\n【代码】\n[粘贴相关代码]\n\n请直接给我修复后的完整代码。`示例：\n\n`我的待办清单报错了：\n\n【现象】点击添加按钮没反应\n【报错】Uncaught TypeError: Cannot read properties of undefined (reading 'push')\n    at addTask (index.html:45:15)\n【代码】\nfunction addTask() {\n    const input = document.querySelector('.task-input');\n    const taskText = input.value.trim();\n    if (taskText) {\n        tasks.push({ text: taskText, completed: false });\n        renderTasks();\n        input.value = '';\n    }\n}\n\n请直接给我修复后的完整代码。`\n## 本节要点 ​\n\n- Debug 遵循「诊断 → 修复 → 验证」三步流程\n- 诊断时先理解问题，不急于要修复代码\n- 提供完整信息：现象 + 报错 + 代码\n- 避免模糊描述，一次只解决一个问题\n- 快速修复话术适合简单问题，复杂问题建议走完整流程接下来，让我们通过真实案例，看看这些方法如何应用。\n\n→ 4.5.3 真实案例复盘",
      "word_count": 2964,
      "estimated_time": 5
    },
    {
      "id": "lesson-128",
      "chapter_id": "chapter-04",
      "lesson_number": 21,
      "title": "4.5.3 真实案例复盘",
      "content": "# 4.5.3 真实案例复盘 ​\n\n本节展示 6 个待办清单开发中的典型错误，包括完整的报错信息、诊断过程和修复对话。\n\n## 案例速查 ​\n案例错误类型错误信息关键词案例 1TypeError`Cannot read properties of undefined`案例 2ReferenceError`is not defined`案例 3SyntaxError`Unexpected token`案例 4逻辑错误无报错案例 5CSS 错误无报错案例 6逻辑错误无报错\n## 案例 1：任务列表是 undefined ​\n\n### 错误现象 ​\n\n点击添加按钮后，任务没有出现。控制台显示红色报错。\n\n### 控制台报错 ​\n\n`Uncaught TypeError: Cannot read properties of undefined (reading 'push')\n    at addTask (index.html:45:15)\n    at HTMLButtonElement.<anonymous> (index.html:52:5)`\n### 问题定位 ​\n这个错误的意思是：代码试图对 `undefined` 调用 `push` 方法。`push` 是数组的方法，说明代码期望这是一个数组，但实际上是 `undefined`。\n\n查看第 45 行代码：\njavascript\n`tasks.push({ text: taskText, completed: false });`问题出在 `tasks` 变量上——它没有被正确初始化。\n\n### 诊断对话 ​\n\n你发送的 Prompt：\n\n`我的待办清单代码报错了：\n\n【现象】点击添加按钮后，任务没有出现\n【报错】Uncaught TypeError: Cannot read properties of undefined (reading 'push')\n    at addTask (index.html:45:15)\n\n【代码】\nfunction addTask() {\n    const input = document.querySelector('.task-input');\n    const taskText = input.value.trim();\n    if (taskText) {\n        tasks.push({ text: taskText, completed: false });\n        renderTasks();\n        input.value = '';\n    }\n}\n\n请帮我分析原因。`AI 的分析：\n\n这个错误表示 `tasks` 变量在调用 `push` 时是 `undefined`。问题原因是 `tasks` 没有在使用前初始化为数组。你需要在代码开头声明 `let tasks = [];`。\n\n### 修复对话 ​\n\n你发送的 Prompt：\n\n`请帮我修复。需要：\n1. 在代码开头初始化 tasks 变量\n2. 给我修复后的完整代码`AI 给出的修复代码（关键部分）：\njavascript\n`// 在代码开头添加这一行\nlet tasks = [];  // 初始化任务数组\n\nfunction addTask() {\n    const input = document.querySelector('.task-input');\n    const taskText = input.value.trim();\n    if (taskText) {\n        tasks.push({ text: taskText, completed: false });\n        renderTasks();\n        input.value = '';\n    }\n}`\n### 验证方法 ​\n\n- 替换代码后刷新页面\n- 在输入框输入任务，点击添加\n- 确认任务出现在列表中\n- 确认控制台没有红色报错\n## 案例 2：函数未定义 ​\n\n### 错误现象 ​\n页面加载后，控制台立即显示报错。\n\n### 控制台报错 ​\n\n`Uncaught ReferenceError: addTask is not defined\n    at HTMLButtonElement.onclick (index.html:15:42)`\n### 问题定位 ​\n`ReferenceError: xxx is not defined` 表示代码中使用了一个不存在的变量或函数。\n\n常见原因：\n\n- 函数名拼写错误\n- 函数定义在调用之后（代码顺序问题）\n- 函数写在了错误的位置\n### 诊断对话 ​\n\n你发送的 Prompt：\n\n`页面加载就报错：ReferenceError: addTask is not defined\n\n我的 HTML 中有这样的按钮：\n<button onclick=\"addTask()\">添加</button>\n\n我的 JavaScript 中有这个函数：\nfunction addtask() {\n    // ... 函数内容\n}\n\n请帮我分析原因。`AI 的分析：\n\n问题在于函数名大小写不一致。HTML 中调用的是 `addTask()`（T 大写），但 JavaScript 中定义的是 `addtask()`（t 小写）。JavaScript 对大小写敏感，这两个被视为不同的函数。\n\n### 修复方法 ​\n\n将 JavaScript 中的函数名改为 `addTask`（与 HTML 中一致）：\njavascript\n`// 修改前\nfunction addtask() {\n\n// 修改后\nfunction addTask() {`\n### 验证方法 ​\n\n- 替换代码后刷新页面\n- 确认控制台没有 `ReferenceError`\n- 点击添加按钮，确认功能正常\n## 案例 3：localStorage 解析失败 ​\n\n### 错误现象 ​\n页面加载时报错，之前保存的任务无法显示。\n\n### 控制台报错 ​\n\n`Uncaught SyntaxError: Unexpected token 'u', \"undefined\" is not valid JSON\n    at JSON.parse (<anonymous>)\n    at loadTasks (index.html:68:24)`\n### 问题定位 ​\n这个错误发生在 `JSON.parse()` 时。错误信息 `\"undefined\" is not valid JSON` 表示试图解析的内容是字符串 `\"undefined\"`，而不是有效的 JSON。\n\n常见原因：\n\n- localStorage 中没有数据时，`getItem` 返回 `null`\n- 代码没有处理 `null` 的情况，直接传给了 `JSON.parse`\n### 诊断对话 ​\n\n你发送的 Prompt：\n\n`localStorage 读取报错：SyntaxError: Unexpected token 'u', \"undefined\" is not valid JSON\n\n我的读取代码：\nfunction loadTasks() {\n    const saved = localStorage.getItem('todoList');\n    tasks = JSON.parse(saved);\n    renderTasks();\n}\n\n请帮我分析。`AI 的分析：\n\n当 localStorage 中没有 'todoList' 这个键时，`getItem` 返回 `null`。`JSON.parse(null)` 会尝试解析，但在某些情况下可能导致问题。更常见的是，如果之前错误地存储了 `undefined` 字符串，就会出现这个错误。你需要在解析前检查数据是否存在。\n\n### 修复对话 ​\n\n你发送的 Prompt：\n\n`请帮我修复 loadTasks 函数，确保：\n1. 如果 localStorage 没有数据，使用空数组\n2. 如果数据格式不对，也使用空数组\n3. 给我完整的修复代码`AI 给出的修复代码：\njavascript\n`function loadTasks() {\n    const saved = localStorage.getItem('todoList');\n    \n    // 检查是否有保存的数据\n    if (saved && saved !== 'undefined') {\n        try {\n            tasks = JSON.parse(saved);\n        } catch (e) {\n            // 如果解析失败，使用空数组\n            console.log('数据格式错误，已重置');\n            tasks = [];\n        }\n    } else {\n        // 没有保存的数据，使用空数组\n        tasks = [];\n    }\n    \n    renderTasks();\n}`\n### 验证方法 ​\n\n- 替换代码后刷新页面\n- 确认控制台没有报错\n- 添加几个任务，刷新页面，确认任务还在\n## 案例 4：点击按钮没反应 ​\n\n### 错误现象 ​\n点击添加按钮，没有任何反应。控制台也没有报错。\n\n### 问题定位 ​\n\n这是典型的「逻辑错误」——代码语法正确，但行为不符合预期。\n\n可能原因：\n\n- 事件监听器没有正确绑定\n- 按钮的选择器写错了\n- 代码执行顺序问题（在 DOM 加载前就执行了）\n### 诊断对话 ​\n\n你发送的 Prompt：\n\n`我的添加按钮点击没反应，控制台也没有报错。\n\nHTML 中的按钮：\n<button class=\"add-btn\">添加</button>\n\nJavaScript 中的绑定：\nconst addBtn = document.querySelector('.add-button');\naddBtn.addEventListener('click', addTask);\n\n请帮我排查问题。`AI 的分析：\n\n问题在于 CSS 选择器不匹配。你的 HTML 中按钮的 class 是 `add-btn`，但 JavaScript 中查找的是 `.add-button`。由于找不到元素，`addBtn` 是 `null`，后续的 `addEventListener` 调用失败（虽然有时不报错）。\n\n### 修复方法 ​\n\n统一选择器名称：\njavascript\n`// 修改前（选择器不匹配）\nconst addBtn = document.querySelector('.add-button');\n\n// 修改后（与 HTML 一致）\nconst addBtn = document.querySelector('.add-btn');`\n### 验证方法 ​\n\n- 替换代码后刷新页面\n- 点击添加按钮，确认功能正常\n## 案例 5：样式突然消失 ​\n\n### 错误现象 ​\n让 AI 添加新功能后，整个页面的样式都消失了，变成了纯文本。\n\n### 问题定位 ​\n\n这通常发生在 AI 修改代码时，不小心删除或破坏了 CSS 部分。\n\n常见原因：\n\n- AI 只返回了 JavaScript 部分，你替换时覆盖了整个文件\n- CSS 代码中出现了语法错误\n- `<style>` 标签被误删\n### 诊断对话 ​\n\n你发送的 Prompt：\n\n`我让你添加删除功能后，页面样式全部消失了。\n现在页面只显示纯文本，没有任何样式。\n\n请帮我排查：\n1. 检查 <style> 标签是否完整\n2. 检查 CSS 语法是否有错误\n3. 如果样式丢失，请帮我恢复\n\n这是我现在的完整 HTML 文件：\n[粘贴完整代码]`AI 的分析：\n\n我发现问题了。在之前的修改中，`<style>` 标签被误删除了。我会帮你恢复完整的样式代码。\n\n### 修复方法 ​\n\n让 AI 重新生成包含完整样式的代码，或者从之前的版本中恢复 CSS 部分。\n\n### 预防措施 ​\n\n- 每次让 AI 修改代码前，先备份当前版本\n- 明确告诉 AI：「只修改 JavaScript 部分，不要改动 HTML 和 CSS」\n- 收到 AI 的代码后，先检查结构是否完整再替换\n## 案例 6：完成状态无法保存 ​\n\n### 错误现象 ​\n\n标记任务为「已完成」后，刷新页面，任务恢复为「未完成」状态。\n\n### 问题定位 ​\n\n这是数据持久化的逻辑错误——完成状态的变更没有触发保存操作。\n\n### 诊断对话 ​\n\n你发送的 Prompt：\n\n`任务的完成状态无法保存。\n\n【复现步骤】\n1. 添加一个任务\n2. 点击完成按钮，任务显示为已完成\n3. 刷新页面\n4. 任务恢复为未完成状态\n\n【现象】\n添加和删除操作都能保存，但完成状态不行\n\n【相关代码】\nfunction toggleComplete(index) {\n    tasks[index].completed = !tasks[index].completed;\n    renderTasks();\n}\n\nfunction saveTasks() {\n    localStorage.setItem('todoList', JSON.stringify(tasks));\n}\n\n请帮我分析原因。`AI 的分析：\n\n`toggleComplete` 函数修改了任务状态并重新渲染，但没有调用 `saveTasks()` 保存到 localStorage。添加和删除功能能保存，可能是因为它们的函数中调用了 `saveTasks()`，但 `toggleComplete` 漏掉了。\n\n### 修复对话 ​\n\n你发送的 Prompt：\n\n`请帮我修复，在 toggleComplete 函数中添加保存操作。`AI 给出的修复代码：\njavascript\n`function toggleComplete(index) {\n    tasks[index].completed = !tasks[index].completed;\n    saveTasks();  // 添加这一行：保存到 localStorage\n    renderTasks();\n}`\n### 验证方法 ​\n\n- 替换代码后刷新页面\n- 添加一个任务\n- 点击完成按钮\n- 刷新页面\n- 确认任务仍然显示为已完成\n## 本节要点 ​\n\n- 每个案例都遵循「现象 → 报错 → 定位 → 修复 → 验证」的流程\n- TypeError 通常是变量未定义或类型不对\n- ReferenceError 通常是拼写错误或作用域问题\n- SyntaxError 在 JSON.parse 时常见于数据为空或格式错误\n- 逻辑错误没有报错信息，需要对比「期望行为」和「实际行为」\n- 样式错误要检查 CSS 代码是否完整掌握了这些案例，你就能应对待办清单开发中的大部分问题。\n\n→ 4.5.4 Debug 心法总结",
      "word_count": 6382,
      "estimated_time": 12
    },
    {
      "id": "lesson-129",
      "chapter_id": "chapter-04",
      "lesson_number": 22,
      "title": "4.5.4 Debug 心法总结",
      "content": "# 4.5.4 Debug 心法总结 ​\n\n经过本节学习，你将掌握：\n\n- 面对报错的正确心态\n- 高效 debug 的五条心法\n- 一份可复用的 Debug 检查清单\n## 心法一：别慌，报错是正常的 ​\n\n报错不是失败的信号，而是代码在告诉你「这里需要调整」。\n错误认知正确认知报错说明我做错了报错是调试过程的一部分专业程序员不会遇到报错专业程序员每天都在 debug代码报错了，我的项目完蛋了90% 的报错都能在几分钟内解决\n记住：每一次成功的 debug，都是你能力的提升。专业程序员和初学者的区别，不是「会不会遇到报错」，而是「遇到报错时知不知道怎么处理」。\n\n## 心法二：先读后改，理解报错信息 ​\n\n在动手修改之前，先读懂报错信息在说什么。\n\n报错信息的三个关键部分：\n\n`Uncaught TypeError: Cannot read properties of undefined (reading 'push')\n        ↑ 错误类型           ↑ 错误描述\n    at addTask (index.html:45:15)\n                    ↑ 错误位置（文件名:行号:列号）`读懂报错的三个问题：\n\n- 是什么类型的错误？ TypeError / ReferenceError / SyntaxError\n- 具体出了什么问题？ 读错误描述，用自己的话复述\n- 错误发生在哪里？ 根据行号定位代码\n避免：看到报错就慌，不读信息就开始改代码。这往往会越改越乱。\n\n## 心法三：隔离问题，一次只改一处 ​\n\n当代码有多个问题时，要逐个击破，而不是一次性全改。\n\n正确做法：\n\n`问题 1：点击添加没反应\n    ↓ 解决\n问题 2：刷新后数据丢失\n    ↓ 解决\n问题 3：样式显示不对\n    ↓ 解决`错误做法：\n\n`同时告诉 AI：\"添加不行，刷新丢数据，样式也不对，帮我全部修好\"\n    ↓\nAI 返回大量改动\n    ↓\n不确定哪些改动解决了哪些问题\n    ↓\n新问题出现，不知道是哪个改动导致的`隔离问题的好处：\n\n- 每次改动都能确认效果\n- 出现新问题时容易定位原因\n- 避免「修一个问题引入三个新问题」\n## 心法四：善用撤销，改错了就退回 ​\n\n改代码就像走迷宫，走错了要能退回来重新选路。\n\n实用技巧：\n场景操作刚改错了代码`Ctrl+Z` / `Cmd+Z` 撤销改了很多想全部放弃不保存，直接刷新页面想保留多个版本每完成一个功能就备份一次文件\n备份策略：\n\n`todo-v1.html  ← 完成静态页面\ntodo-v2.html  ← 完成添加功能\ntodo-v3.html  ← 完成删除功能\ntodo-v4.html  ← 完成 localStorage`如果 v4 改崩了，随时可以回到 v3 重来。\n\n## 心法五：知道何时换思路 ​\n\n有时候，与其死磕一个问题，不如换个方法。\n\n判断标准：\n情况建议同一个问题，AI 反复给出类似的错误方案换一个 Prompt 表述方式改动越来越多，但问题没解决回退到上一个能用的版本代码已经「缝缝补补」面目全非让 AI 重新生成这部分功能花了 30 分钟还没解决休息一下，换个思路或寻求帮助\n「重来」不是失败：\n\n有时候从头开始比修补更快。你已经知道要实现什么、踩过哪些坑，第二次写会比第一次顺利得多。\n\n## Debug 检查清单 ​\n\n遇到问题时，按这个清单逐项检查：\n\n### 初步检查 ​\n\n- [ ] 打开控制台，查看是否有红色报错\n- [ ] 阅读报错信息，识别错误类型\n- [ ] 根据行号定位到具体代码位置\n### 信息收集 ​\n\n- [ ] 记录错误现象（发生了什么）\n- [ ] 记录期望行为（应该发生什么）\n- [ ] 复制完整的报错信息\n- [ ] 定位相关代码（报错行附近 10-20 行）\n### 问题解决 ​\n\n- [ ] 先诊断原因，再请求修复\n- [ ] 一次只解决一个问题\n- [ ] 替换代码前做好备份\n- [ ] 修改后立即验证效果\n### 验证确认 ​\n\n- [ ] 控制台没有新的报错\n- [ ] 功能按预期工作\n- [ ] 没有影响其他功能\n- [ ] 刷新页面后仍然正常\n## 快速参考卡片 ​\n\n将这张卡片保存下来，遇到问题时快速参考：\n\n`┌─────────────────────────────────────────┐\n│           Debug 快速参考                │\n├─────────────────────────────────────────┤\n│ 1. 打开控制台 (F12 → Console)           │\n│ 2. 阅读报错：类型 + 描述 + 位置          │\n│ 3. 定位代码：根据行号找到相关代码        │\n│ 4. 向 AI 报告：现象 + 报错 + 代码        │\n│ 5. 一次一个：解决一个再处理下一个        │\n│ 6. 验证结果：改完后确认问题解决          │\n├─────────────────────────────────────────┤\n│ 常见错误速记：                          │\n│ • TypeError → 变量未定义或类型不对      │\n│ • ReferenceError → 拼写错误或未声明     │\n│ • SyntaxError → 括号/引号/逗号不匹配    │\n│ • 无报错但不工作 → 逻辑错误，对比期望    │\n└─────────────────────────────────────────┘`\n## 本节要点 ​\n\n- 报错是正常的，专业程序员每天都在 debug\n- 先读懂报错信息，再动手修改\n- 一次只解决一个问题，避免越改越乱\n- 善用备份和撤销，给自己留后路\n- 知道何时该换思路或重新开始恭喜你完成了 Debug 实战章节。现在你不仅知道如何开发功能，也知道如何解决开发中遇到的问题。\n\n这正是 Vibe Coding 的核心技能：让 AI 帮你写代码，也让 AI 帮你修代码。\n\n→ 4.6 收尾与回顾",
      "word_count": 2617,
      "estimated_time": 5
    },
    {
      "id": "lesson-130",
      "chapter_id": "chapter-04",
      "lesson_number": 23,
      "title": "4.6.1 完整项目展示",
      "content": "# 4.6.1 完整项目展示 ​\n\n本步目标：确认最终成果，理解项目结构，建立对自己作品的清晰认知\n\n## 最终成果确认 ​\n\n在继续之前，让我们用一个完整的测试流程确认你的待办清单已经具备所有功能。\n\n### 功能验收测试 ​\n\n按照以下步骤逐一测试，每一步都应该得到预期结果：\n测试步骤操作预期结果通过1. 页面加载在浏览器中打开 HTML 文件页面正常显示，无报错☐2. 添加任务输入\"测试任务1\"，点击添加任务出现在列表中，输入框清空☐3. 再添加一个输入\"测试任务2\"，点击添加列表中有两个任务☐4. 空输入拦截输入框为空，点击添加不添加任何任务☐5. 标记完成点击\"测试任务1\"的完成按钮任务显示删除线或完成状态☐6. 删除任务点击\"测试任务2\"的删除按钮任务从列表消失☐7. 刷新页面按 F5 刷新浏览器剩余任务还在，完成状态保留☐8. 关闭重开关闭标签页，重新打开文件数据完全保留☐\n如果以上 8 项全部通过，恭喜你——你的待办清单是一个功能完整的应用。\n\n## 你的项目包含什么 ​\n\n虽然你可能只看到一个 HTML 文件，但它包含了构成一个完整网页应用的三个层次：\n\n`┌─────────────────────────────────────────┐\n│              你的 HTML 文件               │\n├─────────────────────────────────────────┤\n│  ┌─────────────────────────────────┐    │\n│  │         HTML 结构层              │    │\n│  │  标题、输入框、按钮、列表容器     │    │\n│  │  → 决定\"页面有什么元素\"         │    │\n│  └─────────────────────────────────┘    │\n│                                         │\n│  ┌─────────────────────────────────┐    │\n│  │         CSS 样式层               │    │\n│  │  颜色、字体、布局、间距、动画     │    │\n│  │  → 决定\"页面长什么样\"           │    │\n│  └─────────────────────────────────┘    │\n│                                         │\n│  ┌─────────────────────────────────┐    │\n│  │      JavaScript 逻辑层           │    │\n│  │  添加、删除、完成、保存、读取     │    │\n│  │  → 决定\"页面怎么响应操作\"       │    │\n│  └─────────────────────────────────┘    │\n└─────────────────────────────────────────┘`这三层就是前端开发的核心。你用 AI 生成的代码，本质上就是在告诉 AI 如何编写这三层。\n\n## 你的成果 vs 专业开发者的区别 ​\n\n你可能会问：我做的东西和专业程序员做的有什么区别？\n维度你的待办清单专业生产级应用功能完整性核心功能齐全更多边缘情况处理数据存储本地存储（localStorage）云端数据库用户系统单用户（自己用）多用户、登录注册访问方式本地文件部署到服务器，有网址代码组织单文件多文件、模块化版本管理手动备份Git 版本控制\n关键洞察：你的待办清单在核心功能上是完整的。专业应用的复杂性主要来自：\n\n- 支持更多用户\n- 处理更多边缘情况\n- 需要团队协作\n- 需要长期维护\n对于个人使用的小工具，你做的版本已经足够。\n\n## 这个项目的扩展空间 ​\n\n你现在的待办清单是一个很好的起点。基于同样的技术基础，你可以逐步扩展：\n\n### 短期扩展（用同样的方法） ​\n扩展功能复杂度需要新学的知识任务分类/标签低无，继续用现有方法优先级标记低无搜索过滤中无深色模式中无截止日期中日期处理（AI可以帮你）\n### 中期扩展（需要第五章知识） ​\n扩展功能需要学习对应章节部署到网上Vercel 部署5.2版本管理Git 基础5.1分享给朋友自定义域名5.2\n### 长期扩展（进阶版内容） ​\n扩展功能需要学习多设备同步云端数据库用户登录认证系统AI 智能分类AI API 集成\n## 成果截图建议 ​\n\n建议你现在做两件事：\n\n- 截图保存：给你的待办清单截一张图，这是你的第一个作品\n- 备份文件：把 HTML 文件复制一份，命名为 `todo-v1-final.html`\n这些都是你学习 Vibe Coding 的里程碑记录。\n\n## 本步检查点 ​\n\n- [ ] 8项功能测试全部通过\n- [ ] 理解项目包含的三个层次（HTML/CSS/JS）\n- [ ] 明白自己的成果与专业应用的差异和联系\n- [ ] 已截图或备份项目文件\n恭喜你拥有了一个真正能用的作品。接下来，让我们回顾完成这个项目的完整历程。\n\n→ 4.6.2 从 0 到 1 的完整历程回顾",
      "word_count": 2242,
      "estimated_time": 4
    },
    {
      "id": "lesson-131",
      "chapter_id": "chapter-04",
      "lesson_number": 24,
      "title": "4.6.2 从 0 到 1 的完整历程回顾",
      "content": "# 4.6.2 从 0 到 1 的完整历程回顾 ​\n\n本步目标：回顾整个开发历程，理解每一步如何串联第二章思维和第三章技法\n\n## 从想法到产品的完整链路 ​\n\n让我们用一张图回顾你走过的完整路径：\n\n`第二章：想清楚                第三章：说明白              第四章：做出来\n─────────────                ─────────────              ─────────────\n\n  问题发现                      上下文思维\n     │                            │\n     ▼                            ▼\n  JTBD思维  ─────────────────▶  PRD整合  ──────────────▶  4.1 准备工作\n     │                            │                          │\n     ▼                            ▼                          ▼\n  灵魂三问                    S.C.A.F.F.框架 ──────────▶  4.2 静态页面\n     │                            │                          │\n     ▼                            ▼                          ▼\n  减法思维  ─────────────────▶  迭代对话  ──────────────▶  4.3 核心功能\n  (MVP定义)                       │                          │\n     │                            ▼                          ▼\n     ▼                        问题诊断  ──────────────▶  4.4 数据存储\n  逆向思维  ─────────────────▶  修复策略  ──────────────▶  4.5 Debug\n  (预判失败)`每一章都不是孤立的。第二章的思考成果，通过第三章的表达技法，最终在第四章落地成为可运行的代码。\n\n## 每轮迭代用到的思维工具 ​\n\n下面这张表格展示了第四章每个步骤背后的思维和技法支撑：\n第四章步骤使用的第二章思维使用的第三章技法核心产出4.1 准备工作灵魂三问（确认方向）、MVP定义（明确范围）PRD整合（汇总需求）项目启动卡4.2 静态页面故事思维（用户场景）、用户画像S.C.A.F.F.框架写Prompt可视化的页面骨架4.3 核心功能减法思维（只做P0功能）迭代对话（功能逐个实现）添加/删除/完成功能4.4 数据存储—渐进式Prompt（分步实现）localStorage持久化4.5 Debug逆向思维（预判可能的问题）诊断→修复→验证流程问题解决能力\n这张表的价值在于：下次你做新项目时，可以按同样的模式操作。\n\n## 时间与产出数据 ​\n\n让我们看看完成这个项目的实际数据：\n\n### 时间分配 ​\n阶段投入时间产出4.1 准备工作约 15 分钟明确的项目定义4.2 静态页面约 20 分钟完整的页面UI4.3 核心功能约 35 分钟增删改三个功能4.4 数据存储约 20 分钟数据持久化4.5 Debug调试约 15-20 分钟问题解决经验总计约 2 小时完整可用的应用\n### Prompt 与代码对比 ​\n指标数值说明发送的 Prompt 数量约 10-15 条包括初始生成和调整修复生成的代码行数约 150-250 行HTML + CSS + JavaScript你需要理解的代码0 行AI 处理所有技术细节你需要表达清楚的需求100%这是你的核心工作\n关键洞察：Vibe Coding 把你的工作从\"写代码\"变成了\"表达需求\"。你的时间花在想清楚和说明白上，代码由 AI 生成。\n\n## 三轮迭代的递进关系 ​\n\n回顾 4.2-4.4 三轮迭代，它们之间有清晰的递进关系：\n\n`第一轮（4.2）          第二轮（4.3）          第三轮（4.4）\n─────────────         ─────────────         ─────────────\n   静态页面               交互功能               数据存储\n                          \n   \"空壳子\"        →      \"活起来\"        →      \"记得住\"\n                          \n 只有外观                点击有反应             刷新不丢失\n 没有功能                但刷新就没了           真正可用`这种\"静态→交互→存储\"的三轮迭代模式，是一个通用的开发节奏。你做其他项目时，也可以按这个顺序推进。\n\n## 如果重来一次，可以更快的地方 ​\n\n基于这次经验，如果让你重新做一遍，以下几点可以帮你提速：\n\n### 可以更快的环节 ​\n环节加速方法写第一个 Prompt直接用第三章的模板，不用从头想样式调整第一次就描述清楚设计偏好，减少来回修改功能实现一次 Prompt 实现一个功能，比一次要求多个功能更高效Debug提供完整的报错信息，AI 修复更准确\n### 常见的\"慢\"的原因 ​\n慢的表现原因改进方法AI 生成的不是想要的Prompt 描述不够具体用 S.C.A.F.F. 框架补全信息反复调整样式没有提前说明设计偏好第一个 Prompt 就描述颜色、风格Debug 花太多时间没有给 AI 足够的错误信息复制完整的控制台报错功能做一半卡住了一次想实现太多功能一次只做一个功能，确认后再下一个\n## 可复用的工作流模板 ​\n\n基于这次经验，总结一个可复用的 Vibe Coding 工作流：\n\n`┌─────────────────────────────────────────────────────────────┐\n│                  Vibe Coding 项目工作流                      │\n├─────────────────────────────────────────────────────────────┤\n│                                                             │\n│  准备阶段                                                    │\n│  ──────                                                     │\n│  1. 回答灵魂三问：用户是谁？痛点在哪？为什么选你？            │\n│  2. 确定 MVP 范围：第一版只做什么？明确不做什么？             │\n│  3. 整理项目启动卡：把思考成果结构化                         │\n│                                                             │\n│  开发阶段                                                    │\n│  ──────                                                     │\n│  4. 第一轮 - 静态页面：用 S.C.A.F.F. 框架写 Prompt           │\n│  5. 第二轮 - 核心功能：一次一个功能，迭代实现                 │\n│  6. 第三轮 - 数据存储：根据需求选择存储方案                   │\n│                                                             │\n│  收尾阶段                                                    │\n│  ──────                                                     │\n│  7. 完整测试：按功能清单逐一验证                             │\n│  8. 备份保存：保留当前版本，方便日后修改                      │\n│                                                             │\n└─────────────────────────────────────────────────────────────┘`这个流程不只适用于待办清单，任何你想用 Vibe Coding 做的项目都可以参考。\n\n## 本步检查点 ​\n\n- [ ] 理解第二章思维→第三章技法→第四章实战的串联关系\n- [ ] 知道每轮迭代分别用到了哪些思维工具和技法\n- [ ] 明白\"静态→交互→存储\"的三轮迭代模式\n- [ ] 掌握可复用的 Vibe Coding 工作流\n接下来，让我们具体盘点一下你在这个过程中获得了哪些技能。\n\n→ 4.6.3 你学到了什么",
      "word_count": 4102,
      "estimated_time": 8
    },
    {
      "id": "lesson-132",
      "chapter_id": "chapter-04",
      "lesson_number": 25,
      "title": "4.6.3 你学到了什么",
      "content": "# 4.6.3 你学到了什么 ​\n\n本步目标：明确你获得的具体技能，用自评表确认学习成果\n\n## 技能盘点：三个层次的收获 ​\n\n完成第四章后，你的收获可以分为三个层次：\n\n### 第一层：工作流技能 ​\n\n你掌握了从想法到产品的完整流程：\n阶段你学会了具体表现需求阶段用结构化方式定义项目能填写项目启动卡表达阶段用 AI 能理解的方式写 Prompt会用 S.C.A.F.F. 框架开发阶段分阶段推进项目静态→交互→存储三轮迭代验证阶段系统性测试功能会按检查点确认成果问题处理遇到报错不慌张会用 AI 诊断和修复\n这套工作流是可迁移的——做其他项目时，同样适用。\n\n### 第二层：AI 协作技能 ​\n\n你建立了与 AI 高效协作的能力：\n技能之前的你现在的你Prompt 编写不知道怎么描述需求会用结构化框架组织信息迭代追问AI 没做对就不知道怎么办会精确反馈，逐步逼近目标信息提供不知道 AI 需要什么上下文知道背景、任务、约束的重要性Debug 协作看到报错就慌会复制报错信息让 AI 帮忙修复结果验证盲目相信 AI 输出会用检查点确认功能正确\n这些技能的核心是：你学会了\"指挥\" AI，而不是\"等待\" AI。\n\n### 第三层：心态转变 ​\n\n更重要的是，你完成了一次心态上的转变：\n维度转变前转变后身份认知\"我不会编程\"\"我能用 AI 做出东西\"对报错的态度恐惧、觉得自己做错了平常心，知道可以修复对\"完美\"的追求想一次做到完美先跑通再优化对技术的态度技术是门槛技术是可以借助的工具\n这种心态转变，比任何具体技能都重要。它让你从\"想学编程的人\"变成了\"能做东西的人\"。\n\n## 技能自评表 ​\n\n用下面这张表检查你的学习成果。对每一项，诚实地评估自己目前的掌握程度：\n\n### 基础技能（第四章核心） ​\n技能项能做到有点生疏还不太会用项目启动卡整理需求☐☐☐用 S.C.A.F.F. 框架写 Prompt☐☐☐让 AI 生成静态页面☐☐☐让 AI 实现交互功能☐☐☐让 AI 添加 localStorage 存储☐☐☐遇到报错时复制信息给 AI 修复☐☐☐按检查点验证功能是否正常☐☐☐\n### 进阶技能（综合应用） ​\n技能项能做到有点生疏还不太会拆分功能，一次只做一个☐☐☐当 AI 输出不满意时，精确反馈☐☐☐理解\"静态→交互→存储\"的迭代节奏☐☐☐在开发前先做 MVP 范围定义☐☐☐\n评估建议：\n\n- 如果大部分是\"能做到\"：你已经掌握了基础版的核心技能，可以尝试独立做新项目\n- 如果有一些\"有点生疏\"：属于正常情况，多做几个项目就会熟练\n- 如果有\"还不太会\"：建议回顾对应章节，或者在下一个项目中特别练习这些技能\n## 与第一章的对比：你的成长 ​\n\n还记得第一章的 Hello World 吗？让我们对比一下那时和现在：\n维度第一章 Hello World第四章待办清单功能复杂度只显示文字增删改查 + 数据存储交互性无交互响应用户操作数据持久化无localStorage开发时间3 分钟约 2 小时Prompt 数量1 条10-15 条用到的思维工具无灵魂三问、MVP、S.C.A.F.F. 等实用价值演示用真正能用\n从 3 分钟的 Hello World 到 2 小时的完整应用，你走过的不只是时间，更是能力的跃升。\n\n## 你现在能做什么 ​\n\n基于你已经掌握的技能，以下类型的项目你都可以尝试：\n项目类型复杂度示例个人工具⭐记事本、书签管理、倒计时习惯追踪⭐⭐习惯打卡器、阅读记录简单游戏⭐⭐猜数字、石头剪刀布信息展示⭐个人主页、作品集计算工具⭐单位换算、分期计算\n这些项目的共同特点是：\n\n- 单用户使用\n- 本地数据存储足够\n- 不需要用户登录\n- 用同样的 HTML + CSS + JavaScript 就能实现\n## 本步检查点 ​\n\n- [ ] 完成了技能自评表的填写\n- [ ] 理解自己获得的三个层次的收获\n- [ ] 看到了从 Hello World 到待办清单的成长\n- [ ] 知道接下来可以尝试做什么类型的项目\n你已经具备了独立完成简单项目的能力。接下来，让我们看看下一步可以走向哪里。\n\n→ 4.6.4 下一步可以做什么",
      "word_count": 1743,
      "estimated_time": 3
    },
    {
      "id": "lesson-133",
      "chapter_id": "chapter-04",
      "lesson_number": 26,
      "title": "4.6.4 下一步可以做什么",
      "content": "# 4.6.4 下一步可以做什么 ​\n\n本步目标：规划学习路径，明确短期和中期目标\n\n完成了待办清单，你可能在想：接下来做什么？这里给你三个方向的选择。\n\n## 方向一：给待办清单加功能（立即可做） ​\n\n如果你想继续打磨这个项目，以下是一些扩展功能的 Prompt 示例：\n\n### 任务分类 ​\n\n`【背景】\n我的待办清单已经可以添加、删除、完成任务，并且数据会保存在 localStorage 中。\n\n【当前任务】\n请给任务添加分类功能：\n1. 预设三个分类：工作、生活、学习\n2. 添加任务时可以选择分类\n3. 每个分类用不同颜色标识\n4. 可以按分类筛选显示任务\n\n【技术要求】\n- 保持使用 localStorage 存储\n- 代码风格与现有代码一致`\n### 优先级标记 ​\n\n```\n【背景】\n我的待办清单目前功能完整，需要添加优先级功能。\n\n【当前任务】\n请给任务添加优先级功能：\n1. 三个优先级：高、中、低\n2. 高优先级用红色标识，中用黄色，低用灰色\n3. 任务列表自动按优先级排序\n4. 添加任务时可以选择优先级，默认为\"中\"\n\n【技术要求】\n- 优先级信息也要保存到 localStorage\n- 保持现有的完成、删除功能正常工作\n```\n\n### 搜索功能 ​\n\n```\n【背景】\n我的待办清单任务越来越多，需要搜索功能。\n\n【当前任务】\n请添加任务搜索功能：\n1. 在输入框上方添加一个搜索框\n2. 输入关键词时，实时过滤显示匹配的任务\n3. 搜索框为空时，显示所有任务\n4. 搜索不区分大小写\n\n【技术要求】\n- 搜索是前端过滤，不影响 localStorage 中的数据\n```\n这些功能你可以一个一个添加，每添加一个就测试一次，感受渐进式开发的节奏。\n\n## 方向二：进入第五章（推荐的下一步） ​\n\n第五章会解决你现在可能遇到的三个问题：\n\n### 问题一：改崩了回不去 ​\n\n场景：你尝试加了一个新功能，结果把原来能用的功能也搞坏了，而且你已经保存了文件，撤销不回去了。\n\n第五章解决方案：5.1 版本管理\n\n你会学到：\n\n- 什么是版本管理，为什么需要它\n- 用 GitHub Desktop 管理代码版本\n- 每次改动都能\"存档\"，随时回退\n### 问题二：只能自己用 ​\n\n场景：你想把待办清单分享给朋友，但现在它只是你电脑上的一个文件，别人打不开。\n\n第五章解决方案：5.2 部署上线\n\n你会学到：\n\n- 用 Vercel 把网页部署到网上\n- 获得一个真正的网址，任何人都能访问\n- 可选：绑定自己的域名\n### 问题三：安全意识 ​\n\n场景：你想让 AI 帮你做一个有登录功能的应用，但不知道怎么处理密码和敏感信息。\n\n第五章解决方案：5.3 安全意识\n\n你会学到：\n\n- 哪些东西绝对不能告诉 AI\n- 如何正确处理敏感信息\n- 初学者阶段的安全底线第五章小节解决的问题预计时间5.1 版本管理改崩了回不去30 分钟5.2 部署上线只能自己用20 分钟5.3 安全意识不知道什么不能做15 分钟5.4 局限性Vibe Coding 的边界10 分钟\n## 方向三：做一个新项目（巩固技能） ​\n\n用你学到的工作流，尝试做一个新项目。以下是一些适合练手的想法：\n\n### 个人工具类 ​\n项目核心功能复杂度记事本写文字、保存、编辑⭐书签管理器保存网址、分类、搜索⭐⭐倒计时器设置时间、开始、暂停、提醒⭐⭐日记本按日期写日记、查看历史⭐⭐\n### 习惯追踪类 ​\n项目核心功能复杂度习惯打卡器添加习惯、每日打卡、查看连续天数⭐⭐阅读记录记录书名、进度、笔记⭐⭐喝水提醒记录喝水次数、今日目标⭐\n### 给家人做的工具 ​\n项目核心功能复杂度家庭相册展示照片、添加描述⭐⭐家庭食谱收集菜谱、分类查看⭐⭐纪念日提醒记录重要日期、距离天数⭐\n选择项目的建议：\n\n- 从自己的痛点出发：做一个自己真的会用的东西\n- 复杂度适中：第一个项目选 ⭐ 或 ⭐⭐，不要一上来就挑战 ⭐⭐⭐\n- 功能要少：第一版只做核心功能，后续再迭代\n## 基础版学习完成检查清单 ​\n\n在进入第五章或开始新项目之前，用这个清单确认你已经掌握了基础版的核心内容：\n\n### 思维层面 ​\n\n- [ ] 理解 Vibe Coding 是什么，与传统编程的区别\n- [ ] 能用灵魂三问梳理项目方向\n- [ ] 理解 MVP 思维，知道如何定义第一版范围\n- [ ] 知道\"先想失败\"的逆向思维为什么重要\n### 表达层面 ​\n\n- [ ] 能用 S.C.A.F.F. 框架组织 Prompt\n- [ ] 知道上下文（背景、任务、约束）对 AI 输出的影响\n- [ ] 会用迭代对话逐步逼近目标\n- [ ] 遇到问题时，知道如何向 AI 提供有效的信息\n### 实践层面 ​\n\n- [ ] 能让 AI 生成静态页面\n- [ ] 能让 AI 实现交互功能\n- [ ] 能让 AI 添加 localStorage 存储\n- [ ] 遇到报错时，能用 AI 诊断和修复\n- [ ] 完成过至少一个功能完整的项目\n### 心态层面 ​\n\n- [ ] 相信自己能用 AI 做出东西\n- [ ] 对报错不再恐惧\n- [ ] 理解\"先跑通再优化\"的原则\n- [ ] 有动力继续学习和尝试\n如果以上大部分都能打勾，恭喜你——你已经完成了 Vibe Coding 基础版的学习。\n\n## 进阶版预览 ​\n\n完成基础版后，如果你想做更复杂的项目，进阶版会教你：\n主题你将学到能做什么云端数据库Supabase、Prisma数据多设备同步用户认证NextAuth、登录注册多用户系统专业框架Next.js、React复杂应用开发AI 功能集成Vercel AI SDK在应用中使用 AI部署运维Docker、1Panel服务器部署\n进阶版的内容需要更多的时间投入，但如果你对技术感兴趣，这是一条清晰的成长路径。\n\n## 本章结语 ​\n\n恭喜你完成了 Vibe Coding 的第一个完整项目！\n\n从第二章的产品思维，到第三章的表达技法，再到第四章的动手实践——你走过了一条完整的路径。这个待办清单也许功能简单，但它证明了一件事：\n\n你可以把想法变成现实。\n\n这种能力，在 AI 时代会越来越重要。不是因为你需要成为程序员，而是因为\"能做东西\"意味着你可以快速验证想法、解决自己的问题、创造属于自己的工具。\n\n记住这种感觉，带着它继续前进。\n\n→ 第五章：精进 —— 真实世界的开发流程",
      "word_count": 2689,
      "estimated_time": 5
    },
    {
      "id": "lesson-134",
      "chapter_id": "chapter-05",
      "lesson_number": 1,
      "title": "5.1.1 一个真实的噩梦场景",
      "content": "# 5.1.1 一个真实的噩梦场景 ​\n\n## 这种经历，每个学习者都会遇到 ​\n\n想象一下这个场景：\n\n- 你花了 2 小时，终于做好了待办清单\n- 页面很漂亮，功能也正常，你很有成就感\n- 想再加个\"深色模式\"功能，让它更炫酷\n- 改着改着，页面突然白屏了\n- 你不记得改了哪里，Ctrl+Z 也按不回去\n- 2 小时的成果，就这样没了...\n这不是夸张。在社区里，几乎每周都能看到类似的求助帖：\"我的代码改崩了，怎么恢复？\"\n\n## 更常见的几种情况 ​\n场景发生了什么后果改一个功能，坏了另一个添加删除功能时，不小心影响了添加功能花时间排查，可能越改越乱想回到\"昨天那个版本\"昨天的代码能用，今天改了一堆，全坏了找不到昨天的版本试了三种方案，想回到第一种第一种方案其实最好，但已经被覆盖了要么重写，要么将就AI 改了不该改的地方让 AI 改一个文件，它顺手改了其他文件不知道哪些被改了\n## 为什么会发生这种事 ​\n\nVibe Coding 的工作方式是：你告诉 AI 想要什么，AI 直接修改代码。\n\n这个过程非常高效，但有一个风险：改动是即时的、覆盖式的。\n\n传统程序员有一套复杂的工具来管理代码历史，但对于刚入门的你，这些工具学习成本太高。\n\n好消息是：你不需要学那些复杂的东西。\n\n## 解决方案：给代码装上\"时光机\" ​\n\n版本管理，本质上就是给你的代码创建\"存档点\"。\n\n就像玩游戏时的存档功能：\n\n- 打 Boss 之前存一个档\n- 打输了可以读档重来\n- 试新技能之前存一个档\n- 不好用可以回退\n代码也是一样：\n\n- 功能做好了存一个档\n- 准备大改之前存一个档\n- 改崩了可以回退\n核心观点\n\n版本管理不是高级技能，是基本生存技能。\n\n你不需要成为 Git 专家。只需要知道：怎么存档、怎么读档，就够了。\n\n## 接下来学什么 ​\n\n我们会介绍三种方案，从简单到进阶：\n\n- AI IDE 自带的历史功能：最简单，立即可用\n- 手动复制文件夹：最直观，人人都会\n- GitHub Desktop：更专业，为进阶版打基础\n先从最简单的开始。\n\n→ 5.1.2 零门槛方案：AI IDE 自带历史",
      "word_count": 910,
      "estimated_time": 3
    },
    {
      "id": "lesson-135",
      "chapter_id": "chapter-05",
      "lesson_number": 2,
      "title": "5.1.2 零门槛方案：AI IDE 自带历史功能",
      "content": "# 5.1.2 零门槛方案：AI IDE 自带历史功能 ​\n\n好消息：大多数 AI 编程工具已经内置了版本历史功能。\n\n你不需要安装任何新软件，不需要学习新概念，只需要知道在哪里找到它。\n\n## AI 代码编辑器（需安装类） ​\n\n如果你使用的是 Cursor、Windsurf、Trae 等需要安装的 AI IDE，它们都有历史恢复功能。\n\n### Cursor ​\n\nCursor 基于 VS Code，继承了它的 Local History 和 Timeline 功能。\n\n如何找到历史：\n\n- 在左侧 Explorer 面板底部，找到 Timeline 区域\n- 点击展开，可以看到当前文件的所有历史版本\n- 每次保存都会自动记录一个版本\n如何回退：\n\n- 在 Timeline 中找到想要恢复的时间点\n- 右键点击该版本\n- 选择\"Restore Contents\"恢复文件内容\n另一种方式：\n\n- 右键点击文件 → 选择 Local History → Find Local History\n- 可以看到更详细的历史记录\n注意事项\n\n- Timeline 仅保存在本地，换电脑就没了\n- 历史记录有数量和时间限制\n- 建议重要节点配合手动备份\n### Windsurf ​\n\nWindsurf 有独特的 Cascade Checkpoints 功能（2025 年 12 月更新）。\n\n如何找到历史：\n\n- 打开 Cascade 面板（通常在右侧）\n- 找到 Checkpoints 或 Named Checkpoints 选项\n- 可以查看之前保存的检查点\n如何回退：\n\n- 选择想要恢复的检查点\n- 点击 Revert 按钮\n- 代码会回到该检查点的状态\n特色功能：\n\n- 可以给检查点命名，方便识别\n- 支持在不同检查点之间快速切换\n### Trae ​\n\nTrae（包括国际版和国内版）提供 Diff View 功能来查看代码变更。\n\n如何找到历史：\n\n- 使用 Diff View 工具查看代码变更历史\n- 可以看到每次 AI 修改的内容对比\n如何回退：\n\n- 在 Diff View 中查看具体改动\n- 手动撤销不需要的改动\n- 或使用 IDE 的 Undo 功能\n建议\n\nTrae 的历史功能相对基础，建议配合手动备份使用（见 5.1.3）。\n\n### Kiro ​\n\nKiro 在 2025 年 11 月推出了 Checkpointing 功能。\n\n如何找到历史：\n\n- 每次 Kiro 修改代码时，会自动创建检查点\n- 在界面中可以看到检查点列表\n如何回退：\n\n- 找到想要恢复的检查点\n- 一键点击即可回退\n注意事项：\n\n- Checkpointing 只恢复当前会话中 Kiro 做的改动\n- 不会保存整个代码库的状态\n- 适合快速撤销最近的 AI 修改\n## 网页版 AI 编程（零安装类） ​\n\n网页版工具的历史功能通常更完善，因为数据保存在云端。\n\n### 豆包 AI 编程 ​\n\n国内用户首选，访问流畅。\n\n如何找到历史：\n\n- 在项目界面中查找版本历史入口\n- 可以查看之前的项目状态\n如何回退：\n\n- 选择需要恢复的版本\n- 确认恢复操作\n优势：\n\n- 国内访问速度快\n- 中文界面友好\n- 完全免费\n### Bolt.new ​\n\nBolt.new 有完善的 Version History 功能（2025 年 11 月更新）。\n\n如何找到历史：\n\n- 在侧边栏找到 版本历史 或 History 选项\n- 可以看到项目的所有历史版本\n- 版本按时间顺序排列\n如何回退：\n\n- 找到想要恢复的版本\n- 点击 Restore 按钮\n- 项目会恢复到该版本状态\n特色功能：\n\n- Bookmark：可以给重要版本添加书签，方便快速找到\n- 支持查看每个版本的具体改动\n- 版本历史保存在云端，换设备也能访问\n### v0.dev ​\n\nv0.dev 在 2025 年 2 月更新了版本管理功能。\n\n如何找到历史：\n\n- 在编辑器内可以看到版本列表\n- 每次生成都会创建新版本\n如何回退：\n\n- 点击想要恢复的版本\n- 选择切换或恢复\n- 可以在不同版本之间快速切换\n特点：\n\n- UI 组件质量高\n- 版本切换流畅\n### Lovable ​\n\nLovable 在 2025 年 3 月推出了 Versioning 2.0。\n\n如何找到历史：\n\n- 打开 History 面板\n- 编辑记录按日期组织，类似 Google Docs\n- 界面直观，容易找到想要的版本\n如何回退：\n\n- 找到想要恢复的编辑\n- 点击恢复按钮\n- 系统会创建一个新的编辑卡片（不会覆盖当前版本）\n特色功能：\n\n- Bookmarks：给重要版本添加书签\n- 智能恢复：恢复时创建新版本，方便追踪\n- Dev Mode：可以直接在 Lovable 编辑器中查看和编辑代码\n### Replit ​\n\nReplit 的历史功能非常完善（2025 年 5 月更新）。\n\n如何找到历史：\n\n- 打开任意文件\n- 点击编辑器右下角的 History 按钮\n- 可以看到该文件的所有历史版本\n如何回退：\n\n- 在历史面板中选择版本\n- 可以预览该版本的内容\n- 确认后恢复\n特色功能：\n\n- File History：单个文件的历史\n- App History：整个应用的历史（包括数据库状态）\n- Checkpoints：可以手动创建检查点\n## 实操任务：用你的待办清单测试 ​\n\n现在，用你在第四章做的待办清单项目来测试历史功能。\n\n### 测试步骤 ​\n\n- \n打开你的待办清单项目\n\n- \n做一个小改动\n比如修改标题文字\n- 或者改变按钮颜色\n- \n保存文件\n\n- \n找到历史功能\n根据你使用的工具，按照上面的指引找到历史入口\n- \n查看历史版本\n你应该能看到改动之前的版本\n- \n尝试恢复\n选择之前的版本\n- 确认恢复操作\n- 检查代码是否恢复\n### 成功验证 ​\n\n- [ ] 找到了历史功能入口\n- [ ] 能看到之前的版本列表\n- [ ] 成功恢复到了之前的版本\n- [ ] 代码确实回到了改动之前的状态\n如果以上都完成了，恭喜你——你已经学会了最基本的\"存档读档\"。\n\n## 这个方案的局限性 ​\n\n虽然 AI IDE 自带的历史功能很方便，但它有一些局限：\n局限说明仅本地保存（安装类工具）换电脑、重装系统，历史就没了历史有限通常只保留最近的 N 个版本或 N 天内的版本无法云端同步（安装类工具）不能在多台设备间同步不够精细难以对比两个版本的具体差异\n对于个人小项目，这些局限通常不是问题。但如果你想要更可靠的保护，可以结合下一节的手动备份方法。\n\n核心观点\n\n先用好工具自带的功能，够用就行。不需要一开始就追求完美的解决方案。\n\n→ 5.1.3 手动版本管理",
      "word_count": 2847,
      "estimated_time": 5
    },
    {
      "id": "lesson-136",
      "chapter_id": "chapter-05",
      "lesson_number": 3,
      "title": "5.1.3 手动版本管理",
      "content": "# 5.1.3 手动版本管理：简单但有效 ​\n\n最简单的版本管理方法：定期复制文件夹。\n\n这个方法不需要学习任何新工具，不需要联网，人人都会。虽然\"土\"，但非常有效。\n\n## 基本操作 ​\n\n- 找到你的项目文件夹（比如 `todo-list`）\n- 复制整个文件夹\n- 给副本起个有意义的名字\n- 继续在原文件夹里开发\n就这么简单。\n\n## 推荐的命名规范 ​\n\n一个好的命名能让你快速找到需要的版本。\n\n### 格式建议 ​\n\n`项目名-v版本号-功能描述/`或者加上日期：\n\n`项目名-v版本号-功能描述-日期/`\n### 待办清单项目示例 ​\n\n```\ntodo-list/                          ← 当前开发的版本\ntodo-list-v1-基础功能完成/            ← 第一个能用的版本\ntodo-list-v2-添加删除功能/            ← 添加了删除功能\ntodo-list-v3-数据保存/               ← 添加了 localStorage\ntodo-list-v4-深色模式尝试/            ← 准备大改之前的备份\n```\n\n### 如果你更喜欢用日期 ​\n\n```\ntodo-list/\ntodo-list-20250107-基础完成/\ntodo-list-20250108-删除功能/\ntodo-list-20250108-数据保存/\n```\n\n## 什么时候应该保存一个版本 ​\n不需要每改一行代码就备份。以下几个时机最重要：\n时机为什么示例完成一个功能后这个版本是确定能用的添加任务功能做好了准备做重大改动前万一改崩了可以回退准备加深色模式今天工作结束时保护今天的成果下班前备份一下准备让 AI 做大改动前AI 可能改错地方让 AI 重构代码\n## 实操：给你的待办清单创建第一个备份 ​\n\n现在就动手，给你的待办清单项目创建一个备份。\n\n### 步骤 ​\n\n- \n找到项目文件夹\n打开你在第四章创建的项目文件夹\n- 通常在 `文档/vibe-coding-projects/todo-list/` 这样的位置\n- \n复制文件夹\nWindows：右键 → 复制，然后右键 → 粘贴\n- Mac：选中文件夹，按 Command+C，然后 Command+V\n- \n重命名副本\n把副本命名为：`todo-list-v1-第四章完成版`\n- \n验证\n确认你现在有两个文件夹\n- 原文件夹继续开发\n- 副本作为备份保存\n### 成功验证 ​\n\n`vibe-coding-projects/\n├── todo-list/                      ← 继续在这里开发\n└── todo-list-v1-第四章完成版/        ← 备份，不要动它`\n## 这个方案的特点 ​\n优点：\n\n- ✅ 简单直观，人人都会\n- ✅ 不需要学习新工具\n- ✅ 不需要联网\n- ✅ 备份完整，想恢复直接复制回去\n局限性：\n\n- ❌ 占用磁盘空间（项目大的话会很占地方）\n- ❌ 难以对比两个版本的差异\n- ❌ 容易忘记备份\n- ❌ 无法云端同步\n## 与 AI IDE 历史功能配合使用 ​\n\n推荐的组合方式：\n场景使用方式日常小改动依赖 AI IDE 自带历史完成重要功能手动复制一个备份准备大改之前手动复制一个备份项目完成阶段性目标手动复制一个备份\n这样既不会备份太频繁，又能保护重要的版本。\n\n核心观点\n\n手动备份是最后的保险。即使你学会了更高级的工具，偶尔手动备份一下也是好习惯。\n\n→ 5.1.4 进阶方案：GitHub Desktop 入门",
      "word_count": 1528,
      "estimated_time": 3
    },
    {
      "id": "lesson-137",
      "chapter_id": "chapter-05",
      "lesson_number": 4,
      "title": "5.1.4 进阶方案：GitHub Desktop 入门",
      "content": "# 5.1.4 进阶方案：GitHub Desktop 入门 ​\n\n如果你想要更专业的版本管理，GitHub Desktop 是一个很好的起点。\n\n它是一个图形界面工具，让你不用敲命令就能使用 Git——程序员最常用的版本管理工具。\n\n## 先理解三个概念 ​\n\n在开始之前，我们先搞清楚三个经常被混淆的概念：\n概念是什么比喻Git一个版本管理工具时光机的核心引擎GitHub一个在线代码托管平台云端的代码仓库GitHub DesktopGit 的图形界面客户端时光机的遥控器\n简单来说：\n\n- Git 是技术\n- GitHub 是网站\n- GitHub Desktop 是让你用鼠标操作 Git 的软件\n你不需要理解 Git 的所有功能。只需要知道：GitHub Desktop 能帮你存档、回退、云端备份，就够了。\n\n## 为什么选择 GitHub Desktop ​\n优势说明图形界面点击操作，不用记命令免费完全免费使用云端备份代码保存在 GitHub，换电脑也能找回业界标准Git 是程序员的标配技能为进阶版打基础进阶版会学习更多 Git 技巧\n## 核心概念（用生活类比） ​\n\nGitHub Desktop 里有一些专业术语，但其实很好理解：\nGit 术语生活类比一句话解释Repository（仓库）带版本追踪的文件夹你的项目存放地，每次改动都会被记录Commit（提交）存档点保存当前状态，配上一句描述Push（推送）上传到云端把本地的存档同步到 GitHub 网站Pull（拉取）从云端下载把 GitHub 上的最新版本下载到本地History（历史）存档记录所有存档点的列表Revert（回退）读档把代码恢复到某个存档点\n## 基本工作流程 ​\n\n使用 GitHub Desktop 的日常流程很简单：\n\n`改代码 → 保存文件 → Commit（存档）→ Push（上传云端）\n                         ↓\n                可以随时查看历史\n                可以随时回退到任何存档点`每次 Commit 就像在游戏里存了一个档。你可以有很多个存档，随时回到任何一个。\n\n## 学习成本 ​\n操作难度学习时间安装软件简单2 分钟创建仓库简单2 分钟提交代码（Commit）简单1 分钟查看历史简单1 分钟回退版本简单1 分钟推送到云端（Push）简单1 分钟\n总共只需要 10-15 分钟，你就能掌握基本操作。\n\n## 与进阶版的衔接 ​\n\n本节介绍的 GitHub Desktop 是图形界面入门工具，目的是让你先体验版本管理的好处。\n\n进阶版预告\n\n在进阶版中，你将学习：\n\n- Git 命令行：更灵活、更强大的操作方式\n- 分支管理：同时开发多个功能，互不干扰\n- Pull Request：团队协作的标准工作流\n- 冲突解决：多人修改同一文件时怎么处理\n这些都是专业开发者的必备技能。但对于基础版来说，GitHub Desktop 已经足够。\n\n## 是否需要学这个 ​\n\n如果你满足以下任一条件，建议学：\n\n- 想要云端备份，换电脑也能找回代码\n- 想为后续学习打基础\n- 想体验专业开发者的工作方式\n- 有 15 分钟的时间\n如果你暂时没需求，可以跳过：\n\n- AI IDE 自带历史 + 手动备份已经够用\n- 以后需要时再学也来得及\n接下来是具体的实操步骤。\n\n→ 5.1.5 GitHub Desktop 实操",
      "word_count": 1451,
      "estimated_time": 3
    },
    {
      "id": "lesson-138",
      "chapter_id": "chapter-05",
      "lesson_number": 5,
      "title": "5.1.5 GitHub Desktop 实操",
      "content": "# 5.1.5 GitHub Desktop 实操：10 分钟上手 ​\n\n本节带你一步步完成 GitHub Desktop 的安装和基本操作。\n\n## Step 1：下载安装 ​\n\n访问 GitHub Desktop 官网下载安装包：\n\n官网地址：desktop.github.com\n\n- 根据你的操作系统（Windows/Mac）下载对应版本\n- 下载完成后，双击安装包，按提示完成安装\n你应该看到：安装完成后，GitHub Desktop 的图标出现在你的应用列表中。\n\n国内用户提示\n\nGitHub 在国内访问可能较慢。如果下载速度很慢，可以尝试：\n\n- 换个时间段下载（早晨通常较快）\n- 使用手机热点\n- 搜索\"GitHub Desktop 国内镜像\"\n如果实在无法下载，可以暂时跳过这一节，先用 5.1.2 和 5.1.3 的方法。\n\n## Step 2：注册/登录 GitHub 账号 ​\n\n打开 GitHub Desktop 后，它会提示你登录。\n\n如果你没有 GitHub 账号：\n\n- 点击\"Create your free account\"或访问 github.com\n- 填写用户名、邮箱、密码\n- 完成邮箱验证\n如果你已有账号：\n\n- 点击\"Sign in to GitHub.com\"\n- 在弹出的浏览器页面中登录\n- 授权 GitHub Desktop 访问你的账号\n你应该看到：登录成功后，界面显示\"Let's get started!\"或类似的欢迎页面。\n\n## Step 3：把待办清单变成仓库 ​\n\n现在我们要把第四章做的待办清单项目变成一个 Git 仓库。\n\n### 方式一：从现有文件夹创建 ​\n\n- \n点击 \"Create a New Repository on your Hard Drive\" 或 \"Add an Existing Repository\"\n\n- \n如果选择\"Create New\"：\nName：输入仓库名，如 `my-todo-list`\n- Local Path：选择你的项目文件夹的上级目录\n- 勾选 \"Initialize this repository with a README\"\n- 点击 \"Create Repository\"\n- \n把你的待办清单文件复制到新创建的仓库文件夹中\n\n### 方式二：直接添加现有项目（推荐） ​\n\n- 点击 File → Add Local Repository\n- 选择你的待办清单项目文件夹\n- 如果提示\"这不是一个 Git 仓库\"，点击 \"create a repository\"\n- 确认创建\n你应该看到：左侧显示你的项目名称，中间区域显示文件变化。\n\n## Step 4：第一次 Commit（存档） ​\n\n现在你的项目已经是一个 Git 仓库了。来创建第一个存档点。\n\n- \n在 GitHub Desktop 主界面，左侧会显示所有变化的文件\n\n- \n如果是新仓库，所有文件都会显示为\"新增\"\n\n- \n在左下角找到 Summary 输入框\n输入一句描述，比如：\"第四章待办清单完成版\"\n- Description 可以留空\n- \n点击蓝色的 \"Commit to main\" 按钮\n\n你应该看到：\n\n- 左侧的文件列表清空了（因为所有变化都已保存）\n- 界面提示\"No local changes\"\n恭喜！你创建了第一个存档点。\n\n## Step 5：查看历史（History） ​\n\n来看看刚才创建的存档。\n\n- 点击顶部的 \"History\" 标签（或在左侧找到）\n- 你会看到一个时间线，每个节点就是一个 Commit\n你应该看到：\n\n- 刚才的 Commit 出现在列表中\n- 显示你写的描述（如\"第四章待办清单完成版\"）\n- 右侧显示这次 Commit 包含了哪些文件\n## Step 6：模拟改崩然后回退 ​\n\n来测试一下\"读档\"功能。\n\n### 6.1 先做一个改动 ​\n\n- 用你的 AI IDE 或文本编辑器打开待办清单的 HTML 文件\n- 随便改点东西（比如把标题改成\"测试回退\"）\n- 保存文件\n### 6.2 创建一个新的存档 ​\n\n- 回到 GitHub Desktop\n- 你会看到刚才的改动显示在 Changes 列表中\n- 写一个描述：\"测试改动\"\n- 点击 \"Commit to main\"\n### 6.3 回退到之前的版本 ​\n\n- 点击 \"History\" 标签\n- 找到\"第四章待办清单完成版\"那个 Commit\n- 右键点击它\n- 选择 \"Revert Changes in Commit\"（或 \"Revert this Commit\"）\n- 确认操作\n你应该看到：\n\n- 创建了一个新的 Commit，描述类似\"Revert 测试改动\"\n- 打开 HTML 文件，标题恢复了原样\n## Step 7：推送到云端（Push） ​\n\n最后一步，把你的代码上传到 GitHub 网站。\n\n- 点击顶部的 \"Publish repository\" 或 \"Push origin\" 按钮\n- 在弹出的对话框中： Name：确认仓库名称\n- Description：可以写一句描述（可选）\n- Keep this code private：建议勾选（保持私有）\n- 点击 \"Publish Repository\"\n你应该看到：\n\n- 按钮变成\"Fetch origin\"\n- 没有报错信息\n### 验证成功 ​\n\n- 打开浏览器，访问 github.com\n- 登录你的账号\n- 在你的个人页面，应该能看到刚才创建的仓库\n- 点击进去，能看到你的代码文件\n恭喜！你的代码现在有了云端备份。即使电脑坏了，也能从 GitHub 找回来。\n\n## 常见问题 ​\n问题可能原因解决方法Push 失败网络问题检查网络连接，稍后重试找不到项目文件夹路径问题确认文件夹位置，重新添加登录失败账号问题在浏览器中先登录 github.com 试试操作很慢网络问题（国内常见）耐心等待，或换个时间提示\"not a git repository\"还没初始化按 Step 3 创建仓库\n## 成功验证清单 ​\n\n完成以下所有步骤，说明你已经掌握了 GitHub Desktop 的基本操作：\n\n- [ ] 成功安装 GitHub Desktop\n- [ ] 登录了 GitHub 账号\n- [ ] 把待办清单项目变成了仓库\n- [ ] 创建了第一个 Commit\n- [ ] 在 History 中看到了 Commit 记录\n- [ ] 成功测试了回退功能\n- [ ] 把代码推送到了 GitHub 云端\n- [ ] 在 github.com 上能看到自己的项目\n如果全部完成，恭喜你——你已经学会了专业开发者日常使用的版本管理工具！\n\n→ 5.1.6 版本管理最佳实践",
      "word_count": 2852,
      "estimated_time": 5
    },
    {
      "id": "lesson-139",
      "chapter_id": "chapter-05",
      "lesson_number": 6,
      "title": "5.1.6 版本管理最佳实践",
      "content": "# 5.1.6 版本管理最佳实践 ​\n\n学会了工具的基本操作，接下来是一些让版本管理更有效的技巧。\n\n## Commit 信息怎么写 ​\n\n每次 Commit 都需要写一句描述。好的描述能让你快速找到需要的版本。\n\n### 好的写法 ​\n\n`✅ \"添加任务删除功能\"\n✅ \"修复刷新后数据丢失的问题\"\n✅ \"调整按钮颜色为蓝色\"\n✅ \"第四章完成版\"\n✅ \"准备添加深色模式前的备份\"`特点：\n\n- 说清楚做了什么\n- 一眼就能看懂\n### 不好的写法 ​\n\n`❌ \"修改了一些东西\"\n❌ \"update\"\n❌ \"fix\"\n❌ \"...\"\n❌ \"1\"`问题：\n\n- 看不出做了什么\n- 以后找版本时完全没帮助\n### 简单原则 ​\n\n用一句话描述\"这次改动做了什么\"。\n\n不需要写得很正式，只要自己以后能看懂就行。\n\n## 多久 Commit 一次 ​\n\n原则：完成一个小功能就 Commit。\n做法优缺点每改一行就 Commit❌ 太频繁，历史太乱做完一个功能就 Commit✅ 推荐，粒度合适写了一大堆再 Commit❌ 出问题难回退，找不到问题点\n### 推荐的 Commit 时机 ​\n\n- 添加了一个新功能\n- 修复了一个问题\n- 调整了样式/布局\n- 重构了代码结构\n- 准备下班/休息\n不要等到\"完美\"了再 Commit。半成品也可以 Commit，反正随时可以继续改。\n\n## 什么文件应该/不应该提交 ​\n\n有些文件应该纳入版本管理，有些不应该。\n\n### 应该提交的文件 ​\n\n- 你写的代码（HTML、CSS、JavaScript 等）\n- 项目配置文件\n- 文档和说明\n### 不应该提交的文件 ​\n类型例子为什么依赖包文件夹`node_modules/`太大，可以重新安装环境配置`.env`可能包含密码等敏感信息系统文件`.DS_Store`（Mac）与项目无关编译产物`dist/`、`build/`可以重新生成\n### 使用 .gitignore 文件 ​\n\n在项目根目录创建一个名为 `.gitignore` 的文件，写入要忽略的文件/文件夹：\n\n`# 依赖\nnode_modules/\n\n# 环境配置\n.env\n.env.local\n\n# 系统文件\n.DS_Store\nThumbs.db\n\n# 编译产物\ndist/\nbuild/`GitHub Desktop 会自动忽略这些文件，不会把它们纳入版本管理。\n\n提示\n\n如果你用的是纯 HTML/CSS/JS 的简单项目（比如待办清单），暂时不需要担心 `.gitignore`。这个文件在项目变复杂后才会用到。\n\n## 三级方案对比与选择 ​\n方案学习成本可靠性云端备份适合场景AI IDE 自带历史零中否（网页版除外）日常小改动手动复制文件夹零高否重要节点备份GitHub Desktop低高是长期项目、想学专业技能\n### 推荐组合 ​\n\n最省心的方案：\n\n- 日常依赖 AI IDE 自带历史\n- 完成重要功能时手动备份一个文件夹\n- 项目完成后考虑上传到 GitHub\n想要专业一点：\n\n- 从一开始就用 GitHub Desktop\n- 每完成一个功能就 Commit\n- 每天结束时 Push 到云端\n## 本节检查清单 ​\n\n完成本节学习后，确认你掌握了以下内容：\n\n- [ ] 知道在哪里找到 AI IDE 的历史功能\n- [ ] 能够使用历史功能回退到之前的版本\n- [ ] 会用手动复制文件夹的方式备份项目\n- [ ] 知道什么时候应该保存一个版本\n- [ ] （可选）安装了 GitHub Desktop\n- [ ] （可选）成功把项目上传到了 GitHub\n- [ ] （可选）知道 Commit 信息怎么写\n## 恭喜你 ​\n\n从现在起，你的代码有了\"时光机\"保护。\n\n不管是 AI IDE 自带的历史，还是手动备份，还是 GitHub Desktop——你已经掌握了保护自己劳动成果的能力。\n\n这意味着：\n\n- 你可以大胆尝试新功能，不怕改崩\n- 你可以让 AI 做实验性的改动，不满意就回退\n- 你的 2 小时成果不会因为一个小失误而白费\n这不是终点，而是新的起点。\n\n接下来，我们要把你的待办清单发布到互联网上，让全世界都能访问。\n\n鼓励\n\n从\"代码改崩了就没了\"到\"随时可以回退\"——这是一个重要的思维转变。\n\n你已经比很多初学者更懂得保护自己的成果。继续前进！\n\n→ 5.2 见世面：把网页发到互联网上",
      "word_count": 1862,
      "estimated_time": 3
    },
    {
      "id": "lesson-140",
      "chapter_id": "chapter-05",
      "lesson_number": 7,
      "title": "5.2.1 为什么要部署上线",
      "content": "# 5.2.1 为什么要\"部署上线\" ​\n\n在第四章，你亲手做出了一个待办清单。它能添加任务、删除任务、标记完成，数据还能保存下来。这已经是一个真正可用的工具了。\n\n但有一个问题：它只能在你的电脑上运行。\n\n想让朋友看看你做的东西？要么把电脑递给他，要么录个屏发过去。想在手机上用？做不到。想在公司电脑上用？也不行。\n\n部署，就是把你的项目放到互联网上，让它拥有一个真正的网址。\n\n## 部署是什么 ​\n\n用一个类比来理解：\n\n- 你在本地开发，就像在自己家里做饭，只有家里人能吃到\n- 部署上线，就像开了一家餐厅，任何人都可以来品尝\n技术上说，部署就是把你的代码放到一台 24 小时运行的服务器上。但你不需要自己买服务器，现在有很多免费的平台帮你做这件事。\n\n## 不同人群的使用场景 ​\n你是谁部署后能做什么学生把课程作业部署上线，提交一个链接给老师，比截图专业多了职场人做一个效率工具，在公司和家里都能用，手机上也能用给家人做工具爸妈用手机扫个码就能打开，不用教他们装软件学习者积累作品集，每个项目都有真实网址，求职时拿得出手创业者快速验证想法，让潜在用户试用，收集真实反馈\n## 部署后你将获得 ​\n\n- 一个真正的网址（如 `my-todo.zeabur.app`）\n- 任何设备都能访问，包括手机、平板\n- 可以分享给任何人，发个链接就行\n- 24 小时在线，你关机了别人也能访问\n- 代码更新后自动同步，不需要手动操作\n## 部署有多简单 ​\n\n你可能觉得\"部署\"听起来很技术、很复杂。实际上，现在的部署平台已经把流程简化到了极致。\n\n你需要做的只有三步：\n\n- 把代码上传到 GitHub（如果你跟着 5.1 做了，这一步已经完成）\n- 在部署平台上登录，选择你的项目\n- 点击部署，等待 1-3 分钟\n没有服务器要配置，没有复杂的命令要记，就是点几下鼠标的事。\n\n你比想象中离成功更近\n\n如果你已经完成了第四章的待办清单，并且按照 5.1 把代码上传到了 GitHub，那么你距离\"让全世界都能访问你的作品\"只差 5 分钟。\n\n→ 5.2.2 部署平台选择指南",
      "word_count": 889,
      "estimated_time": 3
    },
    {
      "id": "lesson-141",
      "chapter_id": "chapter-05",
      "lesson_number": 8,
      "title": "5.2.2 部署平台选择指南",
      "content": "# 5.2.2 部署平台选择指南 ​\n\n部署平台有很多，但对于初学者来说，选择标准很简单：免费、简单、能用。\n\n中国大陆用户请注意\n\nVercel 和 Netlify 的默认域名（`*.vercel.app` / `*.netlify.app`）在中国大陆被 DNS 污染，直接访问会失败或非常慢。\n\n建议：大陆用户优先使用 Zeabur，它的免费域名（`*.zeabur.app`）可以正常访问。\n\n## 2025 年主流部署平台对比 ​\n平台免费额度大陆访问难度最适合Zeabur$5/月额度正常简单大陆用户首选Vercel100GB带宽/月需代理简单海外用户、Next.js 项目Netlify100GB带宽/月需代理简单静态网站帽子云完全免费正常简单大陆用户、静态网站EdgeOne Pages公测免费正常中等腾讯云用户GitHub Pages完全免费不稳定中等个人主页、文档站\n## 2025 年免费额度详情 ​\n\n### Zeabur（推荐） ​\n\n- 免费试用计划：每月 $5 额度\n- 资源定价：内存约 $0.00025/GB-分钟（约 $10.8/GB-月）\n- vCPU：免费\n- 网络流量：$0.10/GB\n- 特点：国人团队、中文客服、支持支付宝\n对于待办清单这样的小项目，免费额度完全够用。\n\n### Vercel ​\n\n- Hobby 计划（免费）： 100GB 快速数据传输/月\n- 1M Edge 请求/月\n- 4 小时 CPU 时间/月\n- 最多 200 个项目\n- 限制：仅限非商业用途\n### Netlify ​\n\n- 免费计划： 100GB 带宽/月\n- 300 分钟构建时间/月\n- 支持拖拽上传\n## 如何选择 ​\n\n`你在中国大陆吗？\n├── 是 → 使用 Zeabur（首选）或帽子云\n└── 否 → 使用 Vercel（首选）或 Netlify`如果你不确定，跟着本教程使用 Zeabur 即可。它是目前对大陆用户最友好的选择，操作也足够简单。\n\n## 本教程的选择 ​\n场景推荐平台原因大陆用户Zeabur免费域名可正常访问，中文界面海外用户Vercel最流行、功能强大、自动检测纯静态网站帽子云 / Netlify完全免费、操作简单已有域名Vercel + Cloudflare性能最好\n不用纠结\n\n对于你的第一个项目，选哪个平台差别不大。先跑起来最重要，以后可以随时换。\n\n→ 5.2.3 Zeabur 部署实战",
      "word_count": 1034,
      "estimated_time": 3
    },
    {
      "id": "lesson-142",
      "chapter_id": "chapter-05",
      "lesson_number": 9,
      "title": "5.2.3 Zeabur 部署实战（大陆首选）",
      "content": "# 5.2.3 Zeabur 部署实战：大陆用户首选 ​\n\nZeabur 是一个由国人团队开发的部署平台，它的免费域名在国内可以正常访问，这是选择它的最重要原因。\n\n## 经过本节操作，你将获得 ​\n\n- 一个可以在国内正常访问的网址\n- 自动部署能力：代码更新后自动同步\n- 完整的部署流程经验\n## Zeabur 的优势 ​\n特点说明大陆可访问免费域名 `*.zeabur.app` 没有被墙中文支持界面支持中文，客服也是中文自动检测自动识别你的项目类型，无需配置免费额度每月 $5 免费额度，小项目完全够用支付宝付款如果需要升级，可以用支付宝\n## 准备工作 ​\n\n在开始之前，确认你已经完成：\n\n- [ ] 第四章的待办清单项目已完成\n- [ ] 按照 5.1 的步骤，项目已上传到 GitHub\n- [ ] 有一个 GitHub 账号\n如果还没上传到 GitHub，请先回到 5.1 版本管理 完成这一步。\n\n## Step by Step 操作 ​\n\n### Step 1：访问 Zeabur 并登录 ​\n\n打开浏览器，访问 zeabur.com。\n\n点击右上角的\"登录\"按钮，选择\"使用 GitHub 登录\"。\n\n[配图建议] 画面内容：Zeabur 首页，箭头指向右上角的登录按钮 Prompt：clean screenshot style illustration of a modern web dashboard homepage, login button highlighted, minimal design, light background, soft shadows, 8k --ar 16:9\n\n你应该看到：GitHub 授权页面，询问是否允许 Zeabur 访问你的账号。\n\n点击\"Authorize\"（授权）。\n\n### Step 2：创建项目 ​\n\n登录后，你会看到 Zeabur 的控制台。\n\n点击\"创建项目\"（Create Project）按钮。\n\n[配图建议] 画面内容：Zeabur 控制台，突出显示\"创建项目\"按钮 Prompt：minimal dashboard interface illustration, create project button prominently displayed, clean layout, pastel colors, professional look, 8k --ar 16:9\n\n你应该看到：弹出一个对话框，让你选择服务器区域。\n\n### Step 3：选择服务器区域 ​\n\n在弹出的对话框中，选择服务器区域。\n\n推荐选择：\n\n- 如果你在中国大陆：选择 Asia（亚洲）或 Hong Kong（香港）\n- 如果你在其他地区：选择离你最近的区域\n选择后点击\"创建\"。\n\n你应该看到：一个空的项目面板，显示\"添加服务\"按钮。\n\n### Step 4：添加服务 ​\n\n在项目面板中，点击\"添加服务\"（Add Service）。\n\n在弹出的菜单中，选择\"部署你的代码\"（Deploy your code）或\"Git\"。\n\n[配图建议] 画面内容：服务选择菜单，突出\"部署代码\"选项 Prompt：dropdown menu UI illustration, deploy code option highlighted, modern interface design, clean white background, subtle shadows, 8k --ar 16:9\n\n### Step 5：授权并选择仓库 ​\n\n如果是第一次使用，Zeabur 会请求访问你的 GitHub 仓库。\n\n点击\"配置 GitHub\"，然后选择\"授权所有仓库\"或仅授权你的待办清单仓库。\n\n授权完成后，你会看到你的 GitHub 仓库列表。\n\n找到并选择你在第四章创建的待办清单仓库（比如 `my-todo-list`）。\n\n你应该看到：Zeabur 开始检测你的项目类型。\n\n### Step 6：等待构建 ​\n\n选择仓库后，Zeabur 会自动开始构建你的项目。\n\n这个过程通常需要 1-3 分钟。你可以看到构建日志实时滚动。\n\n你应该看到：\n\n- 状态从\"Building\"变成\"Deploying\"\n- 最终变成绿色的\"Running\"\n构建需要时间\n\n第一次构建可能需要 2-3 分钟，耐心等待。如果超过 5 分钟还没完成，可能是项目有问题。\n\n### Step 7：生成域名 ​\n\n构建成功后，你的服务会显示为\"Running\"状态。\n\n但此时还没有公开网址。你需要为它生成一个域名。\n\n- 点击你的服务（待办清单）\n- 在服务详情页，找到\"网络\"（Networking）选项卡\n- 点击\"生成域名\"（Generate Domain）\n[配图建议] 画面内容：服务详情页的网络选项卡，突出\"生成域名\"按钮 Prompt：web dashboard networking settings, generate domain button highlighted, clean interface, light theme, professional design, 8k --ar 16:9\n\n你应该看到：系统自动生成一个类似 `your-project-abc123.zeabur.app` 的域名。\n\n### Step 8：访问你的网站 ​\n\n点击生成的域名链接，或者复制链接在新标签页打开。\n\n你应该看到：你的待办清单页面，和在本地看到的一模一样。\n\n恭喜！你的作品现在已经在互联网上了。\n\n## 成功验证清单 ​\n\n完成部署后，逐项验证：\n\n- [ ] 服务状态显示绿色的\"Running\"\n- [ ] 点击域名链接能打开页面\n- [ ] 页面显示正常，样式没有丢失\n- [ ] 可以正常添加、删除、完成任务\n- [ ] 用手机浏览器打开链接，也能正常访问\n最后一项尤其重要——这证明了你的网站真的可以从任何设备访问。\n\n## 常见问题 ​\n问题可能原因解决方法构建失败代码有语法错误先在本地确认项目能正常运行页面空白入口文件路径不对确保 `index.html` 在项目根目录样式丢失CSS 路径使用了绝对路径改用相对路径，如 `./style.css`功能不工作JavaScript 报错打开浏览器控制台查看错误信息\n## 遇到问题？让 AI 帮你 ​\n\n如果部署过程中遇到问题，可以把错误信息发给 AI：\n\n`我在 Zeabur 上部署我的待办清单项目，遇到了这个错误：\n\n[粘贴错误信息]\n\n我的项目是一个纯 HTML/CSS/JavaScript 的静态网站。\n请帮我分析原因并给出解决方案。`恭喜你\n\n如果你成功看到了自己的待办清单网页，这意味着你已经完成了从\"本地开发\"到\"全球发布\"的跨越。这是一个了不起的里程碑。\n\n→ 5.2.4 Vercel 部署实战",
      "word_count": 2886,
      "estimated_time": 5
    },
    {
      "id": "lesson-143",
      "chapter_id": "chapter-05",
      "lesson_number": 10,
      "title": "5.2.4 Vercel 部署实战",
      "content": "# 5.2.4 Vercel 部署实战：海外用户/有域名用户 ​\n\nVercel 是全球最流行的前端部署平台之一，尤其适合 Next.js、React 等现代前端框架。它的自动检测和部署流程非常智能，几乎不需要任何配置。\n\n中国大陆用户请注意\n\nVercel 的免费域名 `*.vercel.app` 在中国大陆无法正常访问。如果你在大陆且没有自定义域名，建议使用 Zeabur（参见 5.2.3）。\n\n本节适合以下读者：\n\n- 你在海外\n- 你有自己的域名，准备用 Cloudflare 代理\n- 你想了解 Vercel 的使用方法，为将来做准备\n## Vercel 2025 年 Hobby 计划（免费） ​\n资源限制快速数据传输100GB/月Edge 请求100 万次/月CPU 时间4 小时/月项目数量最多 200 个每日部署次数100 次构建时间每次最多 45 分钟\n对于个人项目来说，这些额度完全够用。\n\n## 准备工作 ​\n\n- [ ] 项目已上传到 GitHub\n- [ ] 有 GitHub 账号\n- [ ] （可选）有自己的域名\n## Step by Step 操作 ​\n\n### Step 1：访问 Vercel 并登录 ​\n\n打开浏览器，访问 vercel.com。\n\n点击右上角的\"Sign Up\"或\"Log In\"，选择\"Continue with GitHub\"。\n\n[配图建议] 画面内容：Vercel 首页，突出 GitHub 登录选项 Prompt：modern landing page illustration, GitHub login button highlighted, dark theme with purple accents, clean design, professional, 8k --ar 16:9\n\n你应该看到：GitHub 授权页面。点击\"Authorize Vercel\"。\n\n### Step 2：进入控制台 ​\n\n登录后，你会看到 Vercel 的 Dashboard。\n\n如果是新用户，页面会引导你创建第一个项目。\n\n### Step 3：导入项目 ​\n\n点击\"Add New...\"按钮，选择\"Project\"。\n\n或者直接点击\"Import Project\"。\n\n你应该看到：一个让你选择 Git 仓库的页面。\n\n### Step 4：选择仓库 ​\n\n在\"Import Git Repository\"区域，你会看到你的 GitHub 仓库列表。\n\n如果看不到仓库，点击\"Adjust GitHub App Permissions\"去授权。\n\n找到你的待办清单项目，点击\"Import\"。\n\n[配图建议] 画面内容：仓库列表页面，突出 Import 按钮 Prompt：dashboard interface showing repository list, import button highlighted, modern UI design, dark theme, clean layout, 8k --ar 16:9\n\n### Step 5：配置项目 ​\n\nVercel 会自动检测你的项目类型。\n\n对于我们的待办清单（纯 HTML/CSS/JS），通常不需要任何配置。\n\n检查以下设置：\n\n- Framework Preset：如果是纯 HTML，选择\"Other\"\n- Root Directory：保持默认（`.`）\n- Build Command：留空（纯静态项目不需要构建）\n- Output Directory：留空或填 `.`\n你应该看到：配置页面，大部分选项已自动填好。\n\n### Step 6：部署 ​\n\n确认配置无误后，点击\"Deploy\"按钮。\n\nVercel 会开始构建和部署你的项目。这通常需要 30 秒到 2 分钟。\n\n你应该看到：\n\n- 实时的构建日志\n- 状态从\"Building\"变成\"Ready\"\n- 出现庆祝动画和预览图\n### Step 7：获得网址 ​\n\n部署成功后，Vercel 会给你一个网址，格式类似：\n\n`https://your-project-name.vercel.app`点击这个链接，查看你的网站。\n\n再次提醒\n\n如果你在中国大陆，这个链接可能无法访问。解决方案见 5.2.6 大陆访问解决方案。\n\n## 成功验证清单 ​\n\n- [ ] 部署状态显示\"Ready\"\n- [ ] 点击链接能打开页面（海外访问）\n- [ ] 页面功能正常\n- [ ] 在 Vercel Dashboard 中能看到项目\n## Vercel 的特色功能 ​\n\nVercel 有一些很实用的功能，了解一下：\n功能说明Preview Deployments每次 Push 都会生成一个预览链接自动 HTTPS所有网站自动启用 HTTPS边缘网络全球 CDN 加速回滚一键回滚到之前的版本\n## 遇到问题？让 AI 帮你 ​\n\n`我在 Vercel 上部署项目时遇到了问题：\n\n[粘贴错误信息]\n\n项目是一个纯 HTML/CSS/JavaScript 的静态网站。\n请帮我分析原因。`→ 5.2.5 部署后的实用操作",
      "word_count": 2169,
      "estimated_time": 4
    },
    {
      "id": "lesson-144",
      "chapter_id": "chapter-05",
      "lesson_number": 11,
      "title": "5.2.5 部署后的实用操作",
      "content": "# 5.2.5 部署后的实用操作 ​\n\n部署成功只是开始。你会持续改进你的项目，需要知道如何更新线上版本、如何查看部署状态、以及出问题时如何回滚。\n\n## 如何更新网站 ​\n\n这是最常用的操作。当你在本地修改了代码，想让线上版本也更新，你需要做的是：\n\n`本地修改代码 → git add → git commit → git push → 自动部署`具体步骤：\n\n- 在本地修改你的代码（比如改了一个按钮的颜色）\n- 使用 GitHub Desktop 提交更改\n- 点击\"Push origin\"推送到 GitHub\n- 等待 1-2 分钟\n- 刷新你的网站，看到更新\n你不需要重新登录部署平台，也不需要点击任何部署按钮。Zeabur 和 Vercel 都会自动检测你的代码更新，并自动重新部署。\n\n这就是\"持续部署\"（Continuous Deployment）的魔力。\n\n## 如何查看部署历史 ​\n\n每次代码更新后的部署都会留下记录。你可以在部署平台的控制台中查看：\n\n### 在 Zeabur 中 ​\n\n- 登录 Zeabur 控制台\n- 点击你的项目\n- 点击你的服务\n- 找到\"部署记录\"或\"Deployments\"选项卡\n你可以看到：\n\n- 每次部署的时间\n- 部署是成功还是失败\n- 每次部署对应的 Git 提交\n### 在 Vercel 中 ​\n\n- 登录 Vercel Dashboard\n- 点击你的项目\n- 点击\"Deployments\"选项卡\n每次 Git Push 都会产生一条部署记录，甚至每个分支都有独立的预览链接。\n\n## 如何回滚到之前的版本 ​\n\n如果你更新后发现网站出了问题，可以快速回滚到之前正常的版本。\n\n### 在 Zeabur 中 ​\n\n- 找到部署历史\n- 找到之前正常的部署记录\n- 点击\"重新部署\"或\"Redeploy\"\n### 在 Vercel 中 ​\n\n- 在 Deployments 页面找到之前的部署\n- 点击右侧的三个点菜单\n- 选择\"Promote to Production\"\n回滚是即时的，通常几秒钟就能生效。\n\n## 如何查看部署日志 ​\n\n当部署失败时，日志是排查问题的关键。\n\n在部署记录中，点击具体的某次部署，可以看到：\n\n- 构建日志：项目是如何被构建的\n- 运行日志：项目运行时的输出\n如果看到红色的错误信息，可以复制给 AI 帮你分析。\n\n## 自定义域名（进阶预告） ​\n\n现在你使用的是平台提供的免费域名：\n\n- Zeabur：`your-project.zeabur.app`\n- Vercel：`your-project.vercel.app`\n如果你想要自己的域名（如 `my-todo.com`），需要：\n\n- 购买域名（阿里云、腾讯云、Cloudflare 等）\n- 在部署平台中绑定域名\n- 配置 DNS 记录\n这些操作稍微复杂一些，属于进阶版的内容。对于学习和个人使用来说，免费域名完全够用。\n\n进阶版预告\n\n在进阶版中，你将学习如何购买和配置自定义域名，以及如何使用 Cloudflare 加速你的网站。\n\n→ 5.2.6 大陆访问解决方案",
      "word_count": 1324,
      "estimated_time": 3
    },
    {
      "id": "lesson-145",
      "chapter_id": "chapter-05",
      "lesson_number": 12,
      "title": "5.2.6 大陆访问解决方案（可选）",
      "content": "# 5.2.6 大陆用户的访问解决方案 ​\n\n如果你在中国大陆，或者你的用户在大陆，需要特别注意访问问题。本节介绍几种解决方案。\n\n## 为什么会有访问问题 ​\n\nVercel、Netlify 等海外平台的默认域名（如 `*.vercel.app`）被 DNS 污染，导致大陆用户无法正常访问或访问很慢。\n\n这不是你的代码问题，而是网络环境问题。\n\n## 解决方案汇总 ​\n方案难度成本推荐场景使用 Zeabur简单免费首选方案使用帽子云简单免费纯静态网站EdgeOne Pages中等免费（公测）腾讯云用户21YunBox简单免费Hugo 等静态框架Cloudflare 代理复杂需购买域名已用 Vercel 的进阶用户\n## 方案一：直接用 Zeabur（推荐） ​\n\n最简单的方案。Zeabur 的免费域名 `*.zeabur.app` 在大陆可以正常访问。\n\n参见 5.2.3 Zeabur 部署实战。\n\n## 方案二：帽子云（纯静态网站） ​\n\n帽子云是一个国产的静态网站托管平台，类似于国内版的 GitHub Pages。\n\n特点：\n\n- 完全免费\n- 国内 CDN 节点，访问速度快\n- 支持 GitHub 自动部署\n- 支持自定义域名\n适合：纯 HTML/CSS/JS 的静态网站（比如我们的待办清单）\n\n官网：maoziyun.com\n\n### 使用步骤简述 ​\n\n- 注册帽子云账号\n- 连接你的 GitHub 仓库\n- 选择要部署的分支\n- 等待自动部署完成\n- 获得 `*.maoziyun.com` 域名\n## 方案三：EdgeOne Pages（腾讯云） ​\n\nEdgeOne Pages 是腾讯云推出的前端部署平台，目前处于公测阶段，免费使用。\n\n特点：\n\n- 公测期免费\n- 腾讯云全球边缘网络加速\n- 支持 Next.js、React、Vue 等现代框架\n- 大陆访问速度很快\n适合：已有腾讯云账号的用户，或需要更好国内访问速度的项目\n\n官网：edgeone.ai\n\n### 注意事项 ​\n\nEdgeOne Pages 的配置比 Zeabur 稍微复杂一些，需要熟悉腾讯云的控制台。如果你是第一次部署，建议先用 Zeabur。\n\n## 方案四：21YunBox ​\n\n21YunBox 是专门针对中国大陆用户的托管平台，对 Hugo、Jekyll 等静态站点生成器支持很好。\n\n特点：\n\n- 国内 CDN 加速\n- 支持 Gitee 部署（不需要 GitHub）\n- 自动 SSL 证书\n- 持续部署\n官网：21yunbox.com\n\n## 方案五：Cloudflare 代理（进阶） ​\n\n如果你已经在 Vercel 上部署了项目，又想让大陆用户访问，可以通过 Cloudflare 代理来解决。\n\n### 前提条件 ​\n\n- 购买一个自己的域名（约 10-50 元/年）\n- 注册 Cloudflare 账号（免费）\n### 步骤概要 ​\n\n- 在 Cloudflare 注册账号\n- 添加你的域名到 Cloudflare\n- 在域名注册商处，将 DNS 服务器改为 Cloudflare 提供的\n- 在 Vercel 中添加自定义域名\n- 在 Cloudflare 添加 CNAME 记录指向 Vercel\n- 确保 Cloudflare 代理已开启（橙色云朵图标）\n### 这个方案的优缺点 ​\n优点缺点可以继续使用 Vercel需要购买域名有自己的专属域名配置步骤较多Cloudflare 有全球 CDN需要等待 DNS 生效\n基础版建议\n\n如果你刚开始学习，不建议现在折腾 Cloudflare 配置。先用 Zeabur 或帽子云把网站跑起来，等进阶版再学习域名和 CDN 相关知识。\n\n## 如何选择 ​\n\n`你需要大陆访问吗？\n├── 是\n│   ├── 纯静态网站 → 帽子云（免费）或 Zeabur\n│   ├── 需要服务端功能 → Zeabur\n│   └── 已有腾讯云账号 → EdgeOne Pages\n└── 否 → 直接用 Vercel / Netlify`→ 5.2.7 其他部署选择",
      "word_count": 1727,
      "estimated_time": 3
    },
    {
      "id": "lesson-146",
      "chapter_id": "chapter-05",
      "lesson_number": 13,
      "title": "5.2.7 其他部署选择",
      "content": "# 5.2.7 其他部署选择 ​\n\n除了 Zeabur 和 Vercel，还有一些其他的部署平台可以选择。这里做简要介绍，供参考。\n\n## Netlify：拖拽部署 ​\n\nNetlify 是另一个流行的静态网站托管平台，它最大的特点是支持\"拖拽部署\"。\n\n### 使用方法 ​\n\n- 打开 Netlify Drop\n- 把你的项目文件夹直接拖进浏览器页面\n- 等待几秒钟，部署完成\n- 获得一个 `*.netlify.app` 的网址\n[配图建议] 画面内容：Netlify Drop 页面，展示拖拽区域 Prompt：web interface showing drag and drop zone, file folder being dragged, clean modern design, light background, 8k --ar 16:9\n\n### 优缺点 ​\n优点缺点操作极简，拖拽即可更新需要重新拖拽不需要 GitHub 账号大陆访问有问题秒级部署不适合频繁更新的项目\n适合：临时演示、一次性项目、不想折腾 Git 的情况。\n\n### 持续部署方式 ​\n\n如果想要代码更新后自动部署，可以：\n\n- 注册 Netlify 账号\n- 连接 GitHub 仓库\n- 配置构建设置\n这样就和 Zeabur、Vercel 一样，Push 后自动部署了。\n\n## GitHub Pages：完全免费 ​\n\nGitHub Pages 是 GitHub 提供的静态网站托管服务，完全免费，无需任何额外账号。\n\n### 基本原理 ​\n\nGitHub Pages 会把你仓库中的 HTML 文件直接发布成网站。\n\n### 使用方法概要 ​\n\n- 确保你的仓库是 public（公开）\n- 确保有一个 `index.html` 文件\n- 进入仓库的 Settings → Pages\n- 选择要部署的分支（通常是 main）\n- 等待几分钟，获得 `username.github.io/repo-name` 的网址\n### 优缺点 ​\n优点缺点完全免费仅支持静态网站与 GitHub 深度集成大陆访问不稳定支持自定义域名配置略复杂\n适合：个人博客、文档站点、开源项目主页。\n\n进阶版预告\n\nGitHub Pages 的详细配置和 GitHub Actions 自动部署将在进阶版中讲解。\n\n## Railway：免费额度较少 ​\n\nRailway 是一个全栈应用部署平台，支持前端、后端、数据库一站式部署。\n\n特点：\n\n- 支持多种语言和框架\n- 提供数据库服务\n- 免费额度每月 $5\n官网：railway.app\n\n适合：需要后端服务的项目。对于我们的纯前端待办清单，Railway 有点\"杀鸡用牛刀\"。\n\n## Render：全栈部署 ​\n\nRender 类似于 Railway，是一个全栈部署平台。\n\n特点：\n\n- 免费层支持静态网站\n- 支持后端服务和数据库\n- 自动从 Git 部署\n官网：render.com\n\n## Cloudflare Pages：边缘部署 ​\n\nCloudflare Pages 是 Cloudflare 提供的静态网站托管服务。\n\n特点：\n\n- 完全免费\n- 全球边缘网络加速\n- 与 Cloudflare 生态深度集成\n限制：\n\n- 大陆访问需要额外配置\n- 配置比 Zeabur 稍复杂\n官网：pages.cloudflare.com\n\n## 如何选择 ​\n\n对于基础版的学习，不需要纠结于这些选择。建议：\n\n- 大陆用户：用 Zeabur\n- 海外用户：用 Vercel\n- 临时演示：用 Netlify Drop\n等你完成基础版学习，有更多需求时，再探索其他平台。\n\n→ 5.2.8 部署常见问题",
      "word_count": 1574,
      "estimated_time": 3
    },
    {
      "id": "lesson-147",
      "chapter_id": "chapter-05",
      "lesson_number": 14,
      "title": "5.2.8 部署常见问题",
      "content": "# 5.2.8 部署常见问题 ​\n\n部署过程中遇到问题是正常的。这里整理了最常见的问题和解决方案。\n\n## 问题速查表 ​\n问题可能原因解决方法部署失败代码有语法错误先在本地确认能正常运行页面空白入口文件路径不对确保 `index.html` 在项目根目录样式丢失CSS 路径使用了绝对路径改用相对路径（如 `./style.css`）图片不显示图片路径错误或文件名大小写检查路径和文件名大小写功能不工作JavaScript 报错打开浏览器控制台（F12）查看错误大陆无法访问DNS 污染换用 Zeabur 或帽子云加载很慢资源文件太大压缩图片，检查是否有不必要的大文件更新后没变化浏览器缓存强制刷新（Ctrl+F5）或清除缓存\n## 问题详解 ​\n\n### 问题 1：部署失败，构建报错 ​\n\n现象：点击部署后，状态一直显示\"Building\"然后变成\"Failed\"。\n\n排查步骤：\n\n- 查看构建日志，找到红色的错误信息\n- 检查本地项目是否能正常运行\n- 确认所有必要的文件都已提交到 GitHub\n常见原因：\n\n- 代码有语法错误\n- 缺少必要的配置文件\n- 依赖没有正确安装\nAI 求助模板：\n\n`我在 [Zeabur/Vercel] 上部署项目时，构建失败了。\n\n构建日志显示这个错误：\n[粘贴红色的错误信息]\n\n我的项目是一个 [纯 HTML/CSS/JS 静态网站 / React 项目 / ...]。\n本地运行是 [正常的 / 也有问题]。\n\n请帮我分析原因并给出解决方案。`\n### 问题 2：页面空白 ​\n现象：部署成功了，但打开网址是空白页面。\n\n排查步骤：\n\n- 打开浏览器开发者工具（F12）\n- 查看 Console（控制台）是否有红色错误\n- 查看 Network（网络）是否有 404 错误\n常见原因：\n\n- `index.html` 不在根目录\n- JavaScript 文件路径错误导致脚本加载失败\n- 使用了绝对路径，线上环境找不到文件\n解决方法：\nhtml\n`<!-- 错误：绝对路径 -->\n<script src=\"/js/app.js\"></script>\n\n<!-- 正确：相对路径 -->\n<script src=\"./js/app.js\"></script>`\n### 问题 3：样式丢失 ​\n现象：页面能显示，但样式完全乱了，或者没有样式。\n\n常见原因：\n\n- CSS 文件路径错误\n- CSS 文件没有被提交到 GitHub\n- 使用了绝对路径\n解决方法：\nhtml\n`<!-- 错误 -->\n<link rel=\"stylesheet\" href=\"/style.css\">\n\n<!-- 正确 -->\n<link rel=\"stylesheet\" href=\"./style.css\">`\n### 问题 4：功能不工作 ​\n现象：页面显示正常，但按钮点击没反应，功能不工作。\n\n排查步骤：\n\n- 打开浏览器控制台（F12 → Console）\n- 查看是否有红色错误信息\n- 尝试触发功能，看是否有新的错误出现\nAI 求助模板：\n\n`我的待办清单部署后，[添加任务 / 删除任务 / ...] 功能不工作了。\n\n浏览器控制台显示这个错误：\n[粘贴错误信息]\n\n本地运行时功能是正常的。\n请帮我分析原因。`\n### 问题 5：更新后网站没变化 ​\n现象：代码已经推送到 GitHub，但网站还是旧版本。\n\n可能原因：\n\n- 部署还没完成（去控制台查看状态）\n- 浏览器缓存\n解决方法：\n\n- 等待部署完成（通常 1-2 分钟）\n- 强制刷新页面：Windows 按 `Ctrl+F5`，Mac 按 `Cmd+Shift+R`\n- 打开隐私模式/无痕模式访问\n## 万能解决方案 ​\n\n当你遇到任何部署问题时，都可以用这个模板向 AI 求助：\n\n`我在部署网站时遇到了问题。\n\n【环境信息】\n- 部署平台：[Zeabur / Vercel / Netlify / ...]\n- 项目类型：[纯 HTML/CSS/JS / React / Vue / ...]\n- 本地运行：[正常 / 有问题]\n\n【问题描述】\n[描述你遇到的具体问题]\n\n【错误信息】\n[粘贴完整的错误信息，包括构建日志或浏览器控制台的错误]\n\n【已尝试的方法】\n[列出你已经尝试过的解决方法]\n\n请帮我分析原因并给出解决方案。`记住\n\n遇到问题不要慌。部署问题通常都有明确的错误信息，把错误信息发给 AI，大多数问题都能快速解决。\n\n→ 5.2.9 本节检查清单",
      "word_count": 1895,
      "estimated_time": 3
    },
    {
      "id": "lesson-148",
      "chapter_id": "chapter-05",
      "lesson_number": 15,
      "title": "5.2.9 本节检查清单",
      "content": "# 5.2.9 本节检查清单 ​\n\n完成本节学习后，逐项确认你已经掌握了以下内容。\n\n## 知识检查 ​\n\n- [ ] 理解了\"部署\"的含义：把代码放到服务器上，让所有人都能访问\n- [ ] 知道 Zeabur 和 Vercel 的区别，以及为什么大陆用户建议用 Zeabur\n- [ ] 了解了代码更新后自动部署的工作原理\n## 操作检查 ​\n\n- [ ] 注册了部署平台账号（Zeabur 或 Vercel）\n- [ ] 成功部署了第四章的待办清单项目\n- [ ] 获得了一个可公开访问的网址\n- [ ] 在浏览器中验证了网站功能正常\n- [ ] 在手机上验证了可以正常访问（这一条很重要）\n## 进阶检查（可选） ​\n\n- [ ] 尝试修改代码，提交更新，验证自动部署生效\n- [ ] 把网址分享给朋友或家人，让他们试用\n- [ ] 了解了部署失败时如何排查问题\n## 本节核心要点 ​\n\n经过本节学习，你应该掌握了：\n能力具体表现部署网站能独立将本地项目部署到互联网上平台选择知道根据自己的情况选择合适的部署平台问题排查遇到部署问题时知道如何查看日志和求助 AI持续更新理解 Push 即部署的工作流程\n## 你现在拥有了什么 ​\n\n完成本节后，你已经：\n\n- 拥有了一个真正的网址（如 `my-todo.zeabur.app`）\n- 可以让任何人通过这个链接访问你的作品\n- 具备了将任何项目发布到互联网的能力\n- 你的作品 24 小时在线，不需要开着电脑\n这是一个了不起的里程碑。\n\n从第四章到现在，你完成了：\n\n- 从零开始做出一个待办清单\n- 把代码上传到 GitHub 保管\n- 把网站发布到互联网上\n你已经走完了从\"想法\"到\"产品\"的完整流程。\n\n恭喜你\n\n你的作品现在全世界都能看到了。这不是终点，而是新的起点。\n\n接下来，我们会学习如何保护你的作品和数据安全。\n\n## 下一步行动 ​\n\n- 把你的网址分享给朋友或家人，让他们体验一下\n- 在手机上试试你的待办清单，感受\"随时随地使用\"的便利\n- 准备好进入下一节：学习 AI 时代的安全意识\n→ 5.3 护城河：AI 时代的安全意识",
      "word_count": 904,
      "estimated_time": 3
    },
    {
      "id": "lesson-149",
      "chapter_id": "chapter-05",
      "lesson_number": 16,
      "title": "5.3.0 2025年安全现状：触目惊心的数字",
      "content": "# 5.3.0 2025年安全现状：触目惊心的数字 ​\n\n这些不是危言耸听，而是 2024-2025 年权威机构发布的真实数据。\n\n经过本节学习，你将了解：\n\n- AI 生成代码的安全风险有多普遍\n- 密钥泄露问题有多严重\n- 为什么现在就要重视安全\n## AI 生成代码的安全风险 ​\n\n来源：Veracode 2025 GenAI Code Security Report\n\nVeracode 在 2025 年测试了超过 100 个大语言模型，分析它们生成的 Java、Python、JavaScript、C# 代码。结果令人担忧：\n数据含义45%AI 生成的代码未通过安全测试72%Java 代码的安全失败率（所有语言中最高）86%AI 未能防御跨站脚本攻击的比例88%AI 未能防御日志注入攻击的比例\n更值得注意的是：更新、更大的模型并没有产生更安全的代码。安全性能在过去几年几乎没有改善。\n\n## 密钥泄露危机 ​\n\n来源：GitHub 2025、GitGuardian 2025、Verizon DBIR 2025\n数据来源含义3900 万GitHub 20252024 年在 GitHub 上检测到的泄露密钥数量2380 万GitGuardian 20252024 年公开仓库新增的泄露凭证（同比增长 25%）70%GitGuardian 20252022 年泄露的密钥至今仍然有效35%GitGuardian 2025私有仓库包含明文密钥的比例94 天Verizon DBIR 2025泄露密钥的平均修复时间\n这意味着：攻击者平均有 3 个月的时间窗口 来利用泄露的密钥。\n\n## 顶级公司也难逃一劫 ​\n数据含义65%Forbes AI 50 榜单中的顶级 AI 公司曾在 GitHub 上泄露过凭证$488 万涉及凭证泄露的数据泄露事件平均成本（IBM 2024）\n如果连这些技术最先进的公司都会犯错，普通开发者更需要警惕。\n\n## 新兴威胁：包幻觉攻击 ​\n\n来源：德克萨斯大学、俄克拉荷马大学、弗吉尼亚理工联合研究（2025）\n数据含义19.7%AI 推荐的软件包实际上不存在21.7%开源模型的包幻觉率5.2%GPT 系列模型的包幻觉率（相对较低）58%幻觉包名会重复出现，可被攻击者预测\n攻击者已经开始利用这个漏洞：注册 AI 常\"幻觉\"出来的包名，植入恶意代码，等待开发者上钩。\n\n## 这些数字意味着什么 ​\n\n核心信息\n\n这些数字不是为了吓你，而是告诉你一个事实：\n\nAI 编程的安全风险是真实存在的，不是\"以后再说\"的事情。\n\n但好消息是：只要了解规则，大部分风险都可以轻松避免。\n\n接下来的几节会告诉你具体怎么做。\n\n→ 5.3.1 为什么这一节很重要",
      "word_count": 1145,
      "estimated_time": 3
    },
    {
      "id": "lesson-150",
      "chapter_id": "chapter-05",
      "lesson_number": 17,
      "title": "5.3.1 为什么这一节很重要",
      "content": "# 5.3.1 为什么这一节很重要 ​\n\n## 真实案例：10 分钟损失数千美元 ​\n\n这是 2024-2025 年间反复发生的场景：\n\n- 开发者用 AI 生成代码\n- AI 把 API 密钥直接写进了代码里\n- 代码被上传到 GitHub（即使是私有仓库也不安全）\n- 几分钟后，账户被盗刷\n2024 年 11 月，区块链项目 Pump Science 就因为 GitHub 密钥泄露，导致攻击者创建了欺诈性代币，造成用户损失。\n\n## 大规模凭证盗窃事件 ​\n\n2024 年 10 月，安全研究人员发现了代号为 EMERALDWHALE 的攻击行动：\n\n- 攻击者扫描了约 5 亿个 IP 地址\n- 从暴露的 Git 配置文件中窃取了超过 15,000 个云服务凭证\n- 涉及 10,000+ 个私有代码仓库\n- 被盗凭证被用于钓鱼攻击和垃圾邮件\n这些凭证包括 AWS 密钥、数据库连接字符串、API Token——都是开发者\"不小心\"提交到代码库里的。\n\n## 为什么 AI 编程时代风险更高 ​\n\n还记得第三章提到的 AI 幻觉吗？在安全领域，AI 的\"不靠谱\"可能直接导致：\nAI 行为安全后果把密钥当作\"示例\"写进代码密钥泄露推荐不存在的软件包可能安装恶意代码跳过输入验证留下安全漏洞使用过时的加密方式数据容易被破解\n根据 Veracode 2025 报告，当 AI 在\"安全写法\"和\"不安全写法\"之间做选择时，45% 的情况下会选择不安全的方式。\n\n## 好消息 ​\n\n只要知道规则，就能轻松避免。\n\n接下来的几节会教你：\n\n- 什么是绝对不能做的（三大禁令）\n- 如何检查代码中的安全隐患\n- 如何识别 AI 推荐的可疑软件包\n- 如何养成安全审查习惯\n这些知识会让你比 90% 的初学者更安全。\n\n→ 5.3.2 绝对禁区：永远不要告诉 AI",
      "word_count": 781,
      "estimated_time": 3
    },
    {
      "id": "lesson-151",
      "chapter_id": "chapter-05",
      "lesson_number": 18,
      "title": "5.3.2 绝对禁区：永远不要告诉 AI",
      "content": "# 5.3.2 绝对禁区：永远不要告诉 AI 的东西 ​\n\n经过本节学习，你将掌握：\n\n- 哪些信息绝对不能发送给 AI\n- 为什么这些信息会带来风险\n- 如果已经发送了该怎么补救\n- 如何安全地让 AI 帮你处理敏感场景\n## 绝对禁令清单 ​\n\n永远不要在与 AI 对话时发送以下内容：\n类型示例为什么危险API 密钥`sk-abc123...`、`AKIA...`可被用于消费你的账户，或访问你的云服务数据库连接字符串`postgres://user:pass@host/db`攻击者可直接访问你的数据库密码任何真实密码身份被盗用，账户被入侵私钥/证书`-----BEGIN RSA PRIVATE KEY-----`可用于伪装成你的身份，入侵你的系统个人身份信息身份证号、银行卡号、社保号隐私泄露，可能被用于诈骗公司/学校机密内部文档、客户数据、商业秘密数据泄露，可能违反保密协议Token/SessionJWT token、登录凭证可用于冒充你的登录状态\n## 为什么 AI 对话不安全 ​\n\n你可能会想：我用的是正规的 AI 服务，应该没问题吧？\n\n事实上，风险来自多个方面：\n\n- 训练数据：部分 AI 服务可能将对话用于模型训练，你的信息可能被\"记住\"\n- 日志记录：对话内容可能被记录在服务器上\n- 数据泄露：即使是大公司也可能发生数据泄露事件\n- 员工访问：某些情况下，服务提供商的员工可能有权限查看对话\n核心原则\n\n假设你发送给 AI 的任何内容都可能被公开。\n\n如果你不愿意把某条信息贴在公告栏上，就不要发送给 AI。\n\n## 常见危险场景 ​\n\n### 场景一：让 AI 检查密钥 ​\n\n`❌ 错误做法：\n\"帮我检查这个 OpenAI API Key 格式对不对：sk-proj-abc123xyz...\"\n\n✅ 正确做法：\n\"OpenAI API Key 的格式是什么样的？\"`\n### 场景二：让 AI 帮忙调试连接问题 ​\n\n```\n❌ 错误做法：\n\"我的数据库连接失败了，连接字符串是 postgres://admin:MyP@ssw0rd@db.example.com/mydb\"\n\n✅ 正确做法：\n\"我的 PostgreSQL 连接失败了，错误信息是 'connection refused'，可能是什么原因？\"\n```\n\n### 场景三：让 AI 帮忙写配置文件 ​\n\n```\n❌ 错误做法：\n\"帮我写一个 .env 文件，我的 Stripe 密钥是 sk_live_xxx...\"\n\n✅ 正确做法：\n\"帮我写一个 .env 文件的模板，包含 Stripe 配置项，用占位符表示\"\n```\n\n## 如果已经发送了怎么办 ​\n如果你不小心发送了敏感信息，立即采取以下步骤：\n步骤行动说明1立即更换更换泄露的密钥/密码，不要等到\"有空再说\"2检查使用记录查看相关服务的使用日志，是否有异常活动3设置告警如果服务支持，开启异常使用告警4清除对话如果 AI 服务支持，删除包含敏感信息的对话5记录教训下次更加小心\n## 安全替代方案 ​\n\n那么，如何让 AI 帮忙处理涉及敏感信息的场景呢？\n\n使用占位符：\njavascript\n`// 让 AI 帮你写这样的代码：\nconst apiKey = process.env.API_KEY;  // 从环境变量读取\nconst dbUrl = process.env.DATABASE_URL;  // 不要硬编码\n\n// 而不是：\nconst apiKey = \"sk-真实密钥\";  // 绝对不要这样`只描述问题，不暴露数据：\n\n`✅ \"我的 API 调用返回 401 错误，可能是什么原因？\"\n✅ \"如何验证一个 JWT token 是否过期？\"\n✅ \"数据库连接超时通常怎么排查？\"`记住\n\nAI 不需要看到你的真实密钥就能帮你解决问题。\n\n就像你问医生\"头疼怎么办\"，不需要把你的病历号告诉 AI。\n\n→ 5.3.3 代码中的安全隐患",
      "word_count": 1663,
      "estimated_time": 3
    },
    {
      "id": "lesson-152",
      "chapter_id": "chapter-05",
      "lesson_number": 19,
      "title": "5.3.3 代码中的安全隐患",
      "content": "# 5.3.3 代码中的安全隐患 ​\n\n经过本节学习，你将掌握：\n\n- AI 常犯的 5 类安全错误\n- 如何识别代码中的硬编码密钥\n- .env 文件的正确使用方法\n- .gitignore 的配置技巧\n## AI 常犯的 5 类安全错误 ​\n\n根据 Veracode 2025 报告和安全社区的分析，AI 生成的代码最常出现以下安全问题：\n\n### 1. 硬编码密钥 ​\n\n这是最常见也最危险的问题。\njavascript\n`// ❌ 危险：密钥直接写在代码里\nconst API_KEY = \"sk-proj-abc123xyz...\";\nconst DB_PASSWORD = \"SuperSecret123\";\n\n// ✅ 安全：使用环境变量\nconst API_KEY = process.env.API_KEY;\nconst DB_PASSWORD = process.env.DB_PASSWORD;`\n### 2. 跳过输入验证 ​\nAI 生成的代码往往假设输入是\"正常\"的，不做验证。\njavascript\n`// ❌ 危险：直接使用用户输入\nfunction searchUser(username) {\n  return db.query(`SELECT * FROM users WHERE name = '${username}'`);\n}\n// 攻击者可以输入：' OR '1'='1  来获取所有用户数据\n\n// ✅ 安全：使用参数化查询\nfunction searchUser(username) {\n  return db.query('SELECT * FROM users WHERE name = $1', [username]);\n}`\n### 3. 使用不安全的默认配置 ​\njavascript\n```\n// ❌ 危险：允许所有来源的跨域请求\napp.use(cors({ origin: '*' }));\n\n// ✅ 安全：只允许特定来源\napp.use(cors({ origin: 'https://yoursite.com' }));\n```\n\n### 4. 信息过度暴露 ​\njavascript\n```\n// ❌ 危险：向用户暴露详细错误信息\napp.use((err, req, res, next) => {\n  res.status(500).json({ \n    error: err.message,\n    stack: err.stack,  // 暴露了代码结构\n    dbQuery: err.query // 暴露了数据库查询\n  });\n});\n\n// ✅ 安全：只返回必要信息\napp.use((err, req, res, next) => {\n  console.error(err);  // 在服务器端记录详细信息\n  res.status(500).json({ error: '服务器错误，请稍后重试' });\n});\n```\n\n### 5. 使用过时或存在漏洞的库 ​\nAI 可能推荐一些过时的、存在已知漏洞的库。这个问题我们会在 5.3.5 节详细讨论。\n\n## 如何识别硬编码的密钥 ​\n\n在代码中搜索这些关键词：\n关键词可能是什么`password`、`passwd`、`pwd`密码`secret`、`api_key`、`apikey`API 密钥`token`、`auth`、`bearer`认证令牌`sk-`、`pk-`、`AKIA`特定服务的密钥（OpenAI、AWS 等）`-----BEGIN`私钥或证书\n快速检查方法：\n\n在你的项目文件夹中搜索这些模式。如果看到后面跟着一串看起来像真实密钥的字符串（而不是 `process.env.XXX`），就需要警惕。\n\n## 使用 .env 文件存放敏感信息 ​\n\n`.env` 文件是存放敏感配置的标准方式。\n\n### 创建 .env 文件 ​\n\n在项目根目录创建 `.env` 文件：\nbash\n`# .env 文件示例\n# API 密钥\nOPENAI_API_KEY=sk-proj-你的真实密钥\nSTRIPE_SECRET_KEY=sk_test_你的真实密钥\n\n# 数据库连接\nDATABASE_URL=postgres://user:password@localhost:5432/mydb\n\n# 其他配置\nNODE_ENV=development`\n### 在代码中读取环境变量 ​\njavascript\n```\n// JavaScript/Node.js\nconst apiKey = process.env.OPENAI_API_KEY;\n```\npython\n```\n# Python\nimport os\napi_key = os.environ.get('OPENAI_API_KEY')\n```\n\n### 创建 .env.example 文件 ​\n为了让其他人（或未来的你）知道需要配置哪些环境变量，创建一个 `.env.example` 文件：\nbash\n`# .env.example - 这个文件可以提交到 Git\n# 复制此文件为 .env，然后填入真实值\n\nOPENAI_API_KEY=在这里填入你的密钥\nSTRIPE_SECRET_KEY=在这里填入你的密钥\nDATABASE_URL=在这里填入数据库连接字符串`\n## 配置 .gitignore 防止泄露 ​\n`.gitignore` 文件告诉 Git 哪些文件不应该被上传。\n\n在项目根目录创建或编辑 `.gitignore` 文件：\nbash\n`# 环境变量文件 - 最重要！\n.env\n.env.local\n.env.development\n.env.production\n.env*.local\n\n# 依赖文件夹\nnode_modules/\nvenv/\n__pycache__/\n\n# 编辑器和系统文件\n.DS_Store\nThumbs.db\n.vscode/\n.idea/\n\n# 构建产物\ndist/\nbuild/\n*.log`注意\n\n如果你在添加 `.gitignore` 之前已经提交过 `.env` 文件，仅仅添加 `.gitignore` 是不够的。\n\n你需要：\n\n- 从 Git 历史中删除该文件\n- 立即更换所有已泄露的密钥\n因为 Git 历史是可以被查看的，即使文件被删除。\n\n## 检查你的待办清单项目 ​\n\n回顾你在第四章做的待办清单，检查以下几点：\n\n- [ ] 代码中没有硬编码的密钥或密码\n- [ ] 如果有 API 调用，密钥是从环境变量读取的\n- [ ] `.env` 文件（如果有）已经加入 `.gitignore`\n- [ ] 没有在 console.log 中输出敏感信息\n如果只是一个纯前端的待办清单（使用 localStorage），通常不会有这些问题。但养成检查习惯很重要，因为你以后的项目会越来越复杂。\n\n→ 5.3.4 初学者安全检查清单",
      "word_count": 2924,
      "estimated_time": 5
    },
    {
      "id": "lesson-153",
      "chapter_id": "chapter-05",
      "lesson_number": 20,
      "title": "5.3.4 初学者安全检查清单",
      "content": "# 5.3.4 初学者的安全检查清单 ​\n\n经过本节学习，你将获得：\n\n- 一份可立即使用的安全检查清单\n- 不同场景下的检查要点\n- 快速检查的实用技巧\n## 提交代码前检查清单 ​\n\n每次准备将代码上传到 GitHub 或其他平台之前，请检查：\n\n- [ ] 没有硬编码密钥：代码里没有任何真实的密码、API 密钥或 Token\n- [ ] .env 已被忽略：`.env` 文件已加入 `.gitignore`\n- [ ] 没有敏感日志：`console.log` 或调试语句中没有输出敏感信息\n- [ ] 没有测试数据泄露：测试代码中没有使用真实的用户数据或密钥\n## 部署前检查清单 ​\n\n在将项目部署到互联网之前，额外检查：\n\n- [ ] 环境变量已配置：部署平台上已正确设置所有需要的环境变量\n- [ ] 调试模式已关闭：生产环境没有开启 debug 模式\n- [ ] 错误信息已简化：错误页面不会暴露详细的技术信息\n- [ ] HTTPS 已启用：网站使用 HTTPS 而非 HTTP\n## 定期检查清单 ​\n\n每隔一段时间（比如每月），回顾一下：\n\n- [ ] 密钥是否需要轮换：长期使用的密钥是否应该更换\n- [ ] 依赖是否需要更新：项目使用的库是否有安全更新\n- [ ] 权限是否合理：API 密钥的权限是否只包含必要的范围\n## 快速检查技巧 ​\n\n### 方法一：搜索敏感关键词 ​\n\n在你的代码编辑器中，使用搜索功能查找这些关键词：\n\n`password\nsecret\napi_key\napiKey\ntoken\nsk-\npk-\nAKIA\n-----BEGIN`如果搜索结果中出现了看起来像真实密钥的内容（而不是 `process.env.XXX` 这样的引用），就需要处理。\n\n### 方法二：检查即将提交的文件 ​\n\n如果你使用 Git，在提交前运行：\nbash\n`git diff --cached`这会显示你即将提交的所有更改。快速扫一眼，确认没有敏感信息。\n\n### 方法三：检查 .gitignore 是否生效 ​\n\n确认敏感文件确实被忽略了：\nbash\n`git status`如果 `.env` 文件出现在列表中，说明它没有被正确忽略。\n\n## 常见问题处理 ​\n\n### 问题：我已经不小心提交了 .env 文件 ​\n\n解决步骤：\n\n- 首先，立即更换所有泄露的密钥（这是最重要的）\n- 将 `.env` 加入 `.gitignore`\n- 从 Git 追踪中移除该文件（但不删除本地文件）：bash\n`git rm --cached .env`\n- 提交这个更改：bash\n```\ngit commit -m \"移除敏感文件\"\n```\n重要提醒\n\n即使你删除了文件，Git 历史中仍然保留着它。如果仓库是公开的，密钥已经泄露。\n\n必须更换密钥，没有例外。\n\n### 问题：我不确定某个字符串是不是密钥 ​\n\n判断标准：\n特征可能是密钥可能不是密钥长度较长（20+ 字符）较短内容看起来随机的字母数字有明显含义的单词前缀有特定前缀如 `sk-`、`AKIA`普通前缀位置赋值给类似 `API_KEY` 的变量普通变量\n如果还是不确定，宁可当作密钥处理。\n\n## 养成习惯 ​\n\n安全检查不需要花很多时间。一旦养成习惯，每次提交前花 30 秒扫一眼，就能避免大部分问题。\n\n一个好习惯\n\n每次看到 AI 生成的代码中有类似密钥的长字符串，第一反应应该是：\"这是真实密钥还是占位符？\"\n\n→ 5.3.5 AI 推荐的库安全吗",
      "word_count": 1483,
      "estimated_time": 3
    },
    {
      "id": "lesson-154",
      "chapter_id": "chapter-05",
      "lesson_number": 21,
      "title": "5.3.5 AI 推荐的库安全吗（Slopsquatting）",
      "content": "# 5.3.5 AI 推荐的库安全吗？ ​\n\n经过本节学习，你将了解：\n\n- 什么是 Slopsquatting 攻击\n- 为什么 AI 推荐的库可能有风险\n- 如何验证一个库是否安全\n- 真实的恶意包案例\n## 还记得 AI 幻觉吗？ ​\n\n在第三章，我们讨论过 AI 有时会\"一本正经地胡说八道\"——给出看起来合理但实际上错误的回答。\n\n在安全领域，这种\"幻觉\"会造成严重后果。\n\nAI 可能会推荐根本不存在的软件包。\n\n根据德克萨斯大学等研究机构 2025 年的研究：\n\n- 19.7% 的 AI 推荐的包实际上不存在\n- 开源模型的幻觉率高达 21.7%\n- 即使是 GPT 系列，也有 5.2% 的幻觉率\n- 58% 的幻觉包名会重复出现，可被预测\n## 什么是 Slopsquatting？ ​\n\nSlopsquatting 是 2024-2025 年出现的新型攻击方式，名字来源于：\n\n- Slop：指 AI 生成的\"废话\"或错误内容\n- Squatting：抢注（就像域名抢注一样）\n攻击原理：\n\n`1. 攻击者研究 AI 常\"幻觉\"出的包名\n   （比如 AI 经常推荐一个叫 \"aws-helper-sdk\" 的包，但它不存在）\n\n2. 攻击者抢先注册这个包名\n   （在 npm 或 PyPI 上创建一个真实的 \"aws-helper-sdk\" 包）\n\n3. 在包中植入恶意代码\n   （比如窃取环境变量、下载后门程序）\n\n4. 等待开发者上钩\n   （开发者信任 AI 推荐，直接安装）\n\n5. 恶意代码被执行\n   （开发者的密钥、数据被盗取）`\n## 真实案例 ​\n\n### 案例一：aiocpa 恶意包（2024年11月） ​\nPython 库 aiocpa（一个加密货币支付 API 客户端）被发现：\n\n- 在 0.1.13 版本中植入了恶意代码\n- 会将用户的 Crypto Pay API Token 通过 Telegram Bot 发送给攻击者\n- 该包在被发现前已被下载超过 12,000 次\n### 案例二：solana-systemprogram-utils（2024年12月） ​\n\nnpm 上发现的恶意包：\n\n- 伪装成 Solana 区块链的工具库\n- 会在 2% 的交易中，悄悄将资金转到攻击者地址\n- 因为比例低，很难被立即发现\n### 案例三：GitHub Actions 供应链攻击（2025年9月） ​\n\n代号 GhostAction 的攻击：\n\n- 利用 AI 编程工具生成的 GitHub Actions 配置\n- 从 817 个仓库中窃取凭证\n- 受影响的开发者超过 5,500 人\n## 如何保护自己 ​\n\n### 步骤一：验证包是否存在 ​\n\n安装任何 AI 推荐的包之前，先去官方网站确认：\n语言官方包仓库网址JavaScript/Node.jsnpmnpmjs.comPythonPyPIpypi.orgGoGo Packagespkg.go.devRustcrates.iocrates.io\n### 步骤二：检查包的可信度 ​\n\n在官方仓库中搜索到包后，检查：\n指标安全信号警惕信号下载量周下载量较高（数千以上）下载量很低（几十或更少）维护状态最近有更新超过 2 年没更新作者知名组织或有多个项目只有这一个包，无其他活动依赖者被其他流行项目使用没有其他项目依赖仓库有关联的 GitHub 仓库没有源码仓库\n### 步骤三：警惕\"新发现\"的包 ​\n\n如果 AI 推荐了一个你从未听过的包：\n\n`✅ 先在搜索引擎中搜索这个包名\n✅ 看看是否有人在技术论坛或博客中讨论过\n✅ 检查是否有官方文档\n✅ 如果找不到任何信息，很可能是幻觉`\n### 步骤四：仔细阅读 AI 的推荐 ​\n有时候 AI 会给出这样的建议：\njavascript\n`// AI 可能会说：\n// \"你可以使用 super-easy-auth 库来处理认证\"\nnpm install super-easy-auth`在执行安装命令之前，先问自己：\n\n- 这个库我听过吗？\n- 去 npmjs.com 搜索存在吗？\n- 下载量怎么样？\n## 开源模型 vs 商业模型 ​\n\n研究表明，不同模型的幻觉率差异很大：\n模型类型幻觉率说明开源模型（如 CodeLlama）~21.7%每 5 个推荐中可能有 1 个是假的GPT 系列~5.2%相对较低，但仍需警惕\n无论使用哪个模型，都应该验证。\n\n## 记住这个原则 ​\n\n核心原则\n\nAI 推荐的包 ≠ 存在的包 ≠ 安全的包\n\n在安装任何新依赖之前，花 30 秒去官方仓库验证，可以避免很多麻烦。\n\n→ 5.3.6 永远审查代码",
      "word_count": 1957,
      "estimated_time": 3
    },
    {
      "id": "lesson-155",
      "chapter_id": "chapter-05",
      "lesson_number": 22,
      "title": "5.3.6 永远审查代码",
      "content": "# 5.3.6 永远审查代码：最重要的安全习惯 ​\n\n经过本节学习，你将了解：\n\n- 为什么代码审查如此重要\n- 如何审查你不完全理解的代码\n- 关于\"自动批准模式\"的建议\n- 建立可持续的审查习惯\n## 令人担忧的数据 ​\n\n根据 2025 年的开发者调查：\n\n- 只有 67% 的开发者在部署前审查代码\n- 超过 40% 的初学者承认部署了不完全理解的 AI 生成代码\n- 33% 的开发者表示会直接复制粘贴 AI 生成的代码\n这意味着：很多人正在使用他们并不真正理解的代码。\n\n## 什么是\"真正的\"Vibe Coding？ ​\n\nSimon Willison（AI 领域知名专家、Django 核心贡献者）对此有一个有趣的观点：\n\n\"如果 AI 写了所有代码，但你审查、测试并理解了它，那不是 Vibe Coding——那是用 AI 当打字助手。\"\n\n换句话说：\n做法类型风险AI 生成 → 审查 → 测试 → 部署用 AI 辅助开发较低AI 生成 → 直接部署纯 Vibe Coding较高\n我们在本教程中倡导的是有意识的 AI 辅助开发：充分利用 AI 的能力，但保持人类的判断和审查。\n\n## 如何审查你不完全理解的代码 ​\n\n你可能会想：我是初学者，根本看不懂代码，怎么审查？\n\n好消息是：你不需要完全理解每一行代码，就可以进行有意义的审查。\n\n### 检查项一：敏感信息 ​\n\n即使不懂代码，你也能识别这些模式：\njavascript\n`// 问自己：这里有没有看起来像密钥的东西？\nconst key = \"sk-abc123...\"  // 这看起来像密钥\nconst key = process.env.KEY  // 这是正确的方式`\n### 检查项二：可疑的网络请求 ​\n留意代码是否在向你不认识的地址发送数据：\njavascript\n`// 问自己：这个网址是我知道的服务吗？\nfetch(\"https://api.openai.com/...\")  // 正常，OpenAI 官方\nfetch(\"https://random-site.xyz/steal-data\")  // 可疑`\n### 检查项三：文件操作 ​\n注意代码是否在读写文件，特别是敏感路径：\njavascript\n`// 问自己：为什么要读取这些文件？\nfs.readFile(\"~/.ssh/id_rsa\")  // 危险！在读取 SSH 私钥\nfs.readFile(\"./data.json\")    // 正常，读取项目内的数据`\n### 检查项四：让 AI 帮你审查 ​\n你可以让另一个 AI（或同一个 AI）来检查代码：\n\n`请审查以下代码，检查是否有：\n1. 硬编码的密钥或密码\n2. 可疑的网络请求\n3. 不安全的文件操作\n4. 其他安全隐患\n\n[粘贴代码]`技巧\n\n用一个 AI 来审查另一个 AI 的代码，可以发现一些明显的问题。但这不能替代你自己的判断。\n\n## 关闭自动批准模式 ​\n\n一些 AI IDE 提供了\"自动批准\"或\"Yolo 模式\"，允许 AI 不经你确认就执行命令或修改文件。\n\n初学者应该关闭此功能。\n\n原因：\n\n- 你需要看到 AI 在做什么，才能学习\n- AI 可能做出你不想要的更改\n- 如果出错，你无法及时阻止\n每个操作都手动确认，虽然慢一点，但更安全，也能帮助你理解发生了什么。\n\n## 建立可持续的审查习惯 ​\n\n代码审查不需要花很多时间。建立以下习惯：\n\n每次 AI 生成代码后：\n\n- [ ] 快速扫一眼，有没有看起来像密钥的字符串\n- [ ] 如果有网络请求，确认目标地址是你知道的\n- [ ] 如果看不懂某段代码在做什么，问 AI 解释\n每次准备提交/部署前：\n\n- [ ] 运行安全检查清单（5.3.4 节）\n- [ ] 确认 .env 文件没有被包含\n定期回顾：\n\n- [ ] 检查项目依赖是否需要更新\n- [ ] 确认没有新的安全警告\n## 记住这个原则 ​\n\n核心原则\n\nAI 生成的代码，最终责任在你。\n\n这不是为了吓你，而是提醒你：保持审查习惯，是保护自己的最好方式。\n\n→ 5.3.7 本节要点总结",
      "word_count": 1736,
      "estimated_time": 3
    },
    {
      "id": "lesson-156",
      "chapter_id": "chapter-05",
      "lesson_number": 23,
      "title": "5.3.7 本节要点总结",
      "content": "# 5.3.7 本节要点总结 ​\n\n恭喜你完成了安全章节的学习。现在你已经掌握了 AI 编程时代最重要的安全知识。\n\n## 三大禁令 ​\n\n记住这三条底线，可以避免 90% 的安全问题：\n禁令说明❌ 不告诉 AI 密码/密钥即使是\"帮我检查格式对不对\"也不行❌ 不把密钥写在代码里使用 .env 文件和环境变量❌ 不上传 .env 文件确保 .gitignore 配置正确\n## 两个好习惯 ​\n\n- 安装新库前先验证：去 npmjs.com 或 pypi.org 确认包存在且可信\n- 提交前快速检查：搜索 `password`、`secret`、`key` 等关键词\n## 一个核心原则 ​\n\n核心原则\n\nAI 生成的代码，最终责任在你。\n\n保持审查习惯，不盲目信任 AI 的输出。\n\n## 本节知识地图 ​\n\n`5.3 安全意识\n├── 5.3.0 触目惊心的数字（建立紧迫感）\n├── 5.3.1 为什么重要（真实案例）\n├── 5.3.2 绝对禁区（不要告诉 AI 的东西）\n├── 5.3.3 代码中的隐患（.env 和 .gitignore）\n├── 5.3.4 安全检查清单（可操作的检查项）\n├── 5.3.5 Slopsquatting（验证 AI 推荐的库）\n└── 5.3.6 永远审查代码（建立审查习惯）`\n## 进阶版预告 ​\n这一节只是安全入门。在进阶版中，你将学习更多高级安全知识：\n主题你将学到认证与授权JWT、OAuth 2.0、会话管理API 安全CORS、XSS、CSRF 防护数据安全加密传输、敏感数据处理安全审计日志记录、异常检测\n## 最后一句话 ​\n\n安全知识不是用来吓人的，而是用来保护你的。\n\n只要养成好习惯，你就能安心地使用 AI 编程创造价值。\n\n→ 5.4 再进化：项目的持续迭代与优化",
      "word_count": 772,
      "estimated_time": 3
    },
    {
      "id": "lesson-157",
      "chapter_id": "chapter-05",
      "lesson_number": 24,
      "title": "5.4.1 你的项目不是一次性的",
      "content": "# 5.4.1 你的项目不是一次性的 ​\n\n经过本节学习，你将理解：\n\n- 为什么\"完成\"只是开始\n- 真实产品是如何一步步进化的\n- 如何用迭代思维规划下一步\n## 你可能有的困惑 ​\n\n\"第四章做完的待办清单，已经能用了，还需要改吗？\"\n\n这个想法很正常。我们从小写作业，交了就完事了。但做工具不一样——好用的工具，都是用出来的，不是一次做出来的。\n\n## 看看那些你每天用的产品 ​\n\n微信刚上线时是什么样子？\n时间版本功能2011年1月1.0只能发消息、发图片2012年4月4.0加入朋友圈2013年8月5.0加入微信支付2017年1月小程序上线不用下载App就能用各种服务\n微信用了6年，从一个简单的聊天工具变成了一个超级平台。\n\n淘宝最早就是一个简陋的网页，连图片都模糊。你现在用的\"猜你喜欢\"、\"直播购物\"，都是后来一点点加上去的。\n\n没有哪个产品是一步到位的。 你的待办清单也不需要。\n\n## 一次性作业 vs 持续进化 ​\n一次性作业心态持续进化心态\"做完就不管了\"\"做完是起点\"\"要一次做到完美\"\"先能用，再好用\"\"功能越多越好\"\"解决一个问题再说下一个\"\"有bug说明我做错了\"\"有bug说明我发现了改进点\"\n第二种心态，是创造者的心态。\n\n## 迭代循环：做 → 用 → 改 → 做 ​\n\n`    ┌─────────────┐\n    │   做一版    │\n    └──────┬──────┘\n           │\n           ▼\n    ┌─────────────┐\n    │   用一用    │\n    └──────┬──────┘\n           │\n           ▼\n    ┌─────────────┐\n    │  发现问题   │\n    └──────┬──────┘\n           │\n           ▼\n    ┌─────────────┐\n    │   改进它    │\n    └──────┬──────┘\n           │\n           └──────────────┐\n                          │\n           ┌──────────────┘\n           │\n           ▼\n      (回到\"做一版\")`每转一圈，你的工具就好用一点。\n\n这不是因为你第一次做得不好，而是有些问题只有用了才会发现。\n\n## 回顾灵魂三问：你的改进方向 ​\n\n还记得第二章的\"灵魂三问\"吗？\n\n- 用户是谁？ → 谁在用你的待办清单？你自己？家人？室友？\n- 痛点在哪？ → 用了一段时间后，什么地方让你不爽？\n- 为什么选你？ → 和手机自带的备忘录比，你的有什么特别之处？\n这三个问题，在迭代阶段同样有用。\n\n当你不知道下一步该改什么时，问自己：\n\n- 我用的时候，哪一步最麻烦？\n- 我希望它能做什么，但目前做不到？\n这些答案，就是你的迭代方向。\n\n## 本节要点 ​\n\n- 完成第一版只是开始，不是终点\n- 好的工具都是在使用中慢慢进化出来的\n- 每次改进只需要解决一个问题\n- 第二章的灵魂三问，可以帮你找到改进方向\n一个好的心态\n\n不要想着\"一次做到完美\"。\n\n做出来 → 用起来 → 发现问题 → 改进它。\n\n这就是创造者的日常。\n\n→ 5.4.2 收集反馈：让使用者告诉你",
      "word_count": 1434,
      "estimated_time": 3
    },
    {
      "id": "lesson-158",
      "chapter_id": "chapter-05",
      "lesson_number": 25,
      "title": "5.4.2 收集反馈",
      "content": "# 5.4.2 收集反馈：让使用者告诉你 ​\n\n经过本节学习，你将掌握：\n\n- 为什么反馈比自己闷头想更有用\n- 三种零门槛的反馈收集方法\n- 一个简单的反馈记录模板\n- 如何让 AI 帮你分析反馈\n## 为什么需要别人的反馈 ​\n\n你做的工具，你自己觉得好用，不代表别人觉得好用。\n\n根据 ProdPad 2025 年的调研，91% 的用户认为产品创新应该来自客户的声音。换句话说，闭门造车做出来的东西，大概率不是用户真正想要的。\n\n你可能会想：\"我的待办清单就是给自己用的，不需要别人的意见吧？\"\n\n其实不然。就算是给自己用，让朋友试一下也能发现问题：\n\n- 你觉得\"显而易见\"的操作，别人可能根本不知道怎么用\n- 你习惯的界面布局，换个人可能觉得很别扭\n- 你从来不用的功能，别人可能每天都想用\n找几个人试用，是发现问题最快的方法。\n\n## 方法一：真人测试法 ​\n\n最简单的方法：把你的待办清单发给 3-5 个人试用。\n\n可以是：\n\n- 家人（特别是不太懂技术的）\n- 室友或同事\n- 朋友\n不需要多，3个人就够了。\n\n### 怎么发给他们 ​\n\n如果你已经完成了 5.2 节的部署，直接把网址发给他们就行：\n\n\"我做了一个待办清单工具，你能帮我试用一下吗？大概花2分钟。网址是 xxx.zeabur.app\"\n\n如果还没部署，可以让他们到你电脑前试用。\n\n## 方法二：观察法 ​\n\n观察他们怎么用，比直接问更有用。\n\n当别人在试用时，注意观察：\n观察点可能说明的问题停顿了很久，不知道点哪里界面不够直观问你\"这个按钮是干嘛的\"按钮文字不够清楚反复点同一个地方交互反馈不明显皱眉头、叹气某个操作让他们感到挫败\"哦，原来是这样\"操作逻辑不符合直觉\n不要在旁边指导。让他们自己摸索，你只是观察。这样才能看到真实的使用情况。\n\n## 方法三：直接问 ​\n\n观察完之后，可以问他们三个问题：\n\n`1. 第一次打开时，你知道该怎么用吗？\n2. 有什么地方让你感到困惑或不方便？\n3. 如果可以加一个功能，你希望是什么？`这三个问题覆盖了：\n\n- 易用性（能不能快速上手）\n- 痛点（哪里不好用）\n- 需求（希望有什么功能）\n## 记录反馈的模板 ​\n\n收集到的反馈，用一个简单的表格记录下来：\n反馈来源问题/建议优先级状态室友想要任务截止日期P1待开发妈妈按钮太小，不好点P0已修复自己想要分类标签P2计划中同事能不能有深色模式P2计划中\n### 优先级怎么定 ​\n优先级含义举例P0必须马上修功能坏了、按钮点不动、界面错乱P1尽快做影响日常使用的问题，多人反馈的需求P2有空再说锦上添花的功能，个别人的特殊需求\n一个简单的判断标准：\n\n- 影响所有人 → P0 或 P1\n- 只影响部分人 → P1 或 P2\n- 没人提但你自己想做 → 先放一放\n## 让 AI 帮你分析反馈 ​\n\n如果你收集了不少反馈，可以让 AI 帮你整理和分析。\n\n`我做了一个待办清单工具，收集到了一些用户反馈，请帮我分析：\n\n反馈列表：\n1. 室友说想要任务截止日期提醒\n2. 妈妈说按钮太小，在手机上不好点\n3. 同事说希望有深色模式\n4. 我自己觉得任务多了之后不好找，想要分类功能\n5. 室友还说任务完成后的动画挺好看的（正面反馈）\n\n请帮我：\n1. 按优先级排序这些反馈\n2. 分析哪些是共性问题，哪些是个人偏好\n3. 建议我先做哪个改进`AI 会帮你梳理出一个清晰的行动计划。\n\n## 常见误区 ​\n\n### 只听表扬，忽略批评 ​\n\n\"挺好的\"、\"还不错\"这种反馈虽然听着舒服，但对改进没有帮助。\n\n真正有价值的反馈往往是批评：\n\n- \"我不知道怎么删除任务\"\n- \"这个颜色看着有点刺眼\"\n- \"能不能加个搜索功能\"\n这些才是改进的方向。\n\n### 试图满足所有人 ​\n\n不同的人会提出不同甚至矛盾的需求。你不需要满足所有人。\n\n回到第二章的灵魂三问：你的工具到底是给谁用的？ 优先满足核心用户的需求。\n\n## 本节检查清单 ​\n\n- [ ] 找到了 3-5 个人试用你的待办清单\n- [ ] 观察了他们的使用过程\n- [ ] 问了三个关键问题\n- [ ] 用表格记录了收集到的反馈\n- [ ] 给反馈标注了优先级\n反馈是礼物\n\n每一条反馈，不管是批评还是建议，都是帮你改进的线索。\n\n别人愿意花时间告诉你问题，说明他们在乎你的作品。\n\n→ 5.4.3 功能扩展：让 AI 帮你添加新功能",
      "word_count": 1841,
      "estimated_time": 3
    },
    {
      "id": "lesson-159",
      "chapter_id": "chapter-05",
      "lesson_number": 26,
      "title": "5.4.3 功能扩展",
      "content": "# 5.4.3 功能扩展：让 AI 帮你添加新功能 ​\n\n经过本节学习，你将掌握：\n\n- 常见的功能扩展方向和难度评估\n- 用第三章学到的框架写功能扩展 Prompt\n- 添加新功能的安全流程\n- 一个完整的功能添加实战案例\n## 功能扩展方向参考 ​\n\n收集完反馈后，你可能想给待办清单加一些新功能。\n\n下面是一些常见的扩展方向，按难度分类：\n\n### 基础级功能（推荐先尝试） ​\n功能难度说明任务分类标签⭐⭐给任务打上\"工作\"、\"生活\"、\"学习\"等标签，可以按标签筛选优先级标记⭐⭐高/中/低优先级，用不同颜色区分搜索功能⭐⭐任务多了之后能快速找到深色模式⭐⭐晚上看着不刺眼\n### 进阶级功能（有一定挑战） ​\n功能难度说明截止日期提醒⭐⭐⭐设置截止时间，过期任务标红任务排序⭐⭐⭐可以拖拽调整任务顺序数据导出⭐⭐⭐把任务列表导出成文件简单统计⭐⭐⭐显示\"本周完成了多少任务\"\n建议从基础级功能开始。成功添加一两个之后，再挑战进阶级。\n\n## 添加新功能的安全流程 ​\n\n在动手之前，有一个重要原则：\n\n黄金法则\n\n每次添加新功能前，先保存当前版本。\n\n按照这个流程操作：\n\n`1. 确认当前版本能正常运行\n       ↓\n2. 用 GitHub Desktop 提交一次（Commit）\n       ↓\n3. 写 Prompt 让 AI 添加新功能\n       ↓\n4. 测试新功能\n       ↓\n5. 如果成功 → 再 Commit 一次\n   如果失败 → 回滚到上一版`这样，即使新功能改崩了，你也能随时恢复。（这就是 5.1 节学的版本管理的用处）\n\n## 用 S.C.A.F.F. 框架写功能扩展 Prompt ​\n\n还记得第三章的 S.C.A.F.F. 框架吗？添加新功能时同样适用。\n\n### 框架回顾 ​\n字母含义说明SSituation（情境）当前项目是什么样的CChallenge（挑战）我想添加什么功能AAsk（请求）具体需要 AI 做什么FFormat（格式）希望得到什么样的输出FFilter（过滤）有什么限制条件\n### 示例：添加分类标签功能 ​\n\n`【情境】\n我有一个待办清单项目，目前实现了：\n- 添加任务\n- 删除任务\n- 标记任务完成\n- 使用 localStorage 保存数据\n\n技术栈：HTML + CSS + JavaScript（纯前端，没有后端）\n\n【挑战】\n我想给任务添加\"分类标签\"功能。用户可以：\n1. 创建任务时选择一个分类（工作/生活/学习）\n2. 按分类筛选任务\n3. 每个分类用不同的颜色显示\n\n【请求】\n请帮我修改代码实现这个功能。\n\n【格式】\n1. 先说明需要修改哪些部分\n2. 给出修改后的完整代码\n3. 说明如何测试这个功能\n\n【限制】\n- 保持现有功能不变\n- 使用现有的代码风格\n- 分类数据也要保存到 localStorage`\n## 各功能的 Prompt 模板 ​\n这里提供几个常用功能的 Prompt 模板，你可以直接复制使用，只需要把 `[方括号里的内容]` 替换成你的实际情况。\n\n### 优先级标记 ​\n\n`我的待办清单项目需要添加\"优先级\"功能：\n- 每个任务可以设置优先级：高/中/低\n- 高优先级用红色标记，中优先级用黄色，低优先级用灰色\n- 默认优先级是\"中\"\n- 可以按优先级排序显示（高的在上面）\n\n当前项目技术栈：[HTML + CSS + JavaScript / 其他]\n数据存储方式：[localStorage / 其他]\n\n请修改代码实现这个功能，保持现有功能正常。`\n### 搜索功能 ​\n\n```\n我的待办清单需要添加搜索功能：\n- 在任务列表上方添加一个搜索框\n- 输入关键词时，实时筛选包含该关键词的任务\n- 搜索框为空时显示所有任务\n- 搜索不区分大小写\n\n当前项目技术栈：[你的技术栈]\n\n请给出实现代码。\n```\n\n### 深色模式 ​\n\n```\n我的待办清单需要添加深色模式切换功能：\n- 在页面右上角添加一个切换按钮（太阳/月亮图标）\n- 点击可以在浅色/深色模式之间切换\n- 记住用户的选择（下次打开还是同样的模式）\n\n当前的颜色方案：\n- 背景色：[白色]\n- 文字颜色：[黑色]\n- 主题色：[蓝色]\n\n请给出实现代码，包括深色模式的配色建议。\n```\n\n### 截止日期 ​\n\n```\n我的待办清单需要添加截止日期功能：\n- 创建任务时可以选择截止日期（可选，不是必填）\n- 任务卡片上显示截止日期\n- 已过期的任务用红色高亮显示\n- 今天到期的任务用黄色高亮显示\n\n当前项目技术栈：[你的技术栈]\n数据存储方式：[localStorage / 其他]\n\n请给出实现代码。\n```\n\n## 实战案例：添加分类标签 ​\n下面是一个完整的对话记录，展示如何给待办清单添加分类标签功能。\n\n### 第一轮：说明需求 ​\n\n你发送的 Prompt（使用上面的 S.C.A.F.F. 模板）后，AI 会返回修改方案和代码。\n\n### 第二轮：测试发现问题 ​\n\n测试后，你可能发现问题：\n\n`分类功能基本可以用了，但有个问题：\n切换分类筛选时，如果当前分类下没有任务，页面是空白的，用户会困惑。\n\n请添加一个提示，当筛选结果为空时显示\"暂无任务\"。`\n### 第三轮：微调细节 ​\n\n```\n现在\"暂无任务\"的提示可以显示了，但文字颜色太浅，不太明显。\n请把提示文字改成灰色，并加粗显示。\n```\n这就是迭代的过程：做一版 → 发现问题 → 再改进。\n\n## 测试新功能的检查清单 ​\n\n每次添加新功能后，用这个清单验证：\n\n- [ ] 新功能按预期工作\n- [ ] 原有功能（添加、删除、完成任务）仍然正常\n- [ ] 刷新页面后数据没有丢失\n- [ ] 在手机浏览器上也能正常显示\n- [ ] 没有明显的报错（打开浏览器控制台检查）\n全部通过后，记得用 GitHub Desktop 提交一次，记录这个里程碑。\n\n## 遇到问题时 ​\n\n如果 AI 给的代码不能正常工作，可以这样反馈：\n\n`你给的代码运行后出现了问题：\n\n【问题描述】\n点击分类筛选按钮后，页面变成空白，所有任务都不显示了。\n\n【错误信息】\n打开浏览器控制台，看到这个报错：\nUncaught TypeError: Cannot read property 'filter' of undefined\n\n【期望行为】\n点击\"工作\"分类，应该只显示标记为\"工作\"的任务。\n\n请帮我找出问题并修复。`提供具体的问题描述和错误信息，AI 更容易帮你解决。\n\n## 本节要点 ​\n\n- 从基础级功能开始，成功后再挑战进阶级\n- 每次改代码前先 Commit，改崩了能恢复\n- 用 S.C.A.F.F. 框架写功能扩展 Prompt\n- 添加功能是一个迭代过程，一轮不行就多轮\n- 测试通过后记得再 Commit 一次\n小步前进\n\n不要一次性加太多功能。\n\n每次只加一个，测试通过后再加下一个。\n\n这样出问题时，你能很快定位是哪个改动导致的。\n\n→ 5.4.4 代码优化：让 AI 帮你改进代码质量",
      "word_count": 2954,
      "estimated_time": 5
    },
    {
      "id": "lesson-160",
      "chapter_id": "chapter-05",
      "lesson_number": 27,
      "title": "5.4.4 代码优化",
      "content": "# 5.4.4 代码优化：让 AI 帮你改进代码质量 ​\n\n经过本节学习，你将掌握：\n\n- 什么时候该优化代码\n- 让 AI 帮你做的 5 类优化\n- 代码审查的基本意识\n## 什么时候该优化 ​\n\n先说一个重要原则：\n\n功能稳定之后再优化，不要边写功能边优化。\n\n为什么？\n\n因为你还在加功能的时候，代码会频繁变动。这时候花时间整理代码，可能下一个功能又要重新改。\n\n等待办清单的核心功能都做完、测试通过了，再考虑优化。\n\n优化的目的是：\n\n- 让代码更容易读懂（以后你自己回来看也能看懂）\n- 减少潜在的问题\n- 让代码运行得更快（对于小项目，这通常不是重点）\n## 让 AI 帮你做的 5 类优化 ​\n\n你不需要自己会写更好的代码，可以让 AI 帮你检查和改进。\n\n### 1. 检查代码重复 ​\n\n`请检查我的代码，有没有重复的逻辑？\n如果有，请帮我提取成一个可复用的函数。\n\n[粘贴你的代码]`为什么重要：重复的代码意味着，如果要改某个逻辑，你需要改多处。容易漏改，产生 bug。\n\n### 2. 改进变量命名 ​\n\n`请检查我的代码中的变量和函数命名，有没有不够清晰的？\n请给出改进建议，让代码更容易读懂。\n\n[粘贴你的代码]`例子：\n改进前改进后原因`a`, `b`, `x``taskName`, `dueDate`有意义的名字，一看就知道是什么`data``todoList`更具体`fn1``addNewTask`描述了函数的功能\n### 3. 添加中文注释 ​\n\n`请给这段代码添加中文注释，解释：\n1. 每个函数是做什么的\n2. 关键的代码块在处理什么逻辑\n3. 不容易理解的地方\n\n[粘贴你的代码]`为什么重要：一个月后你再看自己的代码，没有注释的话可能完全看不懂。注释是写给未来的自己的。\n\n### 4. 检查潜在 bug ​\n\n`请检查我的代码，有没有潜在的问题或 bug？\n特别关注：\n1. 可能导致报错的边界情况\n2. 数据为空时的处理\n3. 用户输入的验证\n\n[粘贴你的代码]`常见问题举例：\n\n- 用户没输入就点了添加按钮\n- 任务列表为空时的显示\n- 数据格式不对时的处理\n### 5. 性能优化建议 ​\n\n`请检查我的代码，有没有可以优化性能的地方？\n我的项目是一个待办清单，数据量不大（最多几十条任务）。\n请只给出对我这个规模有意义的优化建议。\n\n[粘贴你的代码]`对于小项目的说明：对于待办清单这样的小项目，性能通常不是问题。不要过度优化。如果 AI 给了很复杂的优化建议，可以先不做。\n\n## 一个完整的代码审查 Prompt ​\n\n如果你想让 AI 做一次全面的代码审查，可以用这个模板：\n\n`请帮我审查这段代码，从以下几个角度给出改进建议：\n\n1. 代码结构：有没有重复的逻辑？可以怎么简化？\n2. 可读性：变量命名是否清晰？需要添加注释吗？\n3. 健壮性：有没有可能报错的边界情况？\n4. 安全性：有没有明显的安全问题？\n\n请按优先级排序你的建议（先说最重要的），并给出具体的修改方案。\n\n代码如下：\n[粘贴你的代码]`\n## 代码审查的基本意识 ​\n在 5.3 节我们提到过，AI 生成的代码并不总是安全的。\n\n根据 Veracode 2025 年的报告，45% 的 AI 生成代码未通过安全测试。\n\n这不是说 AI 不好用，而是说：你需要对 AI 给的代码有基本的审查意识。\n\n### 审查时关注这几点 ​\n关注点检查内容数据安全代码里有没有暴露敏感信息（密码、API密钥）输入验证用户输入的数据有没有做检查错误处理出错时会不会崩溃，有没有给用户提示功能正确AI 实现的逻辑和你的预期是否一致\n如果看不太懂代码也没关系。至少做到：\n\n- 运行测试一下，看功能是否正常\n- 看看关键部分，比如处理用户输入的地方\n- 有疑问就问 AI：\"这段代码是在做什么？有没有问题？\"\n## 优化不等于重写 ​\n\n最后一个重要提醒：\n\n优化是在现有代码基础上小步改进，不是推翻重来。\n\n如果 AI 建议你\"用某某框架重写整个项目\"，这通常不是你现在需要做的。\n\n对于学习阶段的项目，保持现有的代码能工作就好。等你做更多项目、积累更多经验后，自然会知道什么时候该用更好的方案。\n\n## 本节检查清单 ​\n\n- [ ] 核心功能稳定后再考虑优化\n- [ ] 让 AI 检查了代码重复问题\n- [ ] 让 AI 改进了变量命名\n- [ ] 给关键代码添加了中文注释\n- [ ] 对 AI 生成的代码有了基本的审查意识\n代码是给人读的\n\n写代码不只是让程序能运行。\n\n好的代码，别人（包括未来的你）能快速读懂。\n\n注释和清晰的命名，是对未来自己的善意。\n\n→ 5.4.5 从项目到作品集",
      "word_count": 1960,
      "estimated_time": 3
    },
    {
      "id": "lesson-161",
      "chapter_id": "chapter-05",
      "lesson_number": 28,
      "title": "5.4.5 从项目到作品集",
      "content": "# 5.4.5 从项目到作品集 ​\n\n经过本节学习，你将掌握：\n\n- 为什么要把项目整理成作品集\n- 如何写一个清晰的项目说明（README）\n- 记录学习心得的模板\n- 下一步可以尝试什么项目\n## 你的待办清单可以成为什么 ​\n\n完成第四章和第五章后，你手上有的不只是\"一个练习\"，而是：\n它可以是怎么用学习成果的证明告诉别人你做了什么、学会了什么求职/升学的作品面试时展示你的动手能力继续学习的基础在这个项目上尝试新技术帮助他人的工具分享给有类似需求的人\n但前提是——你需要把它整理出来，让别人能看懂。\n\n## 写一个项目说明（README） ​\n\nREADME 是放在项目根目录的一个文件，用来介绍这个项目是什么、怎么用。\n\n当别人打开你的 GitHub 仓库时，第一眼看到的就是 README。\n\n### 简单的 README 模板 ​\n\n在你的项目根目录创建一个 `README.md` 文件，内容可以这样写：\nmarkdown\n`# 我的待办清单\n\n一个简洁的任务管理工具，帮你记录和追踪日常待办事项。\n\n## 功能\n\n- 添加新任务\n- 标记任务完成\n- 删除任务\n- 任务数据自动保存（刷新不丢失）\n\n## 在线体验\n\n访问：[你的网址.zeabur.app](https://你的网址.zeabur.app)\n\n## 技术栈\n\n- HTML\n- CSS\n- JavaScript\n- localStorage（本地存储）\n\n## 我学到了什么\n\n这是我用 AI 辅助编程完成的第一个项目。在这个过程中，我学会了：\n\n1. 用自然语言和 AI 沟通需求\n2. 把想法分解成具体的功能点\n3. 测试和调试代码\n4. 使用 GitHub 管理代码版本\n5. 将网页部署到互联网\n\n## 关于作者\n\n[你的名字]，一个正在学习 Vibe Coding 的普通人。`\n### 让 AI 帮你写 README ​\n如果不知道怎么写，可以让 AI 帮忙：\n\n`我做了一个待办清单项目，请帮我写一个 README 文件。\n\n项目功能：\n- 添加任务\n- 删除任务\n- 标记完成\n- 本地存储\n\n技术栈：HTML + CSS + JavaScript\n\n访问地址：[你的网址]\n\n请用简洁的中文，包含项目介绍、功能列表、在线体验链接、技术栈说明。`\n## 截图展示 ​\n一张好的截图胜过千言万语。\n\n建议准备：\n截图类型展示内容主界面整体页面效果功能演示添加任务、完成任务等操作移动端适配手机上的显示效果（如果做了响应式）\n### 如何截图 ​\n\n- 网页截图：使用浏览器自带的截图功能，或者按 `F12` 打开开发者工具，选择\"设备模式\"可以模拟手机界面\n- 录屏：可以录一个 10-20 秒的操作演示，上传到 GitHub 或转成 GIF\n## 记录学习心得 ​\n\n除了项目本身，你的学习过程也很有价值。\n\n### 学习心得模板 ​\nmarkdown\n`## 我的学习心得\n\n### 最大的收获\n这个项目让我意识到，编程不是\"会写代码\"，而是\"会清晰地表达需求\"。\n当我把想法说清楚了，AI 就能帮我实现。\n\n### 遇到的挑战\n1. 一开始不知道怎么描述需求，总是说得很模糊\n2. AI 给的代码有时候不能直接用，需要调试\n3. 第一次用 GitHub 有点懵，但习惯了就好\n\n### 怎么解决的\n1. 用 S.C.A.F.F. 框架组织我的 Prompt，说清楚情境和目标\n2. 把错误信息发给 AI，让它帮我修复\n3. 按照教程一步步操作，不懂的地方多试几次\n\n### 下一步计划\n- 给待办清单添加分类标签功能\n- 尝试做一个记账小工具\n- 继续学习进阶版教程`这些心得不仅能帮你复盘，也能帮助和你一样的学习者。\n\n## 下一步可以尝试的项目 ​\n\n完成待办清单后，你可以挑战这些项目：\n项目难度为什么适合习惯打卡器⭐⭐和待办清单类似，但增加了日期维度记账小工具⭐⭐学习处理数字和简单统计个人书签管理⭐⭐学习处理链接和分类读书笔记⭐⭐⭐学习处理更多文本内容给家人做的工具⭐⭐真实用户，真实反馈\n挑一个你感兴趣的，用同样的方法再做一遍。每做一个项目，你就更熟练一点。\n\n## 进阶版预告 ​\n\n如果你想做更复杂的项目，比如：\n\n- 需要用户登录\n- 需要多人协作\n- 需要后端数据库\n- 需要更专业的界面\n这些内容会在**进阶版《Vibe Coding 全栈实战教程》**中详细讲解。\n\n基础版让你入门，进阶版让你更强。\n\n## 本节检查清单 ​\n\n- [ ] 为项目写了 README 文件\n- [ ] 准备了项目截图\n- [ ] 记录了学习心得\n- [ ] 想好了下一个要做的项目\n## 本章总结 ​\n\n恭喜你完成了 5.4 节的全部内容。\n\n回顾一下你在这一节学到的：\n主题你掌握了迭代思维完成只是开始，持续改进才是关键收集反馈让真实用户帮你发现问题功能扩展用 S.C.A.F.F. 框架让 AI 帮你加功能代码优化让 AI 帮你改进代码质量作品展示把项目整理成可分享的作品\n你的待办清单，从第四章的\"能用\"，变成了现在的\"好用\"、\"可展示\"。\n\n这是一个了不起的进步。\n\n创造者的身份\n\n从现在起，你不再只是一个\"用户\"。\n\n你是一个能把想法变成现实的创造者。\n\n继续做下去，你会越来越强。\n\n→ 5.5 知边界：Vibe Coding 的能与不能",
      "word_count": 2234,
      "estimated_time": 4
    },
    {
      "id": "lesson-162",
      "chapter_id": "chapter-05",
      "lesson_number": 29,
      "title": "5.5.1 Vibe Coding 能做什么",
      "content": "# 5.5.1 Vibe Coding 能做什么 ​\n\n经过本节学习，你将了解：\n\n- Vibe Coding 真正擅长的六大场景\n- 2025 年 AI 编程的真实数据\n- 为什么你走在正确的路上\n## 先看数据：AI 编程已是主流 ​\n\n在讨论 Vibe Coding 能做什么之前，先看一组 2025 年的真实数据：\n数据来源41% 的代码现在由 AI 生成或辅助Stack Overflow 2025 开发者调查84% 的开发者正在使用或计划使用 AI 编程工具Index.dev 2025 报告82% 的开发者每周使用 AI 编程工具Second Talent 2025 统计25% 的新代码由 AI 辅助完成Google 2025 官方数据\n这些数字说明：你学习 Vibe Coding，不是在追赶潮流，而是在拥抱已经到来的现实。\n\n## Vibe Coding 擅长的六大场景 ​\n\n### 场景一：个人工具 ​\n\n为什么擅长：需求由你自己定义，不需要考虑复杂的用户权限、多人协作、海量数据。AI 能完整理解你的意图。\n项目类型复杂度成功率待办清单低很高习惯打卡器低很高个人记账本中高读书笔记管理中高个人密码管理（本地版）中高\n真实案例：你在第四章做的待办清单，就是典型的个人工具。从零到能用，可能只花了一两个小时。\n\n### 场景二：原型验证 ​\n\n为什么擅长：原型的目标是\"快速验证想法是否可行\"，不需要完美，不需要能承载百万用户。Vibe Coding 的速度优势在这里发挥得淋漓尽致。\n\n根据 Index.dev 2025 的报告，使用 AI 编程工具的开发者：\n\n- 完成原型的速度提升 30%-75%\n- GitHub Copilot 用户每周完成的项目数量增加 126%\n典型场景：\n\n- 创业者验证一个产品想法\n- 学生为课程项目做 Demo\n- 向老板或客户演示一个概念\n### 场景三：效率脚本 ​\n\n为什么擅长：脚本通常是\"输入 → 处理 → 输出\"的线性流程，逻辑清晰，没有复杂的状态管理。这正是 AI 最擅长的模式。\n脚本类型示例文件批处理批量重命名、批量压缩图片、整理下载文件夹数据转换Excel 转 JSON、CSV 合并、格式标准化自动化任务定时备份、自动发邮件提醒、爬取公开数据\n一个真实场景：假设你每周要把 10 个 Excel 表格合并成一个汇总表。手动做需要 30 分钟，用 Vibe Coding 写个脚本可能只需要 10 分钟，而且以后每周只需要运行一下，几秒钟搞定。\n\n### 场景四：数据分析与可视化 ​\n\n为什么擅长：数据分析有明确的输入（数据）和输出（图表/结论），中间的处理步骤可以清晰描述。AI 能很好地理解\"我想看 XX 数据的 YY 趋势\"这类需求。\n分析类型适合程度销售数据趋势分析很适合问卷调查结果可视化很适合个人消费分析很适合简单的统计报告很适合\n### 场景五：静态网站 ​\n\n为什么擅长：静态网站没有复杂的后端逻辑，主要是\"展示内容\"。HTML + CSS + 少量 JavaScript，是 AI 最熟练的领域之一。\n网站类型复杂度成功率个人简历页面低很高作品集展示低很高活动宣传页低很高个人博客（静态）中高小型企业官网中高\n### 场景六：学习编程概念 ​\n\n为什么擅长：AI 可以用你能理解的语言解释代码，帮你建立直觉。你不需要先学会语法才能开始做东西，而是在做的过程中逐渐理解。\n\n这正是 Vibe Coding 的核心价值：降低入门门槛，让\"做中学\"成为可能。\n\n## 一个共同特征：问题边界清晰 ​\n\n如果你仔细看上面六个场景，会发现它们有一个共同特征：\n\n问题的边界是清晰的。\n\n- 个人工具：你自己用，需求你说了算\n- 原型验证：只需要\"能演示\"，不需要\"能上线\"\n- 效率脚本：输入输出明确\n- 数据分析：数据是固定的，分析目标是明确的\n- 静态网站：内容是确定的，交互很简单\n- 学习概念：目标是\"理解\"，不是\"生产\"\n当问题边界清晰时，AI 能很好地理解你的意图，生成的代码大概率能直接用。\n\n## 本节要点 ​\n\n- 2025 年，41% 的代码由 AI 生成或辅助，AI 编程已是主流\n- Vibe Coding 擅长六大场景：个人工具、原型验证、效率脚本、数据分析、静态网站、学习概念\n- 这些场景的共同特征是\"问题边界清晰\"\n- 在这些领域，大胆尝试，快速出成果\n你已经具备的能力\n\n完成第四章后，你已经能独立完成\"个人工具\"和\"静态网站\"类型的项目了。这不是终点，但已经是一个很好的起点。\n\n→ 5.5.2 Vibe Coding 的局限性",
      "word_count": 1928,
      "estimated_time": 3
    },
    {
      "id": "lesson-163",
      "chapter_id": "chapter-05",
      "lesson_number": 30,
      "title": "5.5.2 Vibe Coding 的局限性",
      "content": "# 5.5.2 Vibe Coding 的局限性 ​\n\n经过本节学习，你将了解：\n\n- Vibe Coding 不擅长的五大场景\n- \"70% 问题\"和\"80% 墙\"是什么\n- 为什么知道局限性反而让你更有信心\n## 先看数据：AI 生成的代码并不完美 ​\n\n这些是 2025 年的真实数据，不是为了吓你，而是帮你建立正确预期：\n数据来源含义45% 的 AI 生成代码未通过安全测试Veracode 2025将近一半的代码有安全隐患46% 的开发者不完全信任 AI 生成的代码Index.dev 2025专业开发者也保持谨慎过度依赖 AI 导致 bug 增加 41%Index.dev 2025不检查就用会出问题使用 AI 工具的开发者实际完成任务慢了 19%METR 2025 研究但他们感觉快了 20%\n最后一条数据特别有意思：开发者觉得自己变快了，但实际上变慢了。这说明 AI 带来的\"流畅感\"可能是一种错觉。\n\n这不是说 AI 没用，而是说：AI 是工具，不是魔法。需要你来把关。\n\n## \"70% 问题\"：AI 能做 70%，剩下 30% 要你来 ​\n\nGoogle 工程师 Addy Osmani 在 2025 年提出了一个观察：\n\nAI 可以轻松完成一个项目的 70%——生成样板代码、实现标准功能、处理常规逻辑。但剩下的 30% 才是真正的挑战：复杂的业务逻辑、边界情况处理、系统架构决策、性能优化。\nAI 擅长的 70%需要人类的 30%生成样板代码设计系统架构实现标准功能处理复杂业务逻辑写基础的增删改查优化性能瓶颈套用常见模式处理边界情况快速出原型确保代码安全\n对于基础版学习者来说，好消息是：你做的项目大部分在\"70%\"的范围内。待办清单、个人工具、简单网站——这些正是 AI 最擅长的。\n\n## \"80% 墙\"：项目做到 80% 后，每一步都变难 ​\n\n另一个常见现象是\"80% 墙\"：\n\n用 AI 快速做出一个项目的初版很容易，但当你想添加更多功能时，会发现每增加一个功能都比上一个更难。到了大约 80% 的时候，项目会撞上一堵\"墙\"。\n\n为什么会这样？\n阶段AI 的表现原因0-50%很顺利需求简单，代码量少，AI 能完整理解50-80%开始吃力代码变复杂，AI 开始\"忘记\"之前的上下文80%+非常困难新功能会影响旧功能，AI 难以把握全局\n这不是你的问题。这是 AI 工具本身的限制——它的\"记忆\"是有限的，无法像人类一样理解整个项目的来龙去脉。\n\n## Vibe Coding 不擅长的五大场景 ​\n\n### 场景一：复杂业务逻辑 ​\n\n为什么困难：AI 不理解你的业务背景。它能写出\"看起来正确\"的代码，但逻辑可能是错的。\n\n真实例子：\n\n- 你让 AI 写一个\"会员积分系统\"\n- AI 生成了代码，看起来能运行\n- 但它不知道你们公司的积分规则有特殊情况：满 100 积分送 10 积分、生日当天双倍积分、积分有效期 1 年...\n- 结果：代码能跑，但业务逻辑全错\n### 场景二：大型项目 ​\n\n为什么困难：AI 的\"上下文窗口\"是有限的。当项目有几十个文件、几千行代码时，AI 无法同时\"看到\"所有内容。\n项目规模文件数AI 的表现小型（待办清单）1-3 个很好中型（个人博客）5-10 个还行大型（电商网站）50+ 个力不从心\n会发生什么：\n\n- 代码重复（AI 忘记你已经写过类似功能）\n- 命名不一致（同一个概念用不同的名字）\n- 结构混乱（没有统一的组织方式）\n### 场景三：安全关键功能 ​\n\n为什么困难：安全漏洞往往藏在细节里，AI 倾向于生成\"能用\"的代码，而不是\"安全\"的代码。\n\n根据 Veracode 2025 报告：\n\n- 86% 的 AI 生成代码未能防御跨站脚本攻击\n- 88% 的 AI 生成代码未能防御日志注入攻击\n典型问题：\n\n- 没有验证用户输入\n- 没有正确处理敏感数据\n- 使用了有已知漏洞的库\n这就是为什么 5.3 节专门讲安全——AI 在这方面需要你来把关。\n\n### 场景四：性能优化 ​\n\n为什么困难：AI 倾向于选择\"最简单\"的实现方式，而不是\"最高效\"的。\n\n真实例子：\n\n- 你让 AI 写一个\"搜索功能\"\n- AI 用最简单的方式实现：遍历所有数据，逐个比较\n- 数据少的时候没问题\n- 数据多了（比如 10 万条）就会变得很慢\n会发生什么：\n\n- 小数据量测试时一切正常\n- 上线后用户变多，系统变慢\n- 你不知道慢在哪里，因为代码\"看起来没问题\"\n### 场景五：调试复杂 bug ​\n\n为什么困难：AI 只能看到你给它的信息，无法像人类一样\"追根溯源\"。\n简单 bugAI 能帮忙语法错误能明显的逻辑错误能报错信息清晰的问题能复杂 bugAI 很难帮间歇性出现的问题难涉及多个文件的问题难需要理解业务上下文的问题难\"修了这里，坏了那里\"的问题难\n## 一个形象的比喻 ​\n\nVibe Coding 就像有了翻译软件去国外旅游：\n场景翻译软件表现Vibe Coding 对应点餐、问路完全够用做个人工具、简单网站日常聊天基本够用实现标准功能深入讨论专业话题力不从心处理复杂业务逻辑谈判、演讲几乎不行大型项目、高安全要求\n翻译软件能让你的旅行更轻松，但如果你想在那个国家长期生活、工作，还是需要学习语言本身。\n\nVibe Coding 也是如此：它能让你快速做出东西，但如果你想做更复杂的项目，可能需要学习更多编程知识。\n\n## 本节要点 ​\n\n- AI 生成的代码并不完美：45% 有安全隐患，46% 的专业开发者不完全信任\n- \"70% 问题\"：AI 能完成 70%，剩下 30% 需要人类智慧\n- \"80% 墙\"：项目做到 80% 后，每增加一个功能都变难\n- 五大不擅长场景：复杂业务逻辑、大型项目、安全关键功能、性能优化、复杂 bug 调试\n- 知道局限性不是坏事——它帮你建立正确预期，在遇到困难时不自我怀疑\n好消息\n\n基础版教程涵盖的内容，大部分在 Vibe Coding 的\"舒适区\"内。你做的待办清单、个人工具、简单网站，正是 AI 最擅长的领域。\n\n遇到局限性时，不是你不行，是工具有边界。这时候，要么简化需求，要么准备学习更多。\n\n→ 5.5.3 什么信号告诉你需要学习更多",
      "word_count": 2601,
      "estimated_time": 5
    },
    {
      "id": "lesson-164",
      "chapter_id": "chapter-05",
      "lesson_number": 31,
      "title": "5.5.3 什么信号告诉你需要学更多",
      "content": "# 5.5.3 什么信号告诉你需要学习更多 ​\n\n经过本节学习，你将了解：\n\n- 六个\"升级信号\"的具体表现\n- 如何判断是工具问题还是知识问题\n- 一份自测清单帮你评估当前状态\n## 六个\"升级信号\" ​\n\n当你在 Vibe Coding 过程中遇到以下情况，可能是时候考虑学习更多了。\n\n### 信号一：同一个 bug 反复出现 ​\n\n表现：\n\n- 你让 AI 修了一个 bug，过几天又出现了\n- AI 每次给的修复方案都不一样，但问题还是会复发\n- \"修了这里，坏了那里\"的情况频繁发生\n背后原因：AI 只能看到表面症状，不理解问题的根本原因。它给的是\"止痛药\"，不是\"根治方案\"。\n\n需要学习的方向：调试基础、程序运行原理\n\n### 信号二：项目越改越乱 ​\n\n表现：\n\n- 代码文件越来越多，你不知道每个文件是干什么的\n- 同样的功能在好几个地方都有，不知道改哪个\n- 每次添加新功能都提心吊胆，怕影响已有功能\n背后原因：缺乏代码组织的知识。AI 生成的代码是\"能用\"，但不一定\"好维护\"。\n\n需要学习的方向：代码结构、模块化、设计模式基础\n\n### 信号三：撞上\"80% 墙\" ​\n\n表现：\n\n- 项目初期进展很快，现在每加一个功能都要花很长时间\n- AI 的回答开始变得不靠谱，经常\"忘记\"之前的约定\n- 你开始怀疑是不是要推翻重来\n背后原因：项目复杂度超出了 AI 的\"上下文窗口\"能力。\n\n需要学习的方向：项目规划、架构设计、或者学会拆分项目\n\n### 信号四：想要用户登录功能 ​\n\n表现：\n\n- 你想让用户注册账号、登录\n- 你想让用户的数据保存在云端，换设备也能用\n- 你想区分不同用户，让他们只能看到自己的数据\n背后原因：这需要\"后端\"和\"数据库\"——基础版没有涵盖的内容。\n\n需要学习的方向：后端开发、数据库、用户认证（进阶版内容）\n\n### 信号五：想做手机 App ​\n\n表现：\n\n- 你想让作品在手机上像\"真正的 App\"一样运行\n- 你想发布到应用商店\n- 你想使用手机特有的功能（摄像头、推送通知等）\n背后原因：网页和 App 是不同的技术栈，需要额外的知识。\n\n需要学习的方向：移动开发基础、或者 PWA（渐进式网页应用）\n\n### 信号六：AI 的回答越来越离谱 ​\n\n表现：\n\n- AI 给的代码完全跑不起来\n- AI 开始\"胡说八道\"，给出不存在的函数或库\n- 你问同一个问题，每次得到完全不同的答案\n背后原因：你的需求已经超出了 AI 的能力边界，或者你的问题描述让 AI 无法理解。\n\n需要学习的方向：\n\n- 如果是简单问题：提高提示词质量（回顾第三章）\n- 如果是复杂问题：学习更多编程知识，减少对 AI 的依赖\n## 升级信号速查表 ​\n信号表现可能的原因建议方向同一 bug 反复出现修了又出现AI 治标不治本学习调试基础项目越改越乱不知道代码在哪缺乏代码组织知识学习代码结构撞上 80% 墙每步都很难复杂度超出 AI 能力学习架构/拆分项目想要用户登录需要账号系统需要后端知识进入进阶版想做手机 App发布到应用商店不同技术栈学习移动开发AI 回答离谱代码跑不起来超出 AI 能力边界学习更多编程知识\n## 自测清单：你现在在哪个阶段？ ​\n\n诚实地回答以下问题，勾选符合你情况的选项：\n\n基础阶段（如果大部分是这些情况，继续用基础版即可）：\n\n- [ ] 我的项目只有 1-3 个文件\n- [ ] 我做的是个人使用的小工具\n- [ ] 大部分 bug 让 AI 帮忙就能解决\n- [ ] 我对现在的项目规模感到满意\n成长阶段（如果开始出现这些情况，可以考虑进阶）：\n\n- [ ] 我开始想要添加更多功能\n- [ ] 有些 bug 反复出现，AI 修不彻底\n- [ ] 我想让别人也能用我的工具\n- [ ] 我对代码\"为什么能工作\"产生了好奇\n进阶阶段（如果这些情况明显，建议进入进阶版学习）：\n\n- [ ] 我需要用户登录功能\n- [ ] 我需要数据存储在云端\n- [ ] 项目文件超过 10 个，开始感到混乱\n- [ ] AI 的回答经常不靠谱\n## 这些信号不是坏事 ​\n\n遇到升级信号，说明：\n\n- 你已经做出了东西——很多人还停留在\"想做但没动手\"的阶段\n- 你在真正使用工具——而不是浅尝辄止\n- 你的需求在增长——这是好事，说明你有想法\n这些信号是成长的标志，不是失败的证明。\n\n## 遇到信号后怎么办 ​\n选项适用情况行动简化需求核心功能已满足，额外功能是\"锦上添花\"砍掉复杂功能，保持简单重新开始项目已经乱到无法维护用学到的经验重新设计进入进阶版确实需要更复杂的功能系统学习后端、数据库等知识寻求帮助某个具体问题卡住了问社区、找教程、请教懂的人\n记住\n\n大多数人在基础版阶段，能做出非常有用的工具。不是每个人都需要进入进阶版。\n\n进阶是一个选择，不是必须。根据你的需求和兴趣来决定。\n\n## 本节要点 ​\n\n- 六个升级信号：bug 反复、越改越乱、80% 墙、想要登录、想做 App、AI 离谱\n- 这些信号是成长的标志，不是失败的证明\n- 遇到信号后有多种选择：简化需求、重新开始、进入进阶、寻求帮助\n- 进阶是选择，不是必须——根据你的需求决定\n→ 5.5.4 正确的心态",
      "word_count": 2178,
      "estimated_time": 4
    },
    {
      "id": "lesson-165",
      "chapter_id": "chapter-05",
      "lesson_number": 32,
      "title": "5.5.4 正确的心态",
      "content": "# 5.5.4 正确的心态：AI 是工具，不是魔法 ​\n\n经过本节学习，你将建立：\n\n- 与 AI 协作的正确心态\n- 对 AI 能力的合理预期\n- 作为\"指挥官\"而非\"依赖者\"的自我定位\n## AI 是聪明但没经验的实习生 ​\n\n想象一下，你有一个实习生：\n\n- 学历很高，知识面很广\n- 执行力强，让他做什么他就做什么\n- 但是没有工作经验，不了解你公司的具体情况\n- 有时候会犯低级错误，需要你检查\nAI 就是这样的\"实习生\"。\nAI 的优势AI 的局限知识储备丰富不了解你的具体情况执行速度快缺乏判断力不会疲劳会自信地犯错随叫随到不会主动质疑你的需求\n关键洞察：你不能完全依赖一个实习生，但一个好的实习生能大大提高你的效率。AI 也是如此。\n\n## 你是指挥官，AI 是执行者 ​\n\n这是最重要的心态转变：\n角色你（指挥官）AI（执行者）决策决定做什么、为什么做提供选项和建议执行验收结果生成代码和内容质量最终把关按要求输出责任承担后果无\n一个重要的事实：AI 生成的代码，最终责任在你。\n\n这不是坏事。这意味着你是掌控者。你决定用什么、不用什么、怎么修改。AI 只是你的工具，不是你的老板。\n\n## 三种错误的心态 ​\n\n### 错误心态一：完全依赖 ​\n\n表现：\n\n- AI 说什么就是什么\n- 不检查 AI 生成的代码\n- 出了问题怪 AI\n后果：\n\n- 代码质量不可控\n- 安全隐患不自知\n- 遇到 AI 解决不了的问题就卡住\n### 错误心态二：完全不信任 ​\n\n表现：\n\n- 觉得 AI 生成的代码都不靠谱\n- 每一行代码都要自己重写\n- 不敢用 AI 生成的任何东西\n后果：\n\n- 浪费了 AI 带来的效率提升\n- 错过了快速验证想法的机会\n- 学习曲线变得更陡峭\n### 错误心态三：期望过高 ​\n\n表现：\n\n- 以为 AI 能一次性完成复杂项目\n- 描述很模糊却期望完美结果\n- 遇到问题就觉得\"AI 不行\"\n后果：\n\n- 频繁失望\n- 错误归因（明明是描述不清，却怪 AI）\n- 放弃使用 AI\n## 正确的心态：信任但验证 ​\n\n英语里有句话叫\"Trust but verify\"（信任但验证），用在 AI 协作上非常合适。\n阶段信任验证生成代码相信 AI 能给出合理的起点检查代码是否符合预期修复 bug相信 AI 能找到问题测试修复是否真的有效添加功能相信 AI 能实现基本功能检查是否影响了已有功能安全相关不要信任必须仔细检查\n底线：涉及安全的内容（密码、密钥、用户数据），永远不要盲目相信 AI。\n\n## 从\"消费者\"到\"创造者\"的转变 ​\n\n使用 Vibe Coding 的过程，其实是一个身份转变的过程：\n消费者心态创造者心态\"给我一个完美的解决方案\"\"给我一个起点，我来完善\"\"这个不行，换一个\"\"这个差一点，帮我改这里\"\"AI 应该懂我想要什么\"\"我需要把想法说清楚\"\"出了问题是 AI 的错\"\"出了问题我来解决\"\n创造者心态的核心：你是主人，AI 是助手。你对结果负责，你有能力改进它。\n\n## 实用的协作技巧 ​\n\n基于正确的心态，这里有一些实用的协作技巧：\n\n### 技巧一：分步验证 ​\n\n不要让 AI 一次性完成大任务。分成小步，每步验证。\n\n`❌ 不好的做法\n\"帮我做一个完整的待办清单应用\"\n\n✅ 好的做法\n\"先帮我做一个能显示任务列表的页面\"\n（验证通过后）\n\"现在添加一个输入框，可以添加新任务\"\n（验证通过后）\n\"添加删除功能\"`\n### 技巧二：要求解释 ​\n当 AI 给出代码时，要求它解释关键部分。\n\n`\"这段代码的 localStorage 部分是怎么工作的？请用简单的语言解释\"`如果 AI 解释得清楚，说明代码可能是对的。如果解释得模糊或矛盾，说明需要警惕。\n\n### 技巧三：测试边界情况 ​\n\nAI 生成的代码通常处理\"正常情况\"很好，但边界情况容易出问题。\n\n`测试清单：\n- 如果输入为空会怎样？\n- 如果输入特别长会怎样？\n- 如果快速重复点击会怎样？\n- 如果网络断开会怎样？`\n### 技巧四：保持质疑 ​\n即使代码能运行，也要问自己：\n\n- 这真的是我想要的效果吗？\n- 有没有我没注意到的问题？\n- 如果数据量变大，还能正常工作吗？\n## 本节要点 ​\n\n- AI 是\"聪明但没经验的实习生\"——能帮大忙，但需要你把关\n- 你是指挥官，AI 是执行者——你决定做什么、验证结果、承担责任\n- 避免三种错误心态：完全依赖、完全不信任、期望过高\n- 正确心态是\"信任但验证\"——相信 AI 能给出好的起点，但必须检查\n- 从\"消费者\"转变为\"创造者\"——你是主人，对结果负责\n一句话总结\n\nAI 让你能做更多，但不能替你做决定。\n\n你是创造者，AI 是你的工具。用好它，但不要依赖它。\n\n→ 5.5.5 进阶版预告",
      "word_count": 2003,
      "estimated_time": 4
    },
    {
      "id": "lesson-166",
      "chapter_id": "chapter-05",
      "lesson_number": 33,
      "title": "5.5.5 进阶版预告",
      "content": "# 5.5.5 进阶版预告：突破天花板 ​\n\n经过本节阅读，你将了解：\n\n- 基础版学完后你具备的能力\n- 进阶版将解锁的新能力\n- 如何判断自己是否需要进入进阶版\n## 回顾：基础版你学会了什么 ​\n\n在进入进阶版之前，先回顾一下你已经掌握的能力：\n章节核心能力你能做什么第一章Vibe Coding 基础认知知道 AI 编程是什么、选对工具第二章产品思维想清楚做什么、为谁做、解决什么问题第三章提示词工程把想法清晰地告诉 AI第四章实战开发从零做出一个完整的个人工具第五章精进技能版本管理、部署上线、安全意识、迭代思维\n你已经能做的事情：\n\n- 做出一个能用的个人工具（如待办清单、记账本）\n- 把作品部署到互联网上，分享给朋友\n- 用版本管理保护你的代码\n- 识别和避免常见的安全问题\n- 根据反馈持续改进你的作品\n这已经非常了不起了。 很多人想学编程多年，但从未真正做出过可以上线的东西。\n\n## 基础版的边界在哪里 ​\n\n基础版能做的：\n能做限制个人使用的工具只能本地存储，换设备数据会丢失静态网站没有用户系统，无法区分不同用户简单的交互数据量大时可能变慢单人开发多人协作会遇到问题\n基础版不能做（或很难做）的：\n不能做需要什么用户注册登录后端 + 数据库 + 用户认证数据云端同步服务器 + 数据库多用户协作权限管理 + 实时同步大型项目架构设计 + 代码组织手机 App移动开发技术栈\n如果你的需求在\"能做\"的范围内，基础版已经足够。\n\n## 进阶版将解锁的新能力 ​\n\n进阶版的内容是为那些想要突破基础版边界的人准备的：\n\n### 模块一：理解代码原理 ​\n你将学会带来的好处代码是如何运行的遇到问题不再\"瞎猜\"常见的编程概念能读懂 AI 生成的代码调试的方法论能系统地排查问题\n解锁能力：从\"代码能跑就行\"到\"知道为什么能跑\"。\n\n### 模块二：数据库开发 ​\n你将学会带来的好处什么是数据库数据不再\"只存在浏览器里\"如何设计数据结构数据组织得井井有条基础的增删改查能保存和管理复杂数据\n解锁能力：数据可以持久保存、可以在不同设备访问。\n\n### 模块三：后端开发 ​\n你将学会带来的好处什么是前端和后端理解完整的应用架构如何写简单的 API前后端可以\"对话\"服务器的基本概念知道应用是怎么运行的\n解锁能力：能做需要服务器的应用。\n\n### 模块四：用户认证 ​\n你将学会带来的好处注册登录的原理能实现用户系统安全的密码处理不会犯低级安全错误权限控制基础用户只能看到自己的数据\n解锁能力：能做多用户的应用。\n\n### 模块五：团队协作与项目管理 ​\n你将学会带来的好处Git 进阶使用能和其他人一起开发代码审查代码质量更高项目规划大项目也能有条不紊\n解锁能力：能参与团队项目，管理更大的代码库。\n\n## 进阶版学习路径预览 ​\n\n`基础版毕业\n    │\n    ├─→ 如果只想做个人工具 → 继续用基础版，享受创造的乐趣\n    │\n    └─→ 如果想突破边界 → 进入进阶版\n                            │\n                            ├─→ Bootcamp：补齐计算机基础\n                            │\n                            ├─→ 前端深入：组件化、状态管理\n                            │\n                            ├─→ 后端入门：API、数据库\n                            │\n                            ├─→ 全栈整合：做一个完整应用\n                            │\n                            └─→ 部署运维：让应用稳定运行`\n## 你需要进入进阶版吗？ ​\n做一个简单的自测：\n\n如果以下大部分回答是\"是\"，你可以考虑进入进阶版：\n\n- [ ] 我想做的东西需要用户登录功能\n- [ ] 我希望数据能在不同设备同步\n- [ ] 我想让多个人一起使用同一个应用\n- [ ] 我对\"代码是怎么工作的\"产生了好奇\n- [ ] 我想参与团队开发或者开源项目\n- [ ] 我有明确的目标，需要更复杂的功能\n如果以下大部分回答是\"是\"，继续用基础版就够了：\n\n- [ ] 我做的东西主要是自己用\n- [ ] 本地存储已经能满足我的需求\n- [ ] 我对\"为什么能工作\"不太关心，能用就行\n- [ ] 我没有明确需要用户系统的需求\n- [ ] 我享受现在的创造过程，不想增加复杂度\n两种选择都是对的。 基础版已经能让你做出很多有用的东西。进阶是一个选择，不是必须。\n\n## 从\"玩具\"到\"真正的应用\" ​\n\n如果用一句话总结进阶版的价值：\n\n基础版让你能做\"玩具\"——有用、好玩、但有限制。\n\n进阶版让你能做\"真正的应用\"——可以给很多人用、可以商业化、可以长期维护。\n\n这个跨越需要更多的学习，但也会带来更大的可能性。\n\n## 本节要点 ​\n\n- 基础版你已经学会：产品思维、提示词工程、实战开发、精进技能\n- 基础版的边界：个人工具、静态网站、本地存储、单人开发\n- 进阶版解锁：代码原理、数据库、后端、用户认证、团队协作\n- 是否进入进阶版是选择，不是必须——根据你的需求决定\n最后的话\n\n无论你选择继续用基础版，还是进入进阶版学习，你都已经迈出了重要的一步。\n\n从\"想做但不知道怎么做\"到\"能做出东西并上线\"——这个跨越比你想象的更有价值。\n\n去创造吧。\n\n→ 5.6 启程前：本章总结与进阶预告",
      "word_count": 2366,
      "estimated_time": 4
    },
    {
      "id": "lesson-167",
      "chapter_id": "chapter-05",
      "lesson_number": 34,
      "title": "5.6.1 本章核心要点回顾",
      "content": "# 5.6.1 本章核心要点回顾 ​\n\n经过本节阅读，你将获得：\n\n- 第五章完整知识结构图\n- 核心概念速查表（可收藏）\n- 技能对照清单\n## 第五章知识结构 ​\n\n`第五章：从\"能用\"到\"好用\"\n│\n├── 5.1 后悔药（版本管理）\n│   ├── AI IDE 自带历史功能（零门槛）\n│   ├── 手动版本管理（简单有效）\n│   └── GitHub Desktop（为进阶准备）\n│\n├── 5.2 见世面（部署上线）\n│   ├── Zeabur 一键部署（大陆用户首选）\n│   ├── Vercel 一键部署（海外/有域名用户）\n│   └── 大陆访问解决方案\n│\n├── 5.3 护城河（安全意识）\n│   ├── 三个绝对禁令\n│   ├── .env 和 .gitignore 配置\n│   ├── Slopsquatting 防范\n│   └── 永远审查代码\n│\n├── 5.4 再进化（持续迭代）\n│   ├── 收集反馈的方法\n│   ├── 功能扩展的流程\n│   └── 从项目到作品集\n│\n└── 5.5 知边界（能力边界）\n    ├── Vibe Coding 擅长什么\n    ├── Vibe Coding 的局限\n    └── 升级信号识别`\n## 核心概念速查表 ​\n这张表汇总了第五章最重要的概念，可以收藏备用：\n概念一句话解释为什么重要版本管理给代码装上\"时光机\"，可以随时回到过去改崩了不怕，大胆实验Commit一次\"存档\"，记录代码在某个时刻的状态每个存档都是一个安全点部署把本地代码放到服务器上，让别人能访问从\"自己玩\"到\"分享给世界\"域名网站的\"门牌号\"，如 example.com让别人能找到你的作品.env 文件存放密钥等敏感信息的配置文件保护你的隐私和账户安全.gitignore告诉 Git 哪些文件不要上传防止敏感信息泄露SlopsquattingAI 推荐不存在的库，被恶意者抢注2024-2025 年新型安全威胁迭代根据反馈不断改进产品好产品是改出来的，不是一次做出来的README项目的说明文档，介绍项目是什么、怎么用让别人（和未来的自己）看懂项目\n## 技能对照清单 ​\n\n完成第五章后，对照检查你掌握的技能：\n\n### 5.1 版本管理 ​\n技能掌握标准自评使用 AI IDE 历史功能能找到并恢复到之前的代码版本☐手动备份项目知道在重要节点复制整个项目文件夹☐使用 GitHub Desktop能完成 Clone、Commit、Push 操作☐写清晰的 Commit 信息能一句话说明这次改了什么☐\n### 5.2 部署上线 ​\n技能掌握标准自评选择合适的部署平台知道 Zeabur 适合大陆用户，Vercel 适合海外☐完成一键部署能把项目从 GitHub 部署到平台☐获得访问链接项目有了可公开访问的网址☐验证部署成功能在手机和电脑上都正常访问☐\n### 5.3 安全意识 ​\n技能掌握标准自评三禁令熟记于心不告诉 AI 密钥、不硬编码密钥、不上传 .env☐配置 .gitignore知道把 .env 和 node_modules 加入忽略列表☐验证 AI 推荐的库安装前去官方包管理网站确认存在☐审查代码的习惯不盲目信任 AI 生成的代码☐\n### 5.4 持续迭代 ​\n技能掌握标准自评收集用户反馈知道让真实用户试用并记录问题☐规划功能扩展能用 S.C.A.F.F. 框架让 AI 添加新功能☐整理作品集能写一个清晰的 README 文件☐\n### 5.5 认知边界 ​\n技能掌握标准自评知道擅长什么清楚 Vibe Coding 适合做个人工具、静态网站☐知道局限在哪清楚复杂后端、用户系统需要进阶学习☐识别升级信号知道什么时候该学习更深入的知识☐\n## 常见误区提醒 ​\n\n基于前面章节的学习，这里提醒几个容易踩的坑：\n误区正确做法\"我要等代码完美了再 Commit\"半成品也可以 Commit，随时可以改\"部署好麻烦，先本地用着吧\"部署只需要几分钟，现在就做\"AI 生成的代码应该没问题\"永远审查，特别是涉及安全的部分\"基础版太简单，我要直接学进阶\"基础版的方法论是进阶的根基\"我做的东西太简单，不好意思分享\"能解决问题的就是好东西，大胆分享\n## 本节要点 ​\n\n- 第五章的核心是让你的作品\"从能用到好用\"\n- 版本管理、部署、安全、迭代、边界认知——五大能力缺一不可\n- 对照技能清单检查自己的掌握程度\n- 避开常见误区，建立正确的习惯\n→ 5.6.2 基础版完整学习路径",
      "word_count": 1893,
      "estimated_time": 3
    },
    {
      "id": "lesson-168",
      "chapter_id": "chapter-05",
      "lesson_number": 35,
      "title": "5.6.2 基础版完整学习路径",
      "content": "# 5.6.2 基础版完整学习路径回顾 ​\n\n经过本节阅读，你将获得：\n\n- 从第一章到第五章的完整技能习得路径\n- 每章对应的里程碑成就\n- 你在 AI 编程浪潮中的位置\n## 你走过的路 ​\n\n`基础版学习之旅\n│\n├── 第一章：觉醒\n│   ├── 理解：什么是 Vibe Coding\n│   ├── 破除：编程很难的迷思\n│   ├── 选择：适合自己的 AI 编程工具\n│   └── 完成：第一个 3 分钟 AI 网页\n│\n├── 第二章：心法\n│   ├── 掌握：JTBD 用户需求框架\n│   ├── 学会：MVP 最小可行产品思维\n│   ├── 运用：灵魂三问定义项目\n│   └── 完成：待办清单的需求规划\n│\n├── 第三章：技法\n│   ├── 理解：Context is King 原则\n│   ├── 掌握：S.C.A.F.F. 提示词框架\n│   ├── 学会：迭代对话的技巧\n│   └── 完成：第一份 PRD 文档\n│\n├── 第四章：实战\n│   ├── 搭建：页面框架（静态层）\n│   ├── 实现：增删改查（交互层）\n│   ├── 添加：本地存储（存储层）\n│   └── 完成：可运行的待办清单应用\n│\n└── 第五章：精进\n    ├── 保护：代码版本管理\n    ├── 发布：部署到互联网\n    ├── 防护：安全意识建立\n    ├── 进化：持续迭代能力\n    └── 认知：能力边界清晰`\n## 技能习得里程碑 ​\n每一章都是一个里程碑，让我们看看你具体获得了什么：\n章节里程碑你获得的能力第一章Hello World从零到一的突破，证明\"我也能做\"第二章需求文档想清楚再动手，避免\"做着做着不知道要什么\"第三章高效沟通让 AI 真正理解你，不再\"鸡同鸭讲\"第四章完整作品亲手做出可运行的应用，建立真正的信心第五章上线分享让全世界都能访问，从\"学习者\"变成\"创造者\"\n## 从消费者到创造者的转变 ​\n\n回顾你的起点和现在：\n维度学习前学习后心态\"编程太难了，我不行\"\"说清楚需求，AI 帮我实现\"能力只能用别人做的东西能做出自己想要的工具视角作为用户抱怨功能不好作为创造者思考如何改进工具手动处理重复劳动让 AI 帮我自动化成果想法停留在脑子里想法变成可运行的作品\n## 你在行业中的位置 ​\n\n根据 2025 年的行业数据，你现在的位置是：\n\n根据 Stack Overflow 2025 开发者调查，84% 的开发者正在使用或计划使用 AI 编程工具。\n\n你已经是这 84% 中的一员。\n\n更重要的是：\n数据来源你的位置到 2025 年，70% 的新应用将使用低代码/无代码技术Gartner 预测你已经掌握了这种能力公民开发者与专业开发者的比例将达到 4:1Hostinger 2025 报告你已经是\"公民开发者\"AI 辅助编程可节省 30-75% 的开发时间Second Talent 2025 统计你已经开始享受这个红利\n**\"公民开发者\"**指的是非专业程序员背景，但能使用工具创建应用的人。这是一个正在快速增长的群体，而你已经是其中一员。\n\n## 基础版在整个学习体系中的位置 ​\n\n`Vibe Coding 学习体系\n│\n├── 基础版（你现在的位置）← 你在这里\n│   ├── 目标：能做出个人工具并上线\n│   ├── 技术栈：HTML + CSS + JS + localStorage\n│   └── 产出：静态网站、个人工具\n│\n└── 进阶版（下一步可选）\n    ├── 目标：能做需要后端的完整应用\n    ├── 技术栈：Next.js + TypeScript + 数据库\n    └── 产出：多用户应用、全栈项目`\n## 这是一个了不起的跨越 ​\n从对编程一无所知，到能够独立做出一个可以上线、可以分享的工具。\n\n这个跨越的价值在于：\n\n- 证明了可能性：你不再是\"想学编程的人\"，而是\"做过项目的人\"\n- 建立了方法论：你知道从想法到作品的完整流程\n- 培养了习惯：版本管理、安全意识、迭代思维\n- 打开了大门：无论是继续深入学习，还是用现有能力创造价值，路都在脚下\n## 本节要点 ​\n\n- 基础版五章形成完整的能力闭环：觉醒→心法→技法→实战→精进\n- 每一章都是一个里程碑，都有具体的能力产出\n- 你已经完成了从\"消费者\"到\"创造者\"的身份转变\n- 在 AI 编程的浪潮中，你已经站在了正确的位置\n→ 5.6.3 你现在能做什么",
      "word_count": 1878,
      "estimated_time": 3
    },
    {
      "id": "lesson-169",
      "chapter_id": "chapter-05",
      "lesson_number": 36,
      "title": "5.6.3 你现在能做什么",
      "content": "# 5.6.3 你现在能做什么 ​\n\n经过本节阅读，你将获得：\n\n- 完成基础版后的能力清单\n- 25+ 个按场景分类的项目建议\n- 每个项目的核心挑战和参考方法\n- 30 天持续练习计划\n## 完成基础版后，你具备的能力 ​\n能力维度具体表现可以做什么产品思维能用 JTBD、MVP 思维规划项目清晰定义\"为谁做、做什么、为什么\"提示词工程能用 S.C.A.F.F. 框架与 AI 高效沟通让 AI 准确理解需求，减少返工前端开发能做出包含增删改查的个人工具静态网站、表单交互、数据展示本地存储能使用 localStorage 保存数据数据刷新不丢失，换设备需重新输入版本管理能保护代码不丢失大胆实验，改崩了随时回退部署上线能把作品发布到互联网分享给朋友，获得真实反馈安全意识知道如何避免常见的安全坑保护自己的账户和隐私迭代能力能根据反馈持续改进让作品越来越好用\n## 项目建议：按场景分类 ​\n\n以下项目都可以用基础版学到的方法完成。挑一个你感兴趣的开始吧。\n\n### 场景一：个人效率工具 ​\n\n这类项目帮你管理时间、任务和个人事务。\n项目核心功能学习价值难度番茄钟25分钟倒计时 + 休息提醒 + 专注记录学习定时器和时间处理⭐⭐习惯打卡器每日打卡 + 连续天数 + 日历视图学习日期处理和数据统计⭐⭐简易记账本收支记录 + 分类统计 + 月度汇总学习数字计算和数据展示⭐⭐读书笔记书籍管理 + 笔记记录 + 标签分类学习文本处理和搜索过滤⭐⭐⭐密码生成器自定义长度 + 字符类型选择 + 一键复制学习随机数和剪贴板操作⭐倒计时工具目标日期设置 + 剩余天数显示学习日期差值计算⭐每日一句随机名言 + 收藏功能 + 分享按钮学习数组随机和分享API⭐\n参考方法：使用待办清单的开发流程，先用 S.C.A.F.F. 框架描述需求，再分层实现。\n\n### 场景二：数据分析可视化 ​\n\n这类项目帮你整理和展示数据。虽然基础版不涉及复杂的数据库，但可以用本地数据做简单的分析展示。\n项目核心功能学习价值难度个人支出分析手动输入数据 + 饼图/柱状图展示学习图表库使用（如 Chart.js）⭐⭐⭐阅读统计阅读时长记录 + 周/月汇总图表学习时间统计和数据聚合⭐⭐体重追踪每日记录 + 趋势折线图学习折线图绑定数据⭐⭐学习时间统计科目分类 + 时长记录 + 占比分析学习多维度数据处理⭐⭐⭐问卷结果展示静态数据输入 + 可视化报告页学习数据可视化基础⭐⭐\n参考方法：让 AI 帮你集成 Chart.js 等图表库，你只需要提供数据结构和展示需求。\n\n### 场景三：自动化脚本/批处理 ​\n\n这类项目帮你减少重复劳动。基础版主要做浏览器端的自动化，复杂的本地文件操作需要进阶版。\n项目核心功能学习价值难度文本格式转换文本输入 + 格式转换（大小写、去空格等）学习字符串处理⭐JSON 格式化JSON 输入 + 美化/压缩 + 语法检查学习 JSON 解析和格式化⭐⭐Markdown 预览器实时编辑 + 即时预览学习 Markdown 解析库⭐⭐链接批量提取粘贴文本 + 自动提取所有链接学习正则表达式基础⭐⭐单位换算器长度/重量/温度等单位转换学习数学计算和单位换算⭐\n参考方法：这类工具通常输入输出明确，非常适合用 Vibe Coding 快速实现。\n\n### 场景四：给家人/朋友做的工具 ​\n\n这类项目帮你解决身边人的实际问题，是获得真实反馈的最佳方式。\n项目核心功能适合谁难度家庭菜单规划每周菜单 + 食材清单生成负责做饭的家人⭐⭐药物提醒用药记录 + 定时提醒需要定期服药的长辈⭐⭐生日提醒亲友生日管理 + 倒计时提醒容易忘记重要日子的人⭐⭐简易相册图片上传展示 + 时间轴排列想分享照片的家人⭐⭐⭐购物清单共享清单 + 已购标记一起生活的家人⭐⭐家庭记账本共同支出记录 + 分类统计合租室友或小家庭⭐⭐⭐\n参考方法：先和使用者聊聊他们的痛点（用灵魂三问），再用 MVP 思维确定核心功能。\n\n### 场景五：个人展示/创意项目 ​\n\n这类项目展示你的个人品牌或创意想法。\n项目核心功能学习价值难度个人主页自我介绍 + 作品集展示 + 联系方式学习页面布局和样式设计⭐⭐在线简历响应式简历页面 + 下载PDF功能学习响应式设计和打印样式⭐⭐作品集网站项目展示 + 详情页 + 技术栈说明整合所有学习成果⭐⭐⭐小游戏：猜数字随机数生成 + 猜测反馈 + 记录次数学习游戏逻辑设计⭐小游戏：记忆翻牌卡片匹配 + 计时 + 最佳记录学习状态管理和动画⭐⭐⭐表白网页动画效果 + 音乐播放 + 个性化内容学习CSS动画和音频API⭐⭐\n参考方法：创意项目不需要复杂功能，重点是视觉效果和交互体验。让 AI 帮你实现炫酷的 CSS 动画。\n\n## 如何选择你的下一个项目 ​\n\n不知道选哪个？用这个决策流程：\n\n`你现在最想解决什么问题？\n│\n├── 工作/学习效率低 → 番茄钟、习惯打卡器\n├── 数据杂乱无章 → 记账本、阅读统计\n├── 重复劳动太多 → 文本格式转换、链接提取\n├── 想帮助家人朋友 → 药物提醒、生日提醒\n└── 想展示自己 → 个人主页、在线简历`核心原则：选一个你真正会用的项目，而不是\"看起来最酷\"的项目。\n\n## 30 天练习计划 ​\n\n如果你想持续提升，可以尝试这个计划：\n周次目标建议项目第 1 周复习巩固给待办清单添加 2-3 个新功能第 2 周独立完成选一个 ⭐ 难度的项目从零做起第 3 周挑战进阶选一个 ⭐⭐ 难度的项目第 4 周分享展示整理作品集，写 README，分享给朋友\n每个项目的标准流程：\n\n- 用灵魂三问定义需求\n- 用 S.C.A.F.F. 框架写第一个 Prompt\n- 分层迭代实现功能\n- 部署上线，收集反馈\n- 整理成作品集\n## 本节要点 ​\n\n- 基础版让你具备了做个人工具的完整能力\n- 25+ 个项目建议覆盖效率、数据、自动化、家人、创意五大场景\n- 选项目的关键是\"你真正会用\"，而不是\"看起来最酷\"\n- 30 天计划帮你持续练习，巩固方法论\n记住\n\n每做一个项目，你就更熟练一点。\n\n从第一个待办清单开始，你已经证明了自己能做出东西。现在，去做更多。\n\n→ 5.6.4 进入进阶版的准备",
      "word_count": 2587,
      "estimated_time": 5
    },
    {
      "id": "lesson-170",
      "chapter_id": "chapter-05",
      "lesson_number": 37,
      "title": "5.6.4 进入进阶版的准备",
      "content": "# 5.6.4 进入进阶版的准备 ​\n\n经过本节阅读，你将获得：\n\n- 基础版毕业自测清单\n- 判断是否需要进阶的 5 个信号\n- 进阶版详细模块预告\n- 基础版到进阶版的技能升级路径\n## 自测：你准备好了吗？ ​\n\n完成以下自测，每项打勾得 1 分：\n\n### 核心能力（必备项） ​\n\n- [ ] 我完成了至少一个完整的 Vibe Coding 项目\n- [ ] 我能用 S.C.A.F.F. 框架写出清晰的 Prompt\n- [ ] 我理解版本管理的基本概念（Commit、Push）\n- [ ] 我成功部署过项目到互联网\n- [ ] 我知道三大安全禁令\n### 思维能力（加分项） ​\n\n- [ ] 我能用灵魂三问定义一个项目的需求\n- [ ] 我能区分\"必须有\"和\"可以有\"的功能\n- [ ] 当 AI 给出错误答案时，我知道如何调整 Prompt\n- [ ] 我养成了提交前检查敏感信息的习惯\n- [ ] 我清楚 Vibe Coding 的能力边界\n### 评分标准 ​\n得分建议8-10 分你已经完全准备好了，可以直接进入进阶版5-7 分建议再做 1-2 个基础版项目巩固，然后进入进阶版0-4 分建议回顾第二到第五章，重点补足薄弱环节\n## 需要进阶的 5 个信号 ​\n\n如果你遇到以下情况，说明是时候学习进阶版了：\n\n### 信号 1：你想要用户登录功能 ​\n\n场景：你做了一个记账本，想让家人各自登录，看到自己的数据。\n\n为什么基础版做不到：用户登录需要后端验证身份，需要数据库存储账号信息。localStorage 只能存在单个浏览器里。\n\n进阶版解决方案：NextAuth 用户认证 + 数据库存储\n\n### 信号 2：你想要数据云端同步 ​\n\n场景：你在公司电脑上记录的待办，回家想在自己电脑上继续看。\n\n为什么基础版做不到：localStorage 是浏览器本地存储，不同设备、不同浏览器之间无法共享。\n\n进阶版解决方案：后端 API + 数据库 + 用户认证\n\n### 信号 3：你想做多人协作功能 ​\n\n场景：你想做一个家庭共享的购物清单，家人可以同时编辑。\n\n为什么基础版做不到：多人同时操作需要实时同步，需要处理数据冲突。\n\n进阶版解决方案：WebSocket 实时通信 + 冲突处理策略\n\n### 信号 4：你对\"代码为什么能工作\"产生好奇 ​\n\n场景：AI 给你的代码能用，但你想知道为什么这样写。\n\n为什么基础版没讲：基础版的目标是\"能做出东西\"，不深究原理。\n\n进阶版解决方案：Bootcamp 模块系统讲解计算机基础、网络原理、编程概念\n\n### 信号 5：你想参与团队项目 ​\n\n场景：你想和朋友一起开发一个项目，或者参与开源项目。\n\n为什么基础版不够：多人协作需要分支管理、代码审查、CI/CD 流程。\n\n进阶版解决方案：Git 进阶工作流 + 团队协作最佳实践\n\n## 不需要进阶的场景 ​\n\n同样重要的是，认清什么时候不需要进阶：\n场景基础版已经够用做给自己用的个人工具localStorage 能满足需求静态展示网站（个人主页、简历）不需要后端简单的计算/转换工具纯前端就能实现学习和练习 AI 编程基础版方法论可复用快速验证一个想法MVP 不需要完整后端\n基础版已经够用的情况下，不必急于进阶。 用基础版多做几个项目，把方法论内化，比匆忙学习新技术更重要。\n\n## 进阶版模块详解 ​\n\n如果你决定进入进阶版，以下是你将学习的内容：\n\n### Bootcamp：计算机基础 ​\n你将学到解决什么问题文件系统和路径理解项目结构，不再\"找不到文件\"命令行基础不怕黑窗口，能执行基本操作网络基础（HTTP、DNS）理解网页是如何加载的前端三件套原理知道 HTML/CSS/JS 各自的角色\n### 技术栈：Next.js 全栈开发 ​\n技术作用为什么选它Next.js前后端一体化框架上手快，生态好，部署方便TypeScript类型安全的 JavaScript减少错误，AI 生成代码更可靠Prisma数据库操作工具不用写 SQL，用代码操作数据库Tailwind CSS样式框架快速构建美观界面\n### 核心能力提升 ​\n基础版技能进阶后升级为localStorage 存储数据库持久化（PostgreSQL/MySQL）静态页面部署全栈应用部署（包含后端）个人使用工具多用户协作平台手动测试自动化测试 + CI/CDGitHub DesktopGit 命令行 + 分支策略基础安全意识完整的 Web 安全防护\n### 进阶版学习路径预览 ​\n\n`进阶版学习之旅\n│\n├── Bootcamp（2-3 天）\n│   └── 补齐计算机基础，为后续学习打基础\n│\n├── 第 1-2 章：概念与工具（3-4 天）\n│   └── Next.js 项目搭建 + AI 协作工作流\n│\n├── 第 3-4 章：前后端开发（1-2 周）\n│   └── 页面开发 + API 设计 + 数据库操作\n│\n├── 第 5-6 章：产品与安全（3-4 天）\n│   └── PRD 文档 + 用户认证 + 安全防护\n│\n├── 第 7-9 章：工程实践（1 周）\n│   └── API 规范 + Git 协作 + 测试\n│\n├── 第 10-11 章：部署运维（3-4 天）\n│   └── Docker + CI/CD + 监控\n│\n└── 第 12 章：高级专题（选学）\n    └── SEO + 实时通信 + 文件处理`预计总学习时间：4-6 周（每天 2-3 小时）\n\n## 从基础版到进阶版的平滑过渡 ​\n\n进阶版会复用基础版的核心方法论：\n基础版方法进阶版如何延续JTBD / MVP 思维用于设计更复杂的功能S.C.A.F.F. 框架继续用于与 AI 沟通迭代开发用于全栈项目开发安全三禁令扩展为完整的安全体系版本管理升级为专业的 Git 工作流\n你在基础版学到的一切都不会浪费。 进阶版是在这个基础上的延伸和深化。\n\n## 本节要点 ​\n\n- 用自测清单评估自己的准备程度\n- 5 个信号告诉你是否需要进阶\n- 基础版够用时不必急于进阶\n- 进阶版会复用基础版的核心方法论\n- 预计 4-6 周完成进阶版学习\n最后的话\n\n进阶是一个选择，不是必须。\n\n如果基础版已经能满足你的需求，继续用它创造价值。\n\n如果你想突破边界，进阶版在等着你。\n\n→ 5.6.5 结语",
      "word_count": 2662,
      "estimated_time": 5
    },
    {
      "id": "lesson-171",
      "chapter_id": "chapter-05",
      "lesson_number": 38,
      "title": "5.6.5 结语",
      "content": "# 5.6.5 结语：你已经是创造者了 ​\n\n## 回顾你的旅程 ​\n\n让我们最后一次回顾你的起点和现在：\n维度起点现在身份想学编程的人做出作品的创造者心态\"编程太难了\"\"说清楚需求就能实现\"能力只能用别人的工具能做出自己的工具成果想法停在脑子里想法变成了可访问的网站习惯不知道代码怎么保护懂得版本管理和安全意识\n这个转变，在过去可能需要几个月甚至几年的系统学习。\n\n而你，用 AI 作为伙伴，在很短的时间内就完成了。\n\n## 你加入了一个正在快速增长的群体 ​\n\n根据 2025 年的行业数据：\n\n84% 的开发者正在使用或计划使用 AI 编程工具。\n\n——Stack Overflow 2025 开发者调查\n\n到 2025 年，公民开发者与专业开发者的比例将达到 4:1。\n\n——Hostinger 2025 报告\n\n你不是在\"用 AI 作弊\"，你是学会了一种新的创造方式。\n\n在这个时代，清晰表达需求的能力比记住语法规则更重要。而这正是你在过去几章中练习的核心技能。\n\n## 你获得的不只是技术能力 ​\n\n回顾基础版的学习，你获得的远不止\"会用 AI 写代码\"：\n你获得的这意味着产品思维面对任何问题，你知道如何拆解和定义结构化表达你能把模糊的想法变成清晰的需求迭代心态你知道\"完成\"只是开始，\"完善\"才是关键学习能力你证明了自己能快速学习新领域创造自信你知道自己能把想法变成现实\n这些能力不仅适用于编程，也适用于工作和生活的方方面面。\n\n## 创造者的身份认证 ​\n\n从今天起，你可以告诉自己：\n\n我不是\"想学编程的人\"。\n\n我是做过项目的人。\n\n我是能把想法变成现实的人。\n\n我是创造者。\n\n这个身份，没有人可以从你手中夺走。\n\n## 接下来的路 ​\n\n完成基础版后，你有三条路可以走：\n\n### 路径一：用基础版继续创造 ​\n\n如果你的需求是个人工具、静态网站、简单的效率工具——基础版已经完全够用。\n\n用你学到的方法，去做更多项目：\n\n- 给自己做一个习惯打卡器\n- 给家人做一个药物提醒工具\n- 做一个个人主页展示你的作品\n每做一个项目，你就更熟练一点。\n\n### 路径二：进入进阶版学习 ​\n\n如果你想要：\n\n- 用户登录功能\n- 数据云端同步\n- 多人协作\n- 理解代码原理\n进阶版《Vibe Coding 全栈实战教程》在等着你。\n\n### 路径三：带着方法论去探索 ​\n\n基础版教你的不只是 Vibe Coding，更是一套从想法到实现的方法论：\n\n- JTBD 和 MVP 思维可以用于任何产品设计\n- S.C.A.F.F. 框架可以用于任何 AI 工具\n- 迭代和安全意识可以用于任何项目\n带着这些方法论，去探索更多可能性。\n\n## 最后的话 ​\n\n走到这里，你已经完成了 Vibe Coding 基础版的全部内容。\n\n从对编程一无所知，到能够独立做出一个可以上线、可以分享的工具——这是一个了不起的跨越。\n\n这不是终点，而是新的起点。\n\n去解决那些困扰你的小问题。\n\n去做那些你一直想做的小工具。\n\n去帮助你身边的人。\n\n世界等着看你的作品。\n\n## 致未来的你 ​\n\n也许半年后，你会回头看现在做的第一个待办清单，觉得它很简陋。\n\n那很正常。\n\n那正是你成长的证明。\n\n记住现在这个时刻——你刚刚证明了自己\"能做出东西\"的时刻。\n\n带着这份信心，继续前进。\n\n基础版完结\n\n恭喜你完成了 Vibe Coding 基础版的全部内容。\n\n从现在起，你是创造者。\n\n去创造吧。",
      "word_count": 1451,
      "estimated_time": 3
    },
    {
      "id": "lesson-172",
      "chapter_id": "chapter-101",
      "lesson_number": 1,
      "title": "进阶版核心内容详解",
      "content": "# 进阶版核心内容详解 ​\n\n想知道进阶版具体会教什么？这里是详细介绍。\n\n## 第 0 章：Bootcamp —— 零基础概念打底 ​\n\n为什么需要这一章？\n\n进阶版会涉及更多\"技术性\"的内容。这一章帮你建立必要的认知基础。\n\n你将学到：\n小节内容0.0课程概念定义：什么是全栈开发0.1计算机基础：文件系统、进程、端口0.2命令行入门：像黑客一样操作电脑0.3前端三件套：HTML、CSS、JavaScript0.3.5网络基础：HTTP、域名、DNS0.4开发环境配置：Node.js、包管理器0.5TypeScript 入门：从动态到静态类型0.6开发安全底线：环境变量与密钥管理0.7Docker 核心概念：容器化入门\n💡 如果你有编程基础\n\n可以根据自身情况跳过部分章节。但建议至少浏览一遍 0.5（TypeScript）和 0.7（Docker）。\n\n## 第 1 章：概念与准备 —— 从思维到工具 ​\n\n这一章做什么？\n\n把 Bootcamp 的认知转化为可执行的行动。搭建完整的开发环境，跑通第一个 Next.js 项目。\n\n你将学到：\n\n- 工具装配与验证：选择 IDE、配置 AI 助手\n- Vibe Coding 心法进阶：如何\"指挥\" AI 而不是被 AI 牵着走\n- 最小上线实战：用 1Panel 完成第一次部署\n- AI 协作工作流：建立可复用的人机协作模式\n核心目标：\n\n✅ 拥有一套完整的开发环境\n\n✅ 跑通第一个 Hello World\n\n✅ 完成第一次部署，拥有一个全世界都能访问的 URL\n\n## 第 2 章：技术选型与架构蓝图 ​\n\n这一章做什么？\n\n理解为什么选择 Next.js + TypeScript + Prisma 这套技术栈。了解现代全栈应用的架构设计。\n\n你将学到：\n\n- 技术栈全景与版本管理策略\n- Next.js App Router 架构详解\n- 渲染策略：CSR / SSR / SSG / ISR 的区别与选择\n- 前后端协作与 API 契约\n- 架构分层：表现层 / 接口层 / 业务层 / 数据层\n- Supabase 适用场景与取舍\n核心理解：\n\n技术选型的本质不是选\"最好的\"，而是选\"最适合的\"。\n\n## 第 3 章：前端开发 —— 把页面跑起来 ​\n\n这一章做什么？\n\n从基础的 React 组件到完整的页面，掌握现代前端开发的核心技能。\n\n你将学到：\n\n- React 组件基础：函数组件、JSX、Props\n- 状态管理：useState、useEffect\n- 路由系统：Next.js 的文件系统路由\n- UI 组件库：shadcn/ui 实战\n- 样式方案：Tailwind CSS 原子化 CSS\n## 第 4 章：数据库与数据 —— 数据生命周期管理 ​\n\n这一章做什么？\n\n从简单的数据存储到完整的数据库设计，掌握数据管理的核心能力。\n\n你将学到：\n\n- PostgreSQL 基础：关系型数据库入门\n- Prisma ORM：类型安全的数据库操作\n- 数据建模：如何设计数据表结构\n- CRUD 操作：增删改查的最佳实践\n- 数据验证：保证数据质量\n## 第 5 章：产品与文档 —— 让人和 AI 都读得懂 ​\n\n这一章做什么？\n\n从基础版的简单 PRD 到更专业的文档体系，让你的项目可维护、可协作。\n\n你将学到：\n\n- PRD 进阶：更完整的需求文档\n- 技术文档：架构文档、API 文档\n- 文档自动生成：让 AI 帮你写文档\n- 版本管理：文档的版本控制\n## 第 6 章：认证与安全 —— 权限管理 ​\n\n这一章做什么？\n\n实现用户注册、登录、权限控制，保护你的应用和用户数据。\n\n你将学到：\n\n- 认证 vs 授权：两个概念的区别\n- JWT 和 Session：两种认证方式\n- NextAuth.js：开箱即用的认证方案\n- 权限控制：基于角色的访问控制（RBAC）\n- 安全最佳实践：防范常见攻击\n## 第 7 章：API 设计规范 ​\n\n这一章做什么？\n\n设计规范、易用、安全的 API 接口。\n\n你将学到：\n\n- RESTful 设计原则\n- 请求与响应格式规范\n- 数据校验：Zod 验证库\n- 错误处理：统一的错误响应\n- API 版本管理\n## 第 8 章：项目规则与协作 ​\n\n这一章做什么？\n\n建立规范的项目管理流程，为团队协作做好准备。\n\n你将学到：\n\n- Git 工作流：分支策略、提交规范\n- 代码规范：ESLint、Prettier\n- 代码审查：Pull Request 流程\n- 项目结构：目录组织最佳实践\n## 第 9 章：测试与质量 ​\n\n这一章做什么？\n\n用自动化测试保证代码质量，减少 Bug。\n\n你将学到：\n\n- 为什么需要测试\n- 单元测试：测试单个函数/组件\n- 集成测试：测试多个模块协作\n- E2E 测试：测试完整用户流程\n- 测试覆盖率与持续集成\n## 第 10 章：部署与运维 ​\n\n这一章做什么？\n\n把你的应用部署到生产环境，并保持稳定运行。\n\n你将学到：\n\n- Vercel 部署：零配置上线\n- Docker 容器化：打包你的应用\n- CI/CD 流水线：自动化部署\n- 环境管理：开发/测试/生产环境\n- 监控与告警：发现问题、快速响应\n## 第 11 章：发布与复盘 ​\n\n这一章做什么？\n\n正式发布你的产品，收集反馈，持续迭代。\n\n你将学到：\n\n- 版本发布流程\n- 用户反馈收集\n- 数据分析入门\n- 迭代优化方法论\n- 复盘总结：从项目中学习\n## 第 12 章：高级专题 —— 进阶优化 ​\n\n这一章做什么？\n\n深入探索高级主题，让你的应用从\"能用\"变成\"好用\"。\n\n你将学到：\n\n- SEO 优化：让搜索引擎找到你\n- 性能优化：让应用更快\n- AI SDK 集成：在应用中使用 AI 能力\n- 实时通信：WebSocket 入门\n- 大文件处理：文件上传与下载\n- 国际化：支持多语言\n## 小结 ​\n\n进阶版不是要把你变成\"专业程序员\"。\n\n而是让你在 Vibe Coding 的基础上，掌握更多工具，解决更复杂的问题。\n\n你依然是\"指挥官\"，只是指挥的范围更大了。\n\n准备好开始了吗？\n\n👉 进阶篇入口（已下线，敬请期待）",
      "word_count": 2610,
      "estimated_time": 5
    },
    {
      "id": "lesson-173",
      "chapter_id": "chapter-99",
      "lesson_number": 1,
      "title": "A. Prompt 速查清单",
      "content": "# A. Prompt 速查清单 ​\n\n写 Prompt 时的快速参考。详细讲解见第三章：技法。\n\n## S.C.A.F.F. 框架速查 ​\n要素含义一句话提醒S - Situation背景情境你在做什么项目？用什么技术？C - Challenge具体挑战现在卡在哪里？要解决什么问题？A - Ask明确请求你希望 AI 做什么？输出什么？F - Format输出格式要代码？要解释？要列表？F - Filter限制条件什么不要做？有什么约束？\n## 常见场景要点 ​\n\n### 创建项目 ​\n\n- 说清楚：做什么、给谁用、核心功能（3个以内）\n- 先从最简单的版本开始\n### 修改代码 ​\n\n- 指明位置：哪个文件、哪个函数\n- 说清楚：现在是什么样、想改成什么样\n- 加一句：「只改这里，其他不动」\n### 修复报错 ​\n\n- 复制完整错误信息（比「报错了」有用100倍）\n- 说明：做什么操作时出的错\n### 解释代码 ​\n\n- 直接贴代码，问「这段代码在做什么」\n- 可以追问：「为什么要这样写」\n### 优化代码 ​\n\n- 说明优化目标：可读性？性能？减少重复？\n- 让 AI 解释改了什么\n## 提升效果的小技巧 ​\n技巧适用场景给 1-2 个示例AI 总是理解错你的意图时让 AI「想一想再回答」复杂逻辑、多步骤任务让 AI 自我检查生成的代码不太放心时分步骤提问一次问太多 AI 容易乱\n## 记住这一条 ​\n\nPrompt 的核心是「说清楚」，不是「套模板」。\n\n学会框架后，用自己的话表达就好。",
      "word_count": 658,
      "estimated_time": 3
    },
    {
      "id": "lesson-174",
      "chapter_id": "chapter-99",
      "lesson_number": 2,
      "title": "B.1 JavaScript 错误",
      "content": "# B.1 JavaScript 错误 ​\n\n遇到错误别慌！这一节列出了最常见的 JavaScript 错误，以及对应的解决方法。遇到问题时，直接查表就行。\n\n## undefined 错误 ​\n\n错误信息：\n\n`Uncaught TypeError: Cannot read properties of undefined (reading 'xxx')`通俗解释：你在试图使用一个「不存在」的东西。就像你问「小明的手机号」，但小明这个人不存在。\n\n常见原因：\n原因示例代码修复方法变量没有赋值`let user; console.log(user.name)`先检查变量是否有值数组越界`arr[10]` 但数组只有 3 个元素检查数组长度对象属性拼写错误`user.nmae`（应该是 `name`）检查属性名拼写函数没有返回值`function get() {}` 然后用返回值确保函数有 `return`\n快速修复 Prompt：\nmarkdown\n`我的代码报错：Cannot read properties of undefined (reading 'xxx')\n\n错误出现在这行：[粘贴报错的那行代码]\n\n请帮我分析原因并修复。`\n## null 错误 ​\n错误信息：\n\n`Uncaught TypeError: Cannot read properties of null (reading 'xxx')`通俗解释：你在试图使用一个「明确是空」的东西。就像一个空盒子，你却想从里面拿东西。\n\n常见原因：\n原因示例代码修复方法DOM 元素没找到`document.getElementById('btn')` 返回 null检查 ID 是否正确，或元素是否存在API 返回 null后端返回了 `null`添加空值判断LocalStorage 没数据`JSON.parse(localStorage.getItem('data'))`添加默认值：`\n快速修复 Prompt：\nmarkdown\n`我的代码报错：Cannot read properties of null\n\n我想获取页面上 ID 为 [xxx] 的元素，但返回了 null。\n\n请帮我检查可能的原因。`\n## TypeError ​\n错误信息：\n\n`Uncaught TypeError: xxx is not a function`通俗解释：你把一个不是函数的东西当函数用了。就像你对着一块石头说「给我唱首歌」。\n\n常见原因：\n原因示例代码修复方法变量名覆盖了函数名定义了 `let alert = 'hi'`，然后 `alert('hello')`避免用内置函数名作变量名方法名拼写错误`arr.pushs(1)`（应该是 `push`）检查方法名拼写调用了不存在的方法对数字调用字符串方法检查数据类型\n## ReferenceError ​\n\n错误信息：\n\n`Uncaught ReferenceError: xxx is not defined`通俗解释：你用了一个根本没有定义过的变量。就像你说「请把 xxx 递给我」，但屋子里根本没有这个东西。\n\n常见原因：\n原因示例代码修复方法变量名拼写错误`consle.log`（应该是 `console`）检查拼写变量作用域问题在函数外访问函数内的变量理解作用域，或把变量定义在外面忘记引入库使用了 jQuery 但没引入确保依赖已加载\n## SyntaxError ​\n\n错误信息：\n\n`Uncaught SyntaxError: Unexpected token 'xxx'`通俗解释：代码的「语法」写错了。就像中文里少了标点符号，句子读不通。\n\n常见原因：\n原因示例代码修复方法少了括号`if (x > 1 {`补上缺少的括号多了逗号`[1, 2, 3,]`（某些情况）删掉多余的逗号引号不匹配`'hello\"`使用配对的引号JSON 格式错误`{name: 'test'}` 应该是 `{\"name\": \"test\"}`JSON 的 key 必须用双引号\n语法错误的特点\n\n语法错误通常在代码运行前就会报错，而且浏览器会告诉你在哪一行。仔细看那一行和它的上一行，问题通常就在那附近。\n\n## 错误排查通用流程 ​\n\n记住：报错不可怕，复制粘贴给 AI 就行。",
      "word_count": 1802,
      "estimated_time": 3
    },
    {
      "id": "lesson-175",
      "chapter_id": "chapter-99",
      "lesson_number": 3,
      "title": "B.2 CSS/样式问题",
      "content": "# B.2 CSS/样式问题 ​\n\n样式问题不会报红色错误，但会让你的页面「长得不对」。这一节帮你快速定位和解决常见的样式问题。\n\n## 样式完全不生效 ​\n\n现象：你写了 CSS，但页面完全没变化。\n\n排查清单：\n检查项怎么检查解决方法CSS 文件没引入看 HTML 有没有 `<link>` 标签添加 `<link rel=\"stylesheet\" href=\"style.css\">`路径写错了检查文件路径是否正确确保 `href` 路径对应实际文件位置选择器写错了检查 class/id 名是否匹配`.btn`（class）vs `#btn`（id），别搞混被其他样式覆盖用浏览器开发者工具检查增加选择器权重或调整顺序缓存问题强制刷新页面Mac: `Cmd+Shift+R`，Win: `Ctrl+Shift+R`\n快速修复 Prompt：\nmarkdown\n`我的 CSS 样式没有生效。\n\nHTML 代码：\n[粘贴相关 HTML]\n\nCSS 代码：\n[粘贴 CSS]\n\n请帮我检查为什么样式没生效。`\n## 布局错乱 ​\n现象：元素的位置不对，挤在一起、跑偏了、或者溢出了。\n\n常见问题与解决：\n\n### 元素挤在一起 ​\ncss\n`/* 问题：多个元素挤成一行 */\n/* 解决：让它们换行显示 */\n.container {\n  display: flex;\n  flex-wrap: wrap;  /* 允许换行 */\n  gap: 10px;        /* 添加间距 */\n}`\n### 元素跑到屏幕外 ​\ncss\n```\n/* 问题：内容超出容器 */\n/* 解决：限制宽度，允许滚动或隐藏 */\n.content {\n  max-width: 100%;    /* 不超过父容器 */\n  overflow: auto;     /* 超出时显示滚动条 */\n}\n```\n\n### 垂直居中不生效 ​\ncss\n```\n/* 最简单的垂直居中方法 */\n.parent {\n  display: flex;\n  justify-content: center;  /* 水平居中 */\n  align-items: center;      /* 垂直居中 */\n  height: 100vh;            /* 父容器要有高度！ */\n}\n```\n常见坑\n\n垂直居中不生效，90% 是因为父容器没有设置高度。`height: 100%` 或 `height: 100vh` 是常用的解决方案。\n\n## 响应式问题 ​\n\n现象：在电脑上好好的，手机上就乱了。\n\n快速检查：\n\n- 有没有加 viewport meta 标签？\n- 有没有用百分比/rem 而不是固定 px？\n- 有没有写媒体查询？\n基础响应式模板：\nhtml\n`<!-- 必须在 <head> 里加这行 -->\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">`css\n```\n/* 基础样式（手机优先） */\n.container {\n  width: 100%;\n  padding: 15px;\n}\n\n/* 平板及以上 */\n@media (min-width: 768px) {\n  .container {\n    width: 750px;\n    margin: 0 auto;\n  }\n}\n\n/* 电脑 */\n@media (min-width: 1024px) {\n  .container {\n    width: 960px;\n  }\n}\n```\n\n## 常见样式问题速查表 ​\n问题可能原因快速解决字体大小不对继承了父元素的样式明确设置 `font-size`颜色不对选择器权重不够检查是否被覆盖，提高权重边距不对margin 和 padding 搞混margin 是外边距，padding 是内边距图片变形宽高比被破坏使用 `object-fit: cover`按钮点不到被其他元素遮挡检查 `z-index` 和定位文字溢出容器太小使用 `overflow: hidden` 或 `text-overflow: ellipsis`\n## 用浏览器调试样式 ​\n这是解决样式问题最有效的方法：\n\n- 打开开发者工具：右键页面 → 检查（或按 F12）\n- 选中元素：点击左上角的「选择」图标，然后点击页面上的元素\n- 查看样式：右侧会显示这个元素的所有样式\n- 实时修改：直接在右侧修改 CSS 值，页面会实时更新\n- 找到问题：看哪些样式被划掉了（说明被覆盖了）\n小技巧\n\n在开发者工具里调好样式后，把修改后的 CSS 复制回你的代码文件。这样比盲改快多了。",
      "word_count": 1993,
      "estimated_time": 3
    },
    {
      "id": "lesson-176",
      "chapter_id": "chapter-99",
      "lesson_number": 4,
      "title": "B.3 交互问题",
      "content": "# B.3 交互问题 ​\n\n页面能显示，但点击、输入等交互没反应？这一节帮你解决最常见的交互问题。\n\n## 按钮无反应 ​\n\n现象：点击按钮后，什么都没发生。\n\n排查清单：\n检查项怎么检查解决方法事件没绑定检查 HTML 中的 `onclick` 或 JS 中的 `addEventListener`确保事件处理函数正确绑定函数名写错检查 `onclick=\"xxx()\"` 中的函数名确保和 JS 中定义的函数名一致JS 文件没加载看控制台有没有 404 错误检查 `<script>` 标签路径JS 有语法错误看控制台有没有红色错误修复语法错误后，后面的代码才会执行被其他元素遮挡检查按钮上方有没有透明元素调整 `z-index` 或移除遮挡元素\n快速修复 Prompt：\nmarkdown\n`我的按钮点击没反应。\n\nHTML 按钮代码：\n[粘贴按钮代码]\n\nJS 函数代码：\n[粘贴对应的 JS 代码]\n\n控制台错误信息（如果有）：\n[粘贴错误信息]\n\n请帮我排查原因。`\n## 表单提交失败 ​\n现象：填完表单点提交，页面刷新了但数据没处理。\n\n常见原因与解决：\n\n### 页面刷新问题 ​\njavascript\n`// 问题：表单提交后页面刷新了\n// 解决：阻止默认行为\nform.addEventListener('submit', function(e) {\n  e.preventDefault();  // 阻止默认的表单提交\n  // 然后在这里处理数据\n});`\n### 获取不到输入值 ​\njavascript\n```\n// 问题：获取的值是空的\n// 检查 1：选择器是否正确\nconst input = document.getElementById('username');  // ID 要对应\n\n// 检查 2：获取值的方式\nconst value = input.value;  // 注意是 .value 不是 .innerText\n\n// 检查 3：获取时机是否正确（要在用户输入后获取）\n```\n\n### 数据格式问题 ​\njavascript\n```\n// 问题：数字被当成字符串\nconst age = document.getElementById('age').value;  // \"25\"（字符串）\nconst ageNumber = parseInt(age);  // 25（数字）\n\n// 或者用 Number()\nconst ageNumber2 = Number(age);\n```\n\n## 数据不显示 ​\n现象：数据存了，但页面上看不到。\n\n排查步骤：\n\n常见修复代码：\njavascript\n`// 检查数据是否存在\nconst data = localStorage.getItem('quotes');\nconsole.log('存储的数据:', data);  // 用 console.log 检查\n\n// 确保解析正确\nconst quotes = JSON.parse(data) || [];\nconsole.log('解析后的数组:', quotes);\n\n// 确保渲染到正确位置\nconst container = document.getElementById('list');\nif (container) {\n  container.innerHTML = quotes.map(q => `<p>${q}</p>`).join('');\n} else {\n  console.log('找不到容器元素！');\n}`\n## 数据存了但刷新后没了 ​\n现象：数据操作成功了，但刷新页面后数据消失。\n\n排查清单：\n可能原因检查方法解决方法没有持久化存储检查有没有用 LocalStorage数据变化时保存到 LocalStorage存储时机不对检查保存代码是否执行在数据变化后立即保存加载时机不对检查页面加载时是否读取数据在页面加载时从 LocalStorage 读取存储格式问题检查存储的数据格式用 JSON.stringify 存，JSON.parse 取\n完整的存取示例：\njavascript\n`// 保存数据\nfunction saveQuotes(quotes) {\n  localStorage.setItem('quotes', JSON.stringify(quotes));\n}\n\n// 读取数据\nfunction loadQuotes() {\n  const data = localStorage.getItem('quotes');\n  return data ? JSON.parse(data) : [];\n}\n\n// 页面加载时读取\ndocument.addEventListener('DOMContentLoaded', function() {\n  const quotes = loadQuotes();\n  renderQuotes(quotes);\n});\n\n// 添加新数据时保存\nfunction addQuote(newQuote) {\n  const quotes = loadQuotes();\n  quotes.push(newQuote);\n  saveQuotes(quotes);  // 别忘了保存！\n  renderQuotes(quotes);\n}`\n## 交互问题通用排查口诀 ​\n看控制台 → 加 console.log → 检查时机 → 问 AI\n\n- 看控制台：有红色错误吗？\n- 加 console.log：代码执行到哪一步了？数据是什么？\n- 检查时机：代码是在正确的时间执行吗？\n- 问 AI：把相关代码和现象描述清楚",
      "word_count": 2396,
      "estimated_time": 4
    },
    {
      "id": "lesson-177",
      "chapter_id": "chapter-99",
      "lesson_number": 5,
      "title": "B.4 工具问题",
      "content": "# B.4 工具问题 ​\n\n这一节解决你在使用 AI 编程工具时可能遇到的问题。\n\n## AI 不理解我的需求 ​\n\n现象：AI 给的代码完全不是你想要的。\n\n可能原因与解决：\n原因解决方法描述太模糊增加具体细节，比如尺寸、颜色、位置需求太复杂拆分成多个小需求，一步一步来缺少上下文告诉 AI 你已有的代码结构、用的技术栈术语不准确换个说法，或者用截图/示例网站描述\n示例对比：\nmarkdown\n`❌ 不好的描述：\n做一个好看的页面\n\n✅ 好的描述：\n做一个产品展示页面。\n- 顶部是大标题\"智能记账本\"，白色字，蓝色背景\n- 下面是 3 个功能介绍卡片，横向排列\n- 每个卡片有图标、标题、一句话描述\n- 底部有一个\"立即下载\"按钮\n- 整体风格简洁现代`\n## AI 生成的代码无法运行 ​\n现象：复制 AI 的代码后，页面报错或空白。\n\n排查清单：\n检查项解决方法代码不完整让 AI 「请给出完整代码」缺少依赖询问需要引入什么库或框架代码需要在特定环境运行确认是浏览器代码还是 Node.js 代码文件结构不对让 AI 说明代码应该放在哪个文件复制粘贴出错检查是否漏复制了什么\n快速修复 Prompt：\nmarkdown\n`你给的代码运行后出错了。\n\n错误信息：\n[粘贴错误信息]\n\n请帮我修复，并给出完整的可运行代码。`\n## 部署失败 ​\n现象：本地能跑，但部署到 Vercel/Netlify 后打不开。\n\n常见原因与解决：\n错误类型可能原因解决方法Build failed代码有语法错误查看部署日志，修复错误404 Not Found文件路径问题检查文件名大小写、路径是否正确页面空白JS 报错打开浏览器控制台查看错误样式丢失CSS 路径问题使用相对路径，确保文件已上传API 不工作环境变量没配置在部署平台配置环境变量\n部署前检查清单：\n\n- [ ] 所有文件都已保存\n- [ ] 本地测试运行正常\n- [ ] 文件名没有使用中文和特殊字符\n- [ ] 路径使用相对路径（`./` 或 `../`）\n- [ ] 入口文件是 `index.html`\n## AI 反复给同样的错误答案 ​\n\n现象：反复问 AI，它一直给同样的（错误的）代码。\n\n解决策略：\n\n### 策略 1：换个问法 ​\nmarkdown\n`之前：请帮我实现一个轮播图\n\n之后：请用原生 JavaScript 实现一个图片轮播组件，要求：\n- 每 3 秒自动切换到下一张\n- 底部有小圆点指示当前图片\n- 点击圆点可以跳转到对应图片`\n### 策略 2：明确排除 ​\nmarkdown\n```\n请帮我实现 xxx，但是不要使用 [之前失败的方案]。\n```\n\n### 策略 3：提供更多信息 ​\nmarkdown\n```\n我按你说的做了，但还是报错。具体情况：\n- 我的代码：[粘贴]\n- 报错信息：[粘贴]\n- 我的操作步骤：[描述]\n```\n\n### 策略 4：换一个 AI 工具 ​\n不同的 AI 工具可能有不同的「知识盲区」。如果一个工具反复不行，换一个试试。\n\n## 网络/登录问题 ​\n问题解决方法页面加载慢检查网络，尝试科学上网登录不上清除浏览器缓存，重新登录聊天没响应刷新页面，或稍等几分钟消息发不出去检查是否超出使用限制\n## 工具问题通用解决思路 ​\n\n记住：工具是为你服务的，不是为难你的。 换个姿势再试试！",
      "word_count": 1408,
      "estimated_time": 3
    },
    {
      "id": "lesson-178",
      "chapter_id": "chapter-99",
      "lesson_number": 6,
      "title": "C.1 AI 编程相关",
      "content": "# C.1 AI 编程相关 ​\n\n遇到不认识的词？来这里查。每个术语都用最通俗的话解释。\n\n## Vibe Coding ​\n\n一句话解释：不写代码，用自然语言告诉 AI 你想要什么，让 AI 帮你生成代码。\n\n类比：就像你告诉装修师傅「我想要一个温馨的客厅」，而不是自己去搬砖砌墙。\n\n例子：\n\n- 你说：「做一个显示今日名言的网页，蓝色背景，白色大字」\n- AI：输出完整的 HTML/CSS/JS 代码\n## Spec Coding ​\n\n一句话解释：先写好详细的规范文档，再让 AI 按规范生成代码。\n\n类比：就像盖房子前先画好图纸，每个房间多大、门窗在哪都写清楚。\n\n和 Vibe Coding 的区别：\nVibe CodingSpec Coding文档不需要需要详细文档适合简单项目、快速验证复杂项目、团队协作特点快、灵活稳、可维护\n## Prompt ​\n\n一句话解释：你给 AI 的指令或问题。\n\n类比：就像你给外卖小哥的备注：「少盐少油，多放辣」。Prompt 写得越清楚，AI 做出来的东西越符合你的预期。\n\n好 Prompt 的特点：\n\n- 说清楚要什么（目标）\n- 说清楚给谁用（用户）\n- 说清楚不要什么（限制）\n## Context（上下文） ​\n\n一句话解释：AI 理解你需求所需要的背景信息。\n\n类比：就像医生看病需要知道你的病史。你告诉 AI 越多背景信息，它就越能给出准确的答案。\n\nContext 包括什么：\n\n- 你之前说过的话\n- 你提供的代码\n- 你描述的项目背景\n- 你使用的技术栈\n## Context Window（上下文窗口） ​\n\n一句话解释：AI 一次能「记住」的信息量上限。\n\n类比：就像人的短期记忆容量。聊得太长，AI 会「忘记」最开始说的内容。\n\n实际影响：\n\n- 对话太长时，可能需要重新说明背景\n- 一次给太多代码，AI 可能处理不过来\n- 不同的 AI 工具，窗口大小不同\n## Hallucination（幻觉） ​\n\n一句话解释：AI 一本正经地胡说八道，编造不存在的信息。\n\n类比：就像一个太想帮忙的朋友，不知道答案也要硬编一个。\n\n常见表现：\n\n- 编造不存在的库或函数名\n- 给出「看起来对但实际不能运行」的代码\n- 引用不存在的文档或链接\n如何应对：\n\n- 对 AI 的输出保持怀疑，重要信息要验证\n- 让 AI 解释它的代码，检查逻辑是否说得通\n- 直接运行代码看看能不能跑\n## Agent（智能体） ​\n\n一句话解释：能自主完成多步骤任务的 AI 系统。\n\n类比：普通 AI 像计算器（你问一句答一句），Agent 像助理（你给个任务，它自己规划步骤完成）。\n\n例子：\n\n- 你说：「帮我做一个待办清单应用」\n- Agent：自己分析需求 → 设计结构 → 写代码 → 测试 → 修复问题\n## MCP（Model Context Protocol） ​\n\n一句话解释：让 AI 能连接外部工具和数据的标准协议。\n\n类比：就像 USB 接口标准。有了统一标准，AI 就能方便地「插上」各种工具使用。\n\n实际用途：\n\n- 让 AI 能读写本地文件\n- 让 AI 能访问数据库\n- 让 AI 能调用 API\n## Token ​\n\n一句话解释：AI 处理文本的基本单位，大约等于一个单词或几个汉字。\n\n类比：就像话费的「分钟」。你和 AI 聊天消耗的是 Token，用完了要充值。\n\n关于费用：\n\n- 大多数工具按 Token 收费\n- 输入和输出都消耗 Token\n- 汉字通常比英文消耗更多 Token\n省 Token 的小技巧：\n\n- 描述尽量简洁但不模糊\n- 不要重复已经说过的信息\n- 一次对话解决一个问题",
      "word_count": 1549,
      "estimated_time": 3
    },
    {
      "id": "lesson-179",
      "chapter_id": "chapter-99",
      "lesson_number": 7,
      "title": "C.2 开发相关",
      "content": "# C.2 开发相关 ​\n\n这些是软件开发中常用的术语。不需要深入理解，知道大概意思就行。\n\n## MVP ​\n\n全称：Minimum Viable Product（最小可行产品）\n\n一句话解释：能用的最简版本，只包含最核心的功能。\n\n类比：先做一个能骑的自行车，而不是一上来就想造特斯拉。\n\n为什么重要：\n\n- 快速验证想法是否可行\n- 及早发现问题\n- 避免在没人要的功能上浪费时间\n## PRD ​\n\n全称：Product Requirement Document（产品需求文档）\n\n一句话解释：描述产品「做什么」的文档。\n\n通常包括：\n\n- 产品目标\n- 用户是谁\n- 核心功能\n- 不包含什么\n对 AI 编程的价值： 有了 PRD，AI 能更准确地理解你的需求，生成的代码更符合预期。\n\n## Debug ​\n\n一句话解释：找出并修复代码中的错误。\n\n类比：就像找出灯泡不亮的原因——是灯泡坏了？还是开关没开？还是停电了？\n\n常见 Debug 方法：\n\n- 看错误信息\n- 加 `console.log` 打印变量值\n- 一行一行检查代码\n- 问 AI\n## Deploy（部署） ​\n\n一句话解释：把你做的东西放到网上，让别人能访问。\n\n类比：就像把你写的书从手稿变成上架销售的实体书。\n\n常用部署平台：\n\n- Vercel\n- Netlify\n- GitHub Pages\n## Git ​\n\n一句话解释：代码版本管理工具，可以记录每次修改，随时回退。\n\n类比：就像游戏的存档功能。做错了可以读档回到之前的状态。\n\n核心概念：\n概念解释Repository（仓库）存放项目的地方Commit（提交）保存一次修改记录Branch（分支）代码的平行版本Push（推送）把本地代码上传到云端Pull（拉取）把云端代码下载到本地\n## GitHub ​\n\n一句话解释：最大的代码托管平台，基于 Git。\n\n类比：就像「代码界的百度网盘」，你的代码存在云端，随时随地可以访问。\n\n常见用途：\n\n- 存储和备份代码\n- 和别人协作开发\n- 展示你的项目\n- 找开源项目学习\n## API ​\n\n全称：Application Programming Interface（应用程序接口）\n\n一句话解释：程序之间交流的「暗号」。\n\n类比：就像餐厅的菜单。你按照菜单点菜（发请求），厨房就给你做（返回结果）。你不需要知道厨房怎么做的。\n\n例子：\n\n- 天气 API：你发请求「北京天气」，它返回「晴，25°C」\n- 地图 API：你发请求「从 A 到 B」，它返回路线\n## 框架 ​\n\n一句话解释：别人写好的代码骨架，你在上面填东西就行。\n\n类比：就像搭积木。框架给你提供基础结构，你只需要往里面放内容。\n\n常见框架：\n框架用途React / Vue做网页界面Next.js做完整网站Express做后端服务\n## 前端 vs 后端 ​\n前端后端是什么用户看得见的部分用户看不见的部分类比餐厅的装修和菜单厨房和仓库负责界面、交互、动画数据处理、存储、逻辑技术HTML/CSS/JSNode.js/Python/数据库\n## 全栈 ​\n\n一句话解释：前端后端都会。\n\n类比：既能设计餐厅装修，也能在厨房做菜。\n\n在 AI 时代： 借助 AI，普通人也能做出「全栈」应用——因为 AI 可以帮你处理你不擅长的部分。",
      "word_count": 1403,
      "estimated_time": 3
    },
    {
      "id": "lesson-180",
      "chapter_id": "chapter-99",
      "lesson_number": 8,
      "title": "C.3 技术相关",
      "content": "# C.3 技术相关 ​\n\n这些是做网页/应用时会遇到的技术术语。\n\n## HTML ​\n\n全称：HyperText Markup Language（超文本标记语言）\n\n一句话解释：定义网页「有什么内容」。\n\n类比：就像房子的结构——哪里是客厅、哪里是卧室、哪里是厨房。\n\n长什么样：\nhtml\n`<h1>这是标题</h1>\n<p>这是一段文字</p>\n<button>这是按钮</button>`\n## CSS ​\n全称：Cascading Style Sheets（层叠样式表）\n\n一句话解释：定义网页「长什么样」。\n\n类比：就像房子的装修——墙壁什么颜色、沙发多大、灯放在哪。\n\n长什么样：\ncss\n`h1 {\n  color: blue;      /* 字体颜色 */\n  font-size: 24px;  /* 字体大小 */\n}`\n## JavaScript ​\n简称：JS\n\n一句话解释：让网页「能动」，有交互。\n\n类比：就像房子里的电器和开关——点开关灯会亮，按按钮电视会开。\n\n长什么样：\njavascript\n`// 点击按钮后弹出提示\nbutton.onclick = function() {\n  alert('你点击了按钮！');\n}`\n## HTML + CSS + JS 的关系 ​\n技术负责类比HTML内容结构房子的框架CSS外观样式房子的装修JavaScript行为交互房子的电器\n## LocalStorage ​\n一句话解释：浏览器提供的本地存储空间，数据保存在用户电脑上。\n\n类比：就像你房间里的抽屉，东西放进去，关了门下次开门还在。\n\n特点：\n\n- 只存在用户自己的浏览器里\n- 刷新页面、关闭浏览器数据都还在\n- 换个浏览器或电脑数据就没了\n- 适合存简单的用户偏好、记录等\n使用示例：\njavascript\n`// 存数据\nlocalStorage.setItem('name', '小明');\n\n// 取数据\nconst name = localStorage.getItem('name');  // '小明'\n\n// 删数据\nlocalStorage.removeItem('name');`\n## JSON ​\n全称：JavaScript Object Notation\n\n一句话解释：一种数据格式，用来存储和传输数据。\n\n类比：就像一种通用的「表格格式」，大家都能看懂。\n\n长什么样：\njson\n`{\n  \"name\": \"小明\",\n  \"age\": 25,\n  \"hobbies\": [\"读书\", \"跑步\", \"编程\"]\n}`常见用途：\n\n- API 返回的数据\n- 配置文件\n- LocalStorage 存储复杂数据\n## 环境变量 ​\n\n一句话解释：存放敏感信息（如密钥、密码）的地方，不会被写进代码里。\n\n类比：就像保险箱。密码放在保险箱里，而不是贴在门上。\n\n为什么重要：\n\n- 密钥写在代码里，一旦代码公开，密钥就泄露了\n- 环境变量不会被上传到 GitHub\n- 是安全的最佳实践\n通常的用法：\n\n- 创建 `.env` 文件存放敏感信息\n- 代码中通过 `process.env.XXX` 读取\n- `.env` 文件加入 `.gitignore`，不上传\n## 域名 ​\n\n一句话解释：网站的地址，让人能找到你的网站。\n\n类比：就像你家的门牌号。有了地址，别人才能找到你家。\n\n结构：\n\n`https://www.example.com/about\n  │       │      │      │\n协议    子域名  主域名  路径`获取域名：\n\n- 去域名注册商（如阿里云、腾讯云）购买\n- 连接到你的部署平台\n## 响应式设计 ​\n\n一句话解释：让网页在不同尺寸的屏幕上都能正常显示。\n\n类比：就像水，能适应不同形状的容器。\n\n实现方式：\n\n- 使用百分比而不是固定像素\n- 使用媒体查询针对不同屏幕写样式\n- 使用 Flexbox/Grid 布局\n为什么重要： 现在人们用手机、平板、电脑访问网站，响应式设计让所有用户都有好的体验。",
      "word_count": 1712,
      "estimated_time": 3
    },
    {
      "id": "lesson-181",
      "chapter_id": "chapter-99",
      "lesson_number": 9,
      "title": "D.1 对话式 AI 对比",
      "content": "# D.1 对话式 AI 对比 ​\n\n对话式 AI 是最简单的 AI 编程方式：直接对话，让 AI 帮你写代码。以下是主流工具的对比。\n\n## 综合对比表 ​\n工具公司中文支持免费额度代码能力适合人群ChatGPTOpenAI良好有限制优秀通用场景ClaudeAnthropic优秀有限制优秀长文本/复杂任务GeminiGoogle良好较多良好Google 生态用户Kimi月之暗面原生较多良好国内用户DeepSeekDeepSeek原生免费优秀性价比首选豆包字节跳动原生免费良好国内新手\n## 各工具详解 ​\n\n### ChatGPT ​\n\n官网：chat.openai.com\n\n特点：\n\n- AI 对话的「开山鼻祖」，生态最丰富\n- GPT-4 代码能力非常强\n- 插件和 GPTs 扩展功能多\n限制：\n\n- 需要科学上网\n- 免费版功能受限\n适合：想体验最成熟 AI 能力的用户\n\n### Claude ​\n\n官网：claude.ai\n\n特点：\n\n- 超长上下文窗口（可处理很长的代码）\n- 推理能力强，适合复杂任务\n- 中文理解能力优秀\n- 更不容易产生幻觉\n限制：\n\n- 需要科学上网\n- 免费版有对话次数限制\n适合：处理长代码、复杂逻辑的用户\n\n### Gemini ​\n\n官网：gemini.google.com\n\n特点：\n\n- Google 出品，与 Google 服务整合好\n- 多模态能力强（可以理解图片）\n- 免费额度较多\n限制：\n\n- 需要科学上网\n- 代码能力略逊于 GPT-4 和 Claude\n适合：使用 Google 生态的用户\n\n### Kimi ​\n\n官网：kimi.moonshot.cn\n\n特点：\n\n- 国内可直接访问\n- 超长上下文支持\n- 中文理解优秀\n- 可以读取文件和网页\n限制：\n\n- 代码能力相对弱一些\n- 有使用次数限制\n适合：国内用户的入门首选\n\n### DeepSeek ​\n\n官网：chat.deepseek.com\n\n特点：\n\n- 国内可直接访问\n- 代码能力非常强（DeepSeek Coder）\n- 完全免费使用\n- 性价比极高\n限制：\n\n- 知名度相对较低\n- 生态不如 ChatGPT 丰富\n适合：想要高质量免费工具的用户，强烈推荐\n\n### 豆包 ​\n\n官网：www.doubao.com\n\n特点：\n\n- 字节跳动出品\n- 国内可直接访问\n- 界面友好，上手简单\n- 免费使用\n限制：\n\n- 代码能力一般\n- 更适合日常对话\n适合：国内完全零基础的新手\n\n## 选择建议 ​\n\n## 快速推荐 ​\n你的情况推荐工具国内用户，想写代码DeepSeek国内用户，入门体验Kimi能科学上网，追求最强Claude / ChatGPT能科学上网，想免费用Gemini\n建议\n\n不用纠结选哪个，先用起来最重要。等你熟悉了，再根据需要切换工具。",
      "word_count": 1203,
      "estimated_time": 3
    },
    {
      "id": "lesson-182",
      "chapter_id": "chapter-99",
      "lesson_number": 10,
      "title": "D.2 IDE 集成式对比",
      "content": "# D.2 IDE 集成式对比 ​\n\nIDE 集成式工具把 AI 能力直接嵌入代码编辑器，可以在写代码的同时获得 AI 帮助。更适合有一定基础、想深入学习的用户。\n\n## 综合对比表 ​\n工具基于价格特点适合人群CursorVS Code$20/月最强 AI IDE想深度使用 AI 的开发者GitHub CopilotVS Code 插件$10/月代码补全王者已有 VS Code 经验WindsurfVS Code免费版可用轻量好用想免费体验的用户ClineVS Code 插件按 API 付费开源灵活喜欢自定义的用户Trae独立 IDE免费字节出品国内用户KiroVS Code免费亚马逊出品，Spec 驱动想体验 Spec Coding\n## 各工具详解 ​\n\n### Cursor ​\n\n官网：cursor.com\n\n是什么：基于 VS Code 的 AI 原生 IDE，被称为「AI 编程的未来」。\n\n核心功能：\n\n- Tab 补全：按 Tab 接受 AI 的代码建议\n- Cmd+K：选中代码后，告诉 AI 怎么改\n- Chat：在侧边栏和 AI 对话\n- Composer：让 AI 同时编辑多个文件\n价格：\n\n- 免费版：有限次数\n- Pro：$20/月\n优点：\n\n- AI 集成最深\n- 功能最全面\n- 社区活跃\n缺点：\n\n- 付费才能充分体验\n- 新手可能有点复杂\n### GitHub Copilot ​\n\n官网：github.com/features/copilot\n\n是什么：GitHub 推出的 AI 编程助手，作为 VS Code 插件使用。\n\n核心功能：\n\n- 代码补全：写代码时自动给建议\n- Chat：在 VS Code 里和 AI 对话\n- 解释代码：选中代码让 AI 解释\n价格：\n\n- 个人：$10/月\n- 学生：免费\n优点：\n\n- 代码补全体验丝滑\n- 和 GitHub 生态无缝整合\n- 学生可以免费用\n缺点：\n\n- 只是插件，功能相对简单\n- 需要科学上网\n### Windsurf ​\n\n官网：codeium.com/windsurf\n\n是什么：Codeium 推出的 AI IDE，主打免费好用。\n\n核心功能：\n\n- 类似 Cursor 的 AI 对话\n- 代码补全\n- Agent 模式（自动执行多步操作）\n价格：\n\n- 基础功能免费\n- Pro 版付费\n优点：\n\n- 免费版就很能用\n- 轻量流畅\n- 学习成本低\n缺点：\n\n- 功能不如 Cursor 全面\n- 社区相对小\n### Cline ​\n\n官网：github.com/cline/cline\n\n是什么：开源的 VS Code AI 插件，可以用自己的 API Key。\n\n核心功能：\n\n- 在 VS Code 中和 AI 对话\n- 可以选择不同的 AI 模型\n- Agent 模式\n价格：\n\n- 软件免费\n- 按 API 调用付费\n优点：\n\n- 开源透明\n- 可以用便宜的模型\n- 高度可定制\n缺点：\n\n- 需要自己配置 API Key\n- 不适合完全新手\n### Trae ​\n\n官网：trae.ai\n\n是什么：字节跳动推出的 AI IDE，国内可直接使用。\n\n核心功能：\n\n- AI 对话和代码生成\n- 代码补全\n- 项目理解\n价格：免费\n\n优点：\n\n- 国内可用\n- 完全免费\n- 中文支持好\n缺点：\n\n- 功能在快速迭代中\n- 生态还在建设\n### Kiro ​\n\n官网：kiro.dev\n\n是什么：亚马逊推出的 Spec 驱动 AI IDE。\n\n核心功能：\n\n- Spec 模式：先写需求文档，再生成代码\n- 自动生成 requirements.md、design.md、tasks.md\n- 按任务清单逐步开发\n价格：免费预览中\n\n优点：\n\n- 体验 Spec Coding 的好选择\n- 适合复杂项目\n- 文档和代码结合\n缺点：\n\n- 还在早期阶段\n- 学习曲线较陡\n## 选择建议 ​\n你的情况推荐工具零基础，想先试试Windsurf（免费）有 VS Code 经验GitHub Copilot想深度使用 AICursor国内用户Trae想体验 Spec CodingKiro喜欢折腾Cline\n提醒\n\n这些工具需要一定的编程基础才能充分发挥作用。如果你是完全零基础，建议先用对话式 AI 或专用 AI IDE（下一节）。",
      "word_count": 1828,
      "estimated_time": 3
    },
    {
      "id": "lesson-183",
      "chapter_id": "chapter-99",
      "lesson_number": 11,
      "title": "D.3 专用 AI IDE 对比",
      "content": "# D.3 专用 AI IDE 对比 ​\n\n专用 AI IDE 是为「不懂代码的人」设计的。在网页上描述你想要什么，AI 直接给你做出来。这是零基础最友好的方式。\n\n## 综合对比表 ​\n工具特点价格优势适合Bolt.new全栈应用生成免费版可用功能最全面想做完整应用豆包 AI 编程代码生成+预览免费国内访问流畅国内用户首选v0.devUI 组件生成免费版可用UI 设计感强想做漂亮界面Lovable产品原型免费版可用上手简单快速验证想法Replit Agent在线 IDE + AI免费版可用一站式体验想学编程的新手\n## 各工具详解 ​\n\n### Bolt.new ​\n\n官网：bolt.new\n\n是什么：StackBlitz 推出的 AI 全栈开发平台，可以用自然语言做出完整应用。\n\n核心功能：\n\n- 描述需求，生成完整项目\n- 支持前端 + 后端 + 数据库\n- 实时预览效果\n- 一键部署\n价格：\n\n- 免费版：有使用限制\n- 付费版：$20/月起\n优点：\n\n- 能做的东西最复杂\n- 生成的代码质量高\n- 可以继续迭代修改\n缺点：\n\n- 免费额度较少\n- 国内访问较慢，需要科学上网\n- 复杂需求有时需要多轮调整\n适合：想做完整应用的用户（海外或有科学上网条件的用户）\n\n### 豆包 AI 编程 ​\n\n官网：doubao.com/chat/coding\n\n是什么：字节跳动推出的 AI 编程助手，支持代码生成和实时预览，是国内用户的理想选择。\n\n核心功能：\n\n- 自然语言描述需求，生成代码\n- HTML/CSS/JavaScript 实时预览\n- 代码解释、修复和优化\n- 支持上传代码文件或引入 GitHub 项目\n价格：\n\n- 免费使用\n优点：\n\n- 国内访问流畅，无需科学上网\n- 界面简洁，上手容易\n- 支持中文交互，理解更准确\n- 免费无限制\n缺点：\n\n- 功能相比 Bolt.new 略简单\n- 部署功能不如 Bolt.new 完善\n适合：国内用户、想快速体验 AI 编程的初学者\n\n### v0.dev ​\n\n官网：v0.dev\n\n是什么：Vercel 推出的 AI UI 生成工具，专注于做漂亮的界面。\n\n核心功能：\n\n- 描述需求，生成 UI 组件\n- 基于 React + Tailwind CSS\n- 可以直接复制代码\n- 支持迭代修改\n价格：\n\n- 免费版：每月有限次数\n- Pro：$20/月\n优点：\n\n- UI 设计感非常好\n- 生成的组件可以直接用\n- 和 Vercel 部署无缝对接\n缺点：\n\n- 只能做 UI，不能做后端逻辑\n- 需要了解 React 才能充分利用\n适合：想快速做出漂亮界面的用户\n\n### Lovable ​\n\n官网：lovable.dev\n\n是什么：专注于帮你快速做出产品原型的 AI 工具。\n\n核心功能：\n\n- 自然语言生成应用\n- 简洁直观的界面\n- 支持实时预览\n- 可以部署分享\n价格：\n\n- 免费版可用\n- 付费版功能更多\n优点：\n\n- 上手最简单\n- 非常适合验证想法\n- 界面友好\n缺点：\n\n- 功能相对简单\n- 复杂应用可能力不从心\n适合：想快速验证想法的用户\n\n### Replit Agent ​\n\n官网：replit.com\n\n是什么：Replit 是在线 IDE，Agent 是其 AI 助手，可以帮你从零做出应用。\n\n核心功能：\n\n- 在线编写和运行代码\n- AI 帮你生成代码\n- 支持多种编程语言\n- 可以直接部署\n价格：\n\n- 免费版：基础功能\n- Replit Core：$20/月\n优点：\n\n- 一站式体验（写代码 + 运行 + 部署）\n- 学习编程的好地方\n- 社区活跃，有很多模板\n缺点：\n\n- AI 能力不如专门的 AI 工具\n- 免费版有资源限制\n适合：想在学习编程的同时使用 AI 的用户\n\n## 选择建议 ​\n情况推荐工具国内用户，想快速上手豆包 AI 编程做一个完整的小应用Bolt.new做漂亮的网页界面v0.dev快速验证一个想法Lovable边学编程边做东西Replit\n## 本教程推荐 ​\n\n国内用户推荐从豆包 AI 编程开始，访问流畅、免费、支持实时预览。\n\n海外或有科学上网条件的用户推荐 Bolt.new，功能最全面。\n\n选择理由：\n\n- 功能全面，能做出「有用」的东西\n- 不需要任何编程知识\n- 界面直观，上手简单\n- 生成的代码质量不错，以后想学代码也有参考\n记住\n\n工具只是工具。重要的是你想做什么、解决什么问题。选一个顺手的，先用起来！",
      "word_count": 1893,
      "estimated_time": 3
    },
    {
      "id": "lesson-184",
      "chapter_id": "chapter-99",
      "lesson_number": 12,
      "title": "D.4 部署平台对比",
      "content": "# D.4 部署平台对比 ​\n\n做好的东西要放到网上让别人能访问，这就是「部署」。以下是主流免费部署平台的对比。\n\n## 综合对比表 ​\n平台免费额度上手难度适合场景特色Vercel慷慨简单前端/全栈最流行，和 Next.js 完美配合Netlify慷慨简单静态网站功能丰富，表单功能好用GitHub Pages免费简单静态网站完全免费，和 GitHub 绑定Railway有限中等后端服务适合有后端的应用Cloudflare Pages慷慨简单静态网站全球 CDN，速度快\n## 各平台详解 ​\n\n### Vercel ​\n\n官网：vercel.com\n\n简介：最流行的前端部署平台，Next.js 的官方部署平台。\n\n免费额度：\n\n- 无限静态网站\n- 每月 100GB 流量\n- Serverless 函数有限制\n优点：\n\n- 部署超级简单（连接 GitHub 后自动部署）\n- 预览功能好用（每个 PR 都有预览链接）\n- 和 Next.js 无缝配合\n- 全球 CDN，访问快\n缺点：\n\n- Serverless 函数有执行时间限制\n- 国内访问可能不稳定\n适合：前端项目、Next.js 项目\n\n### Netlify ​\n\n官网：netlify.com\n\n简介：功能丰富的静态网站部署平台。\n\n免费额度：\n\n- 每月 100GB 流量\n- 每月 300 分钟构建时间\n- 表单提交 100 次/月\n优点：\n\n- 功能丰富（表单、身份认证、函数）\n- 界面友好\n- 插件生态好\n缺点：\n\n- 免费版功能有限制\n- 国内访问可能不稳定\n适合：静态网站、博客、文档网站\n\n### GitHub Pages ​\n\n官网：pages.github.com\n\n简介：GitHub 提供的免费静态网站托管服务。\n\n免费额度：\n\n- 完全免费\n- 每个仓库 1GB 存储\n- 每月 100GB 流量\n优点：\n\n- 完全免费\n- 和 GitHub 仓库直接绑定\n- 稳定可靠\n缺点：\n\n- 只能部署静态网站\n- 没有 Serverless 函数\n- 构建功能有限\n适合：个人博客、项目文档、简单静态网站\n\n### Railway ​\n\n官网：railway.app\n\n简介：适合部署有后端服务的应用。\n\n免费额度：\n\n- 每月 $5 免费额度\n- 用完需付费\n优点：\n\n- 支持后端服务（Node.js、Python 等）\n- 支持数据库\n- 部署简单\n缺点：\n\n- 免费额度较少\n- 用完就要付费\n适合：需要后端的完整应用\n\n### Cloudflare Pages ​\n\n官网：pages.cloudflare.com\n\n简介：Cloudflare 推出的静态网站托管服务。\n\n免费额度：\n\n- 无限请求\n- 无限流量\n- 每月 500 次构建\n优点：\n\n- 免费额度非常慷慨\n- 全球 CDN，速度极快\n- 和 Cloudflare 其他服务整合好\n缺点：\n\n- 功能相对简单\n- 学习曲线略陡\n适合：追求访问速度的静态网站\n\n## 选择建议 ​\n你的情况推荐平台第一次部署，想简单Vercel用 Next.jsVercel纯静态网站GitHub Pages / Netlify有后端需求Railway追求速度Cloudflare Pages国内访问稳定考虑国内云服务（阿里云、腾讯云）\n## 部署流程概览 ​\n\n基本流程：\n\n- 把代码推送到 GitHub\n- 在部署平台连接 GitHub 仓库\n- 平台自动检测、构建、部署\n- 获得一个可访问的网址\n新手建议\n\n第一次部署？选 Vercel。操作简单，文档齐全，社区活跃。遇到问题容易找到答案。",
      "word_count": 1526,
      "estimated_time": 3
    },
    {
      "id": "lesson-185",
      "chapter_id": "chapter-99",
      "lesson_number": 13,
      "title": "E.1 个人工具类（10 个）",
      "content": "# E.1 个人工具类（10 个） ​\n\n不知道做什么？从这里找灵感。每个项目都标注了难度和预计时长，选一个感兴趣的开始吧！\n\n## 1. 每日名言展示器 ​\n\n难度：⭐（入门）预计时长：30 分钟 - 1 小时核心技术点：HTML/CSS 基础、JavaScript 数组操作\n\n功能描述：\n\n- 每次打开显示一条随机名言\n- 点击按钮切换下一条\n- 可选：收藏喜欢的名言\n学到什么：网页基础结构、DOM 操作、数组随机取值\n\n## 2. 简易待办清单 ​\n\n难度：⭐⭐（基础）预计时长：1-2 小时核心技术点：LocalStorage、列表渲染、事件处理\n\n功能描述：\n\n- 添加待办事项\n- 标记完成/未完成\n- 删除事项\n- 刷新后数据还在\n学到什么：数据持久化、增删改查操作\n\n## 3. 番茄钟计时器 ​\n\n难度：⭐⭐（基础）预计时长：1-2 小时核心技术点：定时器、状态管理\n\n功能描述：\n\n- 25 分钟工作 + 5 分钟休息的循环\n- 开始/暂停/重置按钮\n- 倒计时显示\n- 时间到了有提醒\n学到什么：setInterval/setTimeout、时间格式化\n\n## 4. 个人记账本 ​\n\n难度：⭐⭐⭐（进阶）预计时长：2-4 小时核心技术点：表单处理、数据统计、LocalStorage\n\n功能描述：\n\n- 记录收入/支出\n- 分类标签\n- 查看当月统计\n- 简单的图表展示\n学到什么：表单验证、数据聚合计算\n\n## 5. 密码生成器 ​\n\n难度：⭐（入门）预计时长：30 分钟 - 1 小时核心技术点：随机数生成、字符串操作\n\n功能描述：\n\n- 选择密码长度\n- 选择包含的字符类型（大写、小写、数字、符号）\n- 一键生成随机密码\n- 复制到剪贴板\n学到什么：随机数、剪贴板 API\n\n## 6. 习惯打卡器 ​\n\n难度：⭐⭐（基础）预计时长：2-3 小时核心技术点：日期处理、LocalStorage、日历视图\n\n功能描述：\n\n- 创建要养成的习惯\n- 每天打卡\n- 查看连续打卡天数\n- 日历视图显示打卡记录\n学到什么：Date 对象、日历布局\n\n## 7. 个人书签收藏 ​\n\n难度：⭐⭐（基础）预计时长：1-2 小时核心技术点：链接管理、分类整理、搜索过滤\n\n功能描述：\n\n- 添加网站书签（名称+链接）\n- 分类管理\n- 搜索书签\n- 点击直接打开\n学到什么：列表过滤、URL 处理\n\n## 8. 简易笔记本 ​\n\n难度：⭐⭐（基础）预计时长：1-2 小时核心技术点：文本编辑、LocalStorage\n\n功能描述：\n\n- 创建/编辑/删除笔记\n- 笔记列表\n- 自动保存\n- 搜索笔记内容\n学到什么：文本区域处理、实时保存\n\n## 9. 倒计时页面 ​\n\n难度：⭐（入门）预计时长：30 分钟 - 1 小时核心技术点：日期计算、定时更新\n\n功能描述：\n\n- 设置目标日期（如生日、考试、假期）\n- 显示距离目标还有多少天/时/分/秒\n- 好看的倒计时展示\n学到什么：日期差值计算、动态更新页面\n\n## 10. 个人主页 / 链接树 ​\n\n难度：⭐（入门）预计时长：30 分钟 - 1 小时核心技术点：HTML/CSS 布局、响应式设计\n\n功能描述：\n\n- 头像和自我介绍\n- 社交媒体链接\n- 作品展示\n- 漂亮的个人风格\n学到什么：CSS 布局、个人品牌展示\n\n## 难度说明 ​\n难度含义建议⭐入门级，30分钟-1小时刚学完教程就能做⭐⭐基础级，1-2小时需要一点点练习⭐⭐⭐进阶级，2-4小时需要多轮迭代\n建议\n\n从 ⭐ 难度开始，做完一个再挑战下一个。完成比完美更重要。",
      "word_count": 1508,
      "estimated_time": 3
    },
    {
      "id": "lesson-186",
      "chapter_id": "chapter-99",
      "lesson_number": 14,
      "title": "E.2 效率工具类（10 个）",
      "content": "# E.2 效率工具类（10 个） ​\n\n这些项目能真正提高你的工作效率。做出来之后，你会每天都用。\n\n## 1. Markdown 预览器 ​\n\n难度：⭐⭐（基础）预计时长：1-2 小时核心技术点：Markdown 解析、实时预览\n\n功能描述：\n\n- 左侧输入 Markdown\n- 右侧实时显示渲染效果\n- 支持常用 Markdown 语法\n- 可选：导出为 HTML\n学到什么：第三方库使用（如 marked.js）、分栏布局\n\n## 2. JSON 格式化工具 ​\n\n难度：⭐⭐（基础）预计时长：1-2 小时核心技术点：JSON 解析、代码高亮\n\n功能描述：\n\n- 粘贴混乱的 JSON\n- 一键格式化/美化\n- 语法高亮显示\n- 错误提示\n学到什么：JSON.parse/stringify、错误处理\n\n## 3. 单位转换器 ​\n\n难度：⭐⭐（基础）预计时长：1-2 小时核心技术点：数学计算、单位映射\n\n功能描述：\n\n- 支持长度、重量、温度等单位转换\n- 输入一个值，显示其他单位的结果\n- 界面简洁易用\n学到什么：数值处理、select 下拉框\n\n## 4. 颜色工具箱 ​\n\n难度：⭐⭐（基础）预计时长：1-2 小时核心技术点：颜色格式转换、颜色选择器\n\n功能描述：\n\n- HEX/RGB/HSL 互转\n- 颜色选择器\n- 显示颜色预览\n- 复制颜色代码\n学到什么：颜色格式、input type=\"color\"\n\n## 5. 文本统计工具 ​\n\n难度：⭐（入门）预计时长：30 分钟 - 1 小时核心技术点：字符串处理\n\n功能描述：\n\n- 统计字数、字符数\n- 统计行数、段落数\n- 统计单词数（英文）\n- 实时更新\n学到什么：字符串方法、正则表达式基础\n\n## 6. 二维码生成器 ​\n\n难度：⭐⭐（基础）预计时长：1 小时核心技术点：第三方库使用\n\n功能描述：\n\n- 输入文字或链接\n- 生成二维码图片\n- 可下载保存\n- 可选：自定义颜色\n学到什么：使用 qrcode.js 等第三方库\n\n## 7. 剪贴板历史 ​\n\n难度：⭐⭐⭐（进阶）预计时长：2-3 小时核心技术点：剪贴板 API、历史记录\n\n功能描述：\n\n- 记录复制过的内容\n- 点击快速复制回去\n- 搜索历史记录\n- 可清除历史\n学到什么：Clipboard API、列表管理\n\n## 8. 快速笔记（便签） ​\n\n难度：⭐⭐（基础）预计时长：1-2 小时核心技术点：拖拽、LocalStorage\n\n功能描述：\n\n- 创建多个便签\n- 可拖动位置\n- 不同颜色区分\n- 自动保存\n学到什么：拖拽 API、位置存储\n\n## 9. 快捷短语管理 ​\n\n难度：⭐⭐（基础）预计时长：1-2 小时核心技术点：文本管理、快捷复制\n\n功能描述：\n\n- 保存常用短语/模板\n- 分类整理\n- 一键复制\n- 搜索\n学到什么：分类管理、剪贴板操作\n\n## 10. 网页截图标注 ​\n\n难度：⭐⭐⭐（进阶）预计时长：3-4 小时核心技术点：Canvas、图片处理\n\n功能描述：\n\n- 上传截图\n- 添加箭头、框、文字标注\n- 导出标注后的图片\n学到什么：Canvas 绑定、图片编辑基础\n\n## 效率工具的共同特点 ​\n\n好的效率工具应该：\n\n- 快：打开就能用，不需要登录\n- 简：功能聚焦，不堆砌\n- 存：数据本地保存，不丢失\n做效率工具的心法\n\n先问自己：「我每天重复做的事情有哪些？」然后把它做成工具。解决自己的问题，就是最好的项目 idea。",
      "word_count": 1463,
      "estimated_time": 3
    },
    {
      "id": "lesson-187",
      "chapter_id": "chapter-99",
      "lesson_number": 15,
      "title": "E.3 内容创作类（10 个）",
      "content": "# E.3 内容创作类（10 个） ​\n\n这些项目适合喜欢写作、创作的人。用 AI 帮你搭建自己的创作平台。\n\n## 1. 个人博客 ​\n\n难度：⭐⭐（基础）预计时长：2-3 小时核心技术点：页面布局、Markdown 渲染\n\n功能描述：\n\n- 文章列表页\n- 文章详情页\n- 分类/标签\n- 简洁的阅读体验\n学到什么：多页面结构、内容展示\n\n## 2. 作品集展示 ​\n\n难度：⭐⭐（基础）预计时长：2-3 小时核心技术点：图片展示、布局设计\n\n功能描述：\n\n- 作品卡片展示\n- 点击查看详情\n- 分类筛选\n- 响应式布局\n学到什么：网格布局、图片优化\n\n## 3. 写作计时器 ​\n\n难度：⭐（入门）预计时长：1 小时核心技术点：计时器、字数统计\n\n功能描述：\n\n- 设定写作时长\n- 专注模式（全屏写作）\n- 实时字数统计\n- 时间到了提醒\n学到什么：专注模式实现、计时逻辑\n\n## 4. 每日写作提示 ​\n\n难度：⭐（入门）预计时长：30 分钟 - 1 小时核心技术点：随机内容、日期判断\n\n功能描述：\n\n- 每天显示一个写作提示/灵感\n- 收藏喜欢的提示\n- 可以自己添加提示\n学到什么：日期处理、内容管理\n\n## 5. 微博/推特风格发布器 ​\n\n难度：⭐⭐（基础）预计时长：1-2 小时核心技术点：字符限制、时间线展示\n\n功能描述：\n\n- 限制字数的输入框\n- 发布后显示在时间线\n- 显示发布时间\n- 删除功能\n学到什么：字符限制、时间格式化\n\n## 6. 简易 Wiki ​\n\n难度：⭐⭐⭐（进阶）预计时长：3-4 小时核心技术点：内容编辑、链接关联\n\n功能描述：\n\n- 创建词条\n- Markdown 编辑\n- 词条之间可以相互链接\n- 搜索功能\n学到什么：内容管理系统基础\n\n## 7. 阅读清单 ​\n\n难度：⭐⭐（基础）预计时长：1-2 小时核心技术点：列表管理、状态切换\n\n功能描述：\n\n- 添加想读的书\n- 标记阅读状态（想读/在读/已读）\n- 添加读书笔记\n- 统计阅读数量\n学到什么：状态管理、筛选排序\n\n## 8. 写作目标追踪 ​\n\n难度：⭐⭐（基础）预计时长：1-2 小时核心技术点：目标设定、进度追踪\n\n功能描述：\n\n- 设定每日/每周写作目标（字数）\n- 记录每天完成的字数\n- 显示进度条\n- 统计完成率\n学到什么：进度可视化、数据统计\n\n## 9. 灵感收集箱 ​\n\n难度：⭐⭐（基础）预计时长：1-2 小时核心技术点：快速记录、标签分类\n\n功能描述：\n\n- 快速记录灵感（一句话就行）\n- 添加标签分类\n- 随机查看一条灵感\n- 搜索灵感\n学到什么：快速输入体验、标签系统\n\n## 10. 文章大纲生成器 ​\n\n难度：⭐⭐（基础）预计时长：1-2 小时核心技术点：树形结构、拖拽排序\n\n功能描述：\n\n- 创建文章大纲\n- 多级标题结构\n- 拖拽调整顺序\n- 导出为 Markdown\n学到什么：树形数据结构、拖拽交互\n\n## 内容创作者的工具心得 ​\n\n作为内容创作者，最好的工具应该：\n\n- 减少阻力：打开就能写，不要有复杂的操作\n- 专注内容：功能够用就行，不要干扰创作\n- 保护成果：自动保存，永不丢失\n建议\n\n如果你是写作者，从「写作计时器」或「每日写作提示」开始。边做边写，一举两得。",
      "word_count": 1372,
      "estimated_time": 3
    },
    {
      "id": "lesson-188",
      "chapter_id": "chapter-99",
      "lesson_number": 16,
      "title": "E.4 数据可视化类（10 个）",
      "content": "# E.4 数据可视化类（10 个） ​\n\n把数据变成图表，让信息一目了然。这类项目非常适合做数据分析、做报告的人。\n\n## 1. 个人支出饼图 ​\n\n难度：⭐⭐（基础）预计时长：1-2 小时核心技术点：Chart.js 使用、数据聚合\n\n功能描述：\n\n- 输入支出数据\n- 按分类生成饼图\n- 显示各分类占比\n- 可选择时间范围\n学到什么：图表库使用、数据处理\n\n## 2. 体重/健康追踪图 ​\n\n难度：⭐⭐（基础）预计时长：1-2 小时核心技术点：折线图、日期数据\n\n功能描述：\n\n- 每天记录体重/步数等\n- 折线图展示趋势\n- 显示平均值、最高/最低\n- 目标线标注\n学到什么：时间序列数据可视化\n\n## 3. 习惯热力图 ​\n\n难度：⭐⭐⭐（进阶）预计时长：2-3 小时核心技术点：热力图、日历视图\n\n功能描述：\n\n- 类似 GitHub 贡献图\n- 颜色深浅表示完成程度\n- 点击查看当天详情\n- 统计连续天数\n学到什么：热力图实现、CSS Grid\n\n## 4. 时间分配统计 ​\n\n难度：⭐⭐⭐（进阶）预计时长：2-3 小时核心技术点：计时器、环形图\n\n功能描述：\n\n- 记录时间花在哪里\n- 分类统计（工作/学习/娱乐等）\n- 环形图展示占比\n- 周/月统计\n学到什么：时间追踪、多种图表\n\n## 5. 投票/调查结果展示 ​\n\n难度：⭐⭐（基础）预计时长：1-2 小时核心技术点：柱状图、实时更新\n\n功能描述：\n\n- 创建投票选项\n- 用户投票\n- 实时显示投票结果\n- 柱状图可视化\n学到什么：实时数据更新、柱状图\n\n## 6. 项目进度仪表盘 ​\n\n难度：⭐⭐⭐（进阶）预计时长：2-3 小时核心技术点：进度条、多图表组合\n\n功能描述：\n\n- 项目任务列表\n- 完成进度百分比\n- 多维度统计\n- 仪表盘布局\n学到什么：仪表盘设计、多图表布局\n\n## 7. 简易股票/币价图表 ​\n\n难度：⭐⭐⭐（进阶）预计时长：2-3 小时核心技术点：API 调用、实时数据\n\n功能描述：\n\n- 输入股票/加密货币代码\n- 显示价格走势图\n- K 线图基础版\n- 自动刷新\n学到什么：API 调用、金融图表\n\n## 8. 学习时长统计 ​\n\n难度：⭐⭐（基础）预计时长：1-2 小时核心技术点：计时器、统计图表\n\n功能描述：\n\n- 学习计时（开始/结束）\n- 分科目记录\n- 日/周/月统计\n- 图表展示\n学到什么：时间统计、多维度展示\n\n## 9. 目标完成雷达图 ​\n\n难度：⭐⭐⭐（进阶）预计时长：2-3 小时核心技术点：雷达图、多维度数据\n\n功能描述：\n\n- 设定多个目标维度\n- 给每个维度打分\n- 雷达图展示完成情况\n- 对比不同时期\n学到什么：雷达图实现、多维度分析\n\n## 10. 简易数据看板 ​\n\n难度：⭐⭐⭐（进阶）预计时长：3-4 小时核心技术点：多图表、布局设计\n\n功能描述：\n\n- 数字卡片（总数、增长率等）\n- 多个图表组合\n- 响应式布局\n- 可选择时间范围\n学到什么：仪表盘设计、数据大屏基础\n\n## 数据可视化常用图表库 ​\n库名特点适合场景Chart.js简单易用入门首选ECharts功能强大复杂图表D3.js灵活度最高高度定制ApexCharts现代美观追求颜值\n建议\n\n先用 Chart.js 入门，它的文档清晰，上手最快。等熟悉了再尝试其他库。\n\n## 数据可视化的核心原则 ​\n\n- 清晰：一眼能看懂在说什么\n- 准确：数据不能误导\n- 美观：颜色协调、布局合理\n- 交互：鼠标悬停显示详情\n注意\n\n做数据可视化项目时，先用假数据把图表做出来，最后再接真实数据。这样迭代更快。",
      "word_count": 1518,
      "estimated_time": 3
    }
  ]
}